!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.8	//
AcceptDragDropPayload	imgui.cpp	/^const ImGuiPayload* ImGui::AcceptDragDropPayload(const char* type, ImGuiDragDropFlags flags)$/;"	f	class:ImGui
ActivateItem	imgui.cpp	/^void ImGui::ActivateItem(ImGuiID id)$/;"	f	class:ImGui
Active	imgui_internal.h	/^    bool                    Active;                             \/\/ Set to true on Begin(), unless Collapsed$/;"	m	struct:ImGuiWindow
ActiveId	imgui_internal.h	/^    ImGuiID                 ActiveId;                           \/\/ Active widget$/;"	m	struct:ImGuiContext
ActiveIdAllowOverlap	imgui_internal.h	/^    bool                    ActiveIdAllowOverlap;               \/\/ Active widget allows another widget to steal active id (generally for overlapping widgets, but not always)$/;"	m	struct:ImGuiContext
ActiveIdClickOffset	imgui_internal.h	/^    ImVec2                  ActiveIdClickOffset;                \/\/ Clicked offset from upper-left corner, if applicable (currently only set by ButtonBehavior)$/;"	m	struct:ImGuiContext
ActiveIdHasBeenEditedBefore	imgui_internal.h	/^    bool                    ActiveIdHasBeenEditedBefore;        \/\/ Was the value associated to the widget Edited over the course of the Active state.$/;"	m	struct:ImGuiContext
ActiveIdHasBeenEditedThisFrame	imgui_internal.h	/^    bool                    ActiveIdHasBeenEditedThisFrame;$/;"	m	struct:ImGuiContext
ActiveIdHasBeenPressedBefore	imgui_internal.h	/^    bool                    ActiveIdHasBeenPressedBefore;       \/\/ Track whether the active id led to a press (this is to allow changing between PressOnClick and PressOnRelease without pressing twice). Used by range_select branch.$/;"	m	struct:ImGuiContext
ActiveIdIsAlive	imgui_internal.h	/^    ImGuiID                 ActiveIdIsAlive;                    \/\/ Active widget has been seen this frame (we can't use a bool as the ActiveId may change within the frame)$/;"	m	struct:ImGuiContext
ActiveIdIsJustActivated	imgui_internal.h	/^    bool                    ActiveIdIsJustActivated;            \/\/ Set at the time of activation for one frame$/;"	m	struct:ImGuiContext
ActiveIdMouseButton	imgui_internal.h	/^    int                     ActiveIdMouseButton;$/;"	m	struct:ImGuiContext
ActiveIdNoClearOnFocusLoss	imgui_internal.h	/^    bool                    ActiveIdNoClearOnFocusLoss;         \/\/ Disable losing active id if the active id window gets unfocused.$/;"	m	struct:ImGuiContext
ActiveIdPreviousFrame	imgui_internal.h	/^    ImGuiID                 ActiveIdPreviousFrame;$/;"	m	struct:ImGuiContext
ActiveIdPreviousFrameHasBeenEditedBefore	imgui_internal.h	/^    bool                    ActiveIdPreviousFrameHasBeenEditedBefore;$/;"	m	struct:ImGuiContext
ActiveIdPreviousFrameIsAlive	imgui_internal.h	/^    bool                    ActiveIdPreviousFrameIsAlive;$/;"	m	struct:ImGuiContext
ActiveIdPreviousFrameWindow	imgui_internal.h	/^    ImGuiWindow*            ActiveIdPreviousFrameWindow;$/;"	m	struct:ImGuiContext
ActiveIdSource	imgui_internal.h	/^    ImGuiInputSource        ActiveIdSource;                     \/\/ Activating with mouse or nav (gamepad\/keyboard)$/;"	m	struct:ImGuiContext
ActiveIdTimer	imgui_internal.h	/^    float                   ActiveIdTimer;$/;"	m	struct:ImGuiContext
ActiveIdUsingKeyInputMask	imgui_internal.h	/^    ImU64                   ActiveIdUsingKeyInputMask;          \/\/ Active widget will want to read those key inputs. When we grow the ImGuiKey enum we'll need to either to order the enum to make useful keys come first, either redesign this into e.g. a small array.$/;"	m	struct:ImGuiContext
ActiveIdUsingMouseWheel	imgui_internal.h	/^    bool                    ActiveIdUsingMouseWheel;            \/\/ Active widget will want to read mouse wheel. Blocks scrolling the underlying window.$/;"	m	struct:ImGuiContext
ActiveIdUsingNavDirMask	imgui_internal.h	/^    ImU32                   ActiveIdUsingNavDirMask;            \/\/ Active widget will want to read those nav move requests (e.g. can activate a button and move away from it)$/;"	m	struct:ImGuiContext
ActiveIdUsingNavInputMask	imgui_internal.h	/^    ImU32                   ActiveIdUsingNavInputMask;          \/\/ Active widget will want to read those nav inputs.$/;"	m	struct:ImGuiContext
ActiveIdWindow	imgui_internal.h	/^    ImGuiWindow*            ActiveIdWindow;$/;"	m	struct:ImGuiContext
Add	imgui_internal.h	/^    T*          Add()                               { int idx = FreeIdx; if (idx == Buf.Size) { Buf.resize(Buf.Size + 1); FreeIdx++; } else { FreeIdx = *(int*)&Buf[idx]; } IM_PLACEMENT_NEW(&Buf[idx]) T(); return &Buf[idx]; }$/;"	f	struct:ImPool
Add	imgui_internal.h	/^    void        Add(const ImRect& r)                { if (Min.x > r.Min.x) Min.x = r.Min.x; if (Min.y > r.Min.y) Min.y = r.Min.y; if (Max.x < r.Max.x) Max.x = r.Max.x; if (Max.y < r.Max.y) Max.y = r.Max.y; }$/;"	f	struct:ImRect
Add	imgui_internal.h	/^    void        Add(const ImVec2& p)                { if (Min.x > p.x)     Min.x = p.x;     if (Min.y > p.y)     Min.y = p.y;     if (Max.x < p.x)     Max.x = p.x;     if (Max.y < p.y)     Max.y = p.y; }$/;"	f	struct:ImRect
AddBezierCubic	imgui_draw.cpp	/^void ImDrawList::AddBezierCubic(const ImVec2& p1, const ImVec2& p2, const ImVec2& p3, const ImVec2& p4, ImU32 col, float thickness, int num_segments)$/;"	f	class:ImDrawList
AddBezierCurve	imgui.h	/^    inline    void  AddBezierCurve(const ImVec2& p1, const ImVec2& p2, const ImVec2& p3, const ImVec2& p4, ImU32 col, float thickness, int num_segments = 0) { AddBezierCubic(p1, p2, p3, p4, col, thickness, num_segments); }$/;"	f	struct:ImDrawList
AddBezierQuadratic	imgui_draw.cpp	/^void ImDrawList::AddBezierQuadratic(const ImVec2& p1, const ImVec2& p2, const ImVec2& p3, ImU32 col, float thickness, int num_segments)$/;"	f	class:ImDrawList
AddCallback	imgui_draw.cpp	/^void ImDrawList::AddCallback(ImDrawCallback callback, void* callback_data)$/;"	f	class:ImDrawList
AddChar	imgui.h	/^    inline void     AddChar(ImWchar c)      { SetBit(c); }                      \/\/ Add character$/;"	f	struct:ImFontGlyphRangesBuilder
AddCircle	imgui_draw.cpp	/^void ImDrawList::AddCircle(const ImVec2& center, float radius, ImU32 col, int num_segments, float thickness)$/;"	f	class:ImDrawList
AddCircleFilled	imgui_draw.cpp	/^void ImDrawList::AddCircleFilled(const ImVec2& center, float radius, ImU32 col, int num_segments)$/;"	f	class:ImDrawList
AddContextHook	imgui.cpp	/^ImGuiID ImGui::AddContextHook(ImGuiContext* ctx, const ImGuiContextHook* hook)$/;"	f	class:ImGui
AddConvexPolyFilled	imgui_draw.cpp	/^void ImDrawList::AddConvexPolyFilled(const ImVec2* points, const int points_count, ImU32 col)$/;"	f	class:ImDrawList
AddCustomRectFontGlyph	imgui_draw.cpp	/^int ImFontAtlas::AddCustomRectFontGlyph(ImFont* font, ImWchar id, int width, int height, float advance_x, const ImVec2& offset)$/;"	f	class:ImFontAtlas
AddCustomRectRegular	imgui_draw.cpp	/^int ImFontAtlas::AddCustomRectRegular(int width, int height)$/;"	f	class:ImFontAtlas
AddDrawCmd	imgui_draw.cpp	/^void ImDrawList::AddDrawCmd()$/;"	f	class:ImDrawList
AddDrawListToDrawData	imgui.cpp	/^static void AddDrawListToDrawData(ImVector<ImDrawList*>* out_list, ImDrawList* draw_list)$/;"	f	file:
AddFont	imgui_draw.cpp	/^ImFont* ImFontAtlas::AddFont(const ImFontConfig* font_cfg)$/;"	f	class:ImFontAtlas
AddFontDefault	imgui_draw.cpp	/^ImFont* ImFontAtlas::AddFontDefault(const ImFontConfig* font_cfg_template)$/;"	f	class:ImFontAtlas
AddFontFromFileTTF	imgui_draw.cpp	/^ImFont* ImFontAtlas::AddFontFromFileTTF(const char* filename, float size_pixels, const ImFontConfig* font_cfg_template, const ImWchar* glyph_ranges)$/;"	f	class:ImFontAtlas
AddFontFromMemoryCompressedBase85TTF	imgui_draw.cpp	/^ImFont* ImFontAtlas::AddFontFromMemoryCompressedBase85TTF(const char* compressed_ttf_data_base85, float size_pixels, const ImFontConfig* font_cfg, const ImWchar* glyph_ranges)$/;"	f	class:ImFontAtlas
AddFontFromMemoryCompressedTTF	imgui_draw.cpp	/^ImFont* ImFontAtlas::AddFontFromMemoryCompressedTTF(const void* compressed_ttf_data, int compressed_ttf_size, float size_pixels, const ImFontConfig* font_cfg_template, const ImWchar* glyph_ranges)$/;"	f	class:ImFontAtlas
AddFontFromMemoryTTF	imgui_draw.cpp	/^ImFont* ImFontAtlas::AddFontFromMemoryTTF(void* ttf_data, int ttf_size, float size_pixels, const ImFontConfig* font_cfg_template, const ImWchar* glyph_ranges)$/;"	f	class:ImFontAtlas
AddGlyph	imgui_draw.cpp	/^void ImFont::AddGlyph(const ImFontConfig* cfg, ImWchar codepoint, float x0, float y0, float x1, float y1, float u0, float v0, float u1, float v1, float advance_x)$/;"	f	class:ImFont
AddImage	imgui_draw.cpp	/^void ImDrawList::AddImage(ImTextureID user_texture_id, const ImVec2& p_min, const ImVec2& p_max, const ImVec2& uv_min, const ImVec2& uv_max, ImU32 col)$/;"	f	class:ImDrawList
AddImageQuad	imgui_draw.cpp	/^void ImDrawList::AddImageQuad(ImTextureID user_texture_id, const ImVec2& p1, const ImVec2& p2, const ImVec2& p3, const ImVec2& p4, const ImVec2& uv1, const ImVec2& uv2, const ImVec2& uv3, const ImVec2& uv4, ImU32 col)$/;"	f	class:ImDrawList
AddImageRounded	imgui_draw.cpp	/^void ImDrawList::AddImageRounded(ImTextureID user_texture_id, const ImVec2& p_min, const ImVec2& p_max, const ImVec2& uv_min, const ImVec2& uv_max, ImU32 col, float rounding, ImDrawFlags flags)$/;"	f	class:ImDrawList
AddInputCharacter	imgui.cpp	/^void ImGuiIO::AddInputCharacter(unsigned int c)$/;"	f	class:ImGuiIO
AddInputCharacterUTF16	imgui.cpp	/^void ImGuiIO::AddInputCharacterUTF16(ImWchar16 c)$/;"	f	class:ImGuiIO
AddInputCharactersUTF8	imgui.cpp	/^void ImGuiIO::AddInputCharactersUTF8(const char* utf8_chars)$/;"	f	class:ImGuiIO
AddLine	imgui_draw.cpp	/^void ImDrawList::AddLine(const ImVec2& p1, const ImVec2& p2, ImU32 col, float thickness)$/;"	f	class:ImDrawList
AddNgon	imgui_draw.cpp	/^void ImDrawList::AddNgon(const ImVec2& center, float radius, ImU32 col, int num_segments, float thickness)$/;"	f	class:ImDrawList
AddNgonFilled	imgui_draw.cpp	/^void ImDrawList::AddNgonFilled(const ImVec2& center, float radius, ImU32 col, int num_segments)$/;"	f	class:ImDrawList
AddPolyline	imgui_draw.cpp	/^void ImDrawList::AddPolyline(const ImVec2* points, const int points_count, ImU32 col, ImDrawFlags flags, float thickness)$/;"	f	class:ImDrawList
AddQuad	imgui_draw.cpp	/^void ImDrawList::AddQuad(const ImVec2& p1, const ImVec2& p2, const ImVec2& p3, const ImVec2& p4, ImU32 col, float thickness)$/;"	f	class:ImDrawList
AddQuadFilled	imgui_draw.cpp	/^void ImDrawList::AddQuadFilled(const ImVec2& p1, const ImVec2& p2, const ImVec2& p3, const ImVec2& p4, ImU32 col)$/;"	f	class:ImDrawList
AddRanges	imgui_draw.cpp	/^void ImFontGlyphRangesBuilder::AddRanges(const ImWchar* ranges)$/;"	f	class:ImFontGlyphRangesBuilder
AddRect	imgui_draw.cpp	/^void ImDrawList::AddRect(const ImVec2& p_min, const ImVec2& p_max, ImU32 col, float rounding, ImDrawFlags flags, float thickness)$/;"	f	class:ImDrawList
AddRectFilled	imgui_draw.cpp	/^void ImDrawList::AddRectFilled(const ImVec2& p_min, const ImVec2& p_max, ImU32 col, float rounding, ImDrawFlags flags)$/;"	f	class:ImDrawList
AddRectFilledMultiColor	imgui_draw.cpp	/^void ImDrawList::AddRectFilledMultiColor(const ImVec2& p_min, const ImVec2& p_max, ImU32 col_upr_left, ImU32 col_upr_right, ImU32 col_bot_right, ImU32 col_bot_left)$/;"	f	class:ImDrawList
AddRemapChar	imgui_draw.cpp	/^void ImFont::AddRemapChar(ImWchar dst, ImWchar src, bool overwrite_dst)$/;"	f	class:ImFont
AddRootWindowToDrawData	imgui.cpp	/^static void AddRootWindowToDrawData(ImGuiWindow* window)$/;"	f	file:
AddText	imgui_draw.cpp	/^void ImDrawList::AddText(const ImFont* font, float font_size, const ImVec2& pos, ImU32 col, const char* text_begin, const char* text_end, float wrap_width, const ImVec4* cpu_fine_clip_rect)$/;"	f	class:ImDrawList
AddText	imgui_draw.cpp	/^void ImDrawList::AddText(const ImVec2& pos, ImU32 col, const char* text_begin, const char* text_end)$/;"	f	class:ImDrawList
AddText	imgui_draw.cpp	/^void ImFontGlyphRangesBuilder::AddText(const char* text, const char* text_end)$/;"	f	class:ImFontGlyphRangesBuilder
AddTriangle	imgui_draw.cpp	/^void ImDrawList::AddTriangle(const ImVec2& p1, const ImVec2& p2, const ImVec2& p3, ImU32 col, float thickness)$/;"	f	class:ImDrawList
AddTriangleFilled	imgui_draw.cpp	/^void ImDrawList::AddTriangleFilled(const ImVec2& p1, const ImVec2& p2, const ImVec2& p3, ImU32 col)$/;"	f	class:ImDrawList
AddWindowToDrawData	imgui.cpp	/^static void AddWindowToDrawData(ImGuiWindow* window, int layer)$/;"	f	file:
AddWindowToSortBuffer	imgui.cpp	/^static void AddWindowToSortBuffer(ImVector<ImGuiWindow*>* out_sorted_windows, ImGuiWindow* window)$/;"	f	file:
AdvanceX	imgui.h	/^    float           AdvanceX;           \/\/ Distance to next character (= data from font + ImFontConfig::GlyphExtraSpacing.x baked in)$/;"	m	struct:ImFontGlyph
AlignTextToFramePadding	imgui_widgets.cpp	/^void ImGui::AlignTextToFramePadding()$/;"	f	class:ImGui
Alpha	imgui.h	/^    float       Alpha;                      \/\/ Global alpha applies to everything in Dear ImGui.$/;"	m	struct:ImGuiStyle
AngleMax12	imgui.cpp	/^    int     AngleMin12, AngleMax12;$/;"	m	struct:ImGuiResizeGripDef	file:
AngleMin12	imgui.cpp	/^    int     AngleMin12, AngleMax12;$/;"	m	struct:ImGuiResizeGripDef	file:
AntiAliasedFill	imgui.h	/^    bool        AntiAliasedFill;            \/\/ Enable anti-aliased edges around filled shapes (rounded rectangles, circles, etc.). Disable if you are really tight on CPU\/GPU. Latched at the beginning of the frame (copied to ImDrawList).$/;"	m	struct:ImGuiStyle
AntiAliasedLines	imgui.h	/^    bool        AntiAliasedLines;           \/\/ Enable anti-aliased lines\/borders. Disable if you are really tight on CPU\/GPU. Latched at the beginning of the frame (copied to ImDrawList).$/;"	m	struct:ImGuiStyle
AntiAliasedLinesUseTex	imgui.h	/^    bool        AntiAliasedLinesUseTex;     \/\/ Enable anti-aliased lines\/borders using textures where possible. Require backend to render with bilinear filtering. Latched at the beginning of the frame (copied to ImDrawList).$/;"	m	struct:ImGuiStyle
Appearing	imgui_internal.h	/^    bool                    Appearing;                          \/\/ Set during the frame where the window is appearing (or re-appearing)$/;"	m	struct:ImGuiWindow
ApplyAllFn	imgui_internal.h	/^    void        (*ApplyAllFn)(ImGuiContext* ctx, ImGuiSettingsHandler* handler);                                \/\/ Read: Called after reading (in registration order)$/;"	m	struct:ImGuiSettingsHandler
ApplyWindowSettings	imgui.cpp	/^static void ApplyWindowSettings(ImGuiWindow* window, ImGuiWindowSettings* settings)$/;"	f	file:
ArcFastRadiusCutoff	imgui_internal.h	/^    float           ArcFastRadiusCutoff;                        \/\/ Cutoff radius after which arc drawing will fallback to slower PathArcTo()$/;"	m	struct:ImDrawListSharedData
ArcFastVtx	imgui_internal.h	/^    ImVec2          ArcFastVtx[IM_DRAWLIST_ARCFAST_TABLE_SIZE]; \/\/ Sample points on the quarter of the circle.$/;"	m	struct:ImDrawListSharedData
ArrowButton	imgui_widgets.cpp	/^bool ImGui::ArrowButton(const char* str_id, ImGuiDir dir)$/;"	f	class:ImGui
ArrowButtonEx	imgui_widgets.cpp	/^bool ImGui::ArrowButtonEx(const char* str_id, ImGuiDir dir, ImVec2 size, ImGuiButtonFlags flags)$/;"	f	class:ImGui
Ascent	imgui.h	/^    float                       Ascent, Descent;    \/\/ 4+4   \/\/ out \/\/            \/\/ Ascent: distance from top to bottom of e.g. 'A' [0..FontSize]$/;"	m	struct:ImFont
AutoFitChildAxises	imgui_internal.h	/^    ImS8                    AutoFitChildAxises;$/;"	m	struct:ImGuiWindow
AutoFitFramesX	imgui_internal.h	/^    ImS8                    AutoFitFramesX, AutoFitFramesY;$/;"	m	struct:ImGuiWindow
AutoFitFramesY	imgui_internal.h	/^    ImS8                    AutoFitFramesX, AutoFitFramesY;$/;"	m	struct:ImGuiWindow
AutoFitOnlyGrows	imgui_internal.h	/^    bool                    AutoFitOnlyGrows;$/;"	m	struct:ImGuiWindow
AutoFitQueue	imgui_internal.h	/^    ImU8                    AutoFitQueue;                   \/\/ Queue of 8 values for the next 8 frames to request auto-fit$/;"	m	struct:ImGuiTableColumn
AutoFitSingleColumn	imgui_internal.h	/^    ImGuiTableColumnIdx         AutoFitSingleColumn;        \/\/ Index of single column requesting auto-fit.$/;"	m	struct:ImGuiTable
AutoPosLastDirection	imgui_internal.h	/^    ImGuiDir                AutoPosLastDirection;$/;"	m	struct:ImGuiWindow
AutoScroll	imgui_demo.cpp	/^    bool                  AutoScroll;$/;"	m	struct:ExampleAppConsole	file:
AutoScroll	imgui_demo.cpp	/^    bool                AutoScroll;  \/\/ Keep scrolling if already at the bottom.$/;"	m	struct:ExampleAppLog	file:
BackendFlags	imgui.h	/^    ImGuiBackendFlags  BackendFlags;            \/\/ = 0              \/\/ See ImGuiBackendFlags_ enum. Set by backend (imgui_impl_xxx files or custom backend) to communicate features supported by the backend.$/;"	m	struct:ImGuiIO
BackendLanguageUserData	imgui.h	/^    void*       BackendLanguageUserData;        \/\/ = NULL           \/\/ User data for non C++ programming language backend$/;"	m	struct:ImGuiIO
BackendPlatformName	imgui.h	/^    const char* BackendPlatformName;            \/\/ = NULL$/;"	m	struct:ImGuiIO
BackendPlatformUserData	imgui.h	/^    void*       BackendPlatformUserData;        \/\/ = NULL           \/\/ User data for platform backend$/;"	m	struct:ImGuiIO
BackendRendererName	imgui.h	/^    const char* BackendRendererName;            \/\/ = NULL$/;"	m	struct:ImGuiIO
BackendRendererUserData	imgui.h	/^    void*       BackendRendererUserData;        \/\/ = NULL           \/\/ User data for renderer backend$/;"	m	struct:ImGuiIO
Backup	imgui_internal.h	/^    void Backup()           { ImGuiWindow* window = GImGui->CurrentWindow; LastItemId = window->DC.LastItemId; LastItemStatusFlags = window->DC.LastItemStatusFlags; LastItemRect = window->DC.LastItemRect; LastItemDisplayRect = window->DC.LastItemDisplayRect; }$/;"	f	struct:ImGuiLastItemDataBackup
BackupActiveIdIsAlive	imgui_internal.h	/^    ImGuiID     BackupActiveIdIsAlive;$/;"	m	struct:ImGuiGroupData
BackupActiveIdPreviousFrameIsAlive	imgui_internal.h	/^    bool        BackupActiveIdPreviousFrameIsAlive;$/;"	m	struct:ImGuiGroupData
BackupCurrLineSize	imgui_internal.h	/^    ImVec2      BackupCurrLineSize;$/;"	m	struct:ImGuiGroupData
BackupCurrLineTextBaseOffset	imgui_internal.h	/^    float       BackupCurrLineTextBaseOffset;$/;"	m	struct:ImGuiGroupData
BackupCursorMaxPos	imgui_internal.h	/^    ImVec2      BackupCursorMaxPos;$/;"	m	struct:ImGuiGroupData
BackupCursorPos	imgui_internal.h	/^    ImVec2              BackupCursorPos;$/;"	m	struct:ImGuiTabBar
BackupCursorPos	imgui_internal.h	/^    ImVec2      BackupCursorPos;$/;"	m	struct:ImGuiGroupData
BackupFloat	imgui_internal.h	/^    union           { int BackupInt[2]; float BackupFloat[2]; };$/;"	m	union:ImGuiStyleMod::__anon25
BackupGroupOffset	imgui_internal.h	/^    ImVec1      BackupGroupOffset;$/;"	m	struct:ImGuiGroupData
BackupHoveredIdIsAlive	imgui_internal.h	/^    bool        BackupHoveredIdIsAlive;$/;"	m	struct:ImGuiGroupData
BackupIndent	imgui_internal.h	/^    ImVec1      BackupIndent;$/;"	m	struct:ImGuiGroupData
BackupInt	imgui_internal.h	/^    union           { int BackupInt[2]; float BackupFloat[2]; };$/;"	m	union:ImGuiStyleMod::__anon25
BackupValue	imgui_internal.h	/^    ImVec4      BackupValue;$/;"	m	struct:ImGuiColorMod
BarRect	imgui_internal.h	/^    ImRect              BarRect;$/;"	m	struct:ImGuiTabBar
BasePtr	imgui_internal.h	/^    char*   BasePtr;$/;"	m	struct:ImSpanAllocator
Begin	imgui.cpp	/^bool ImGui::Begin(const char* name, bool* p_open, ImGuiWindowFlags flags)$/;"	f	class:ImGui
Begin	imgui.cpp	/^void ImGuiListClipper::Begin(int items_count, float items_height)$/;"	f	class:ImGuiListClipper
BeginChild	imgui.cpp	/^bool ImGui::BeginChild(ImGuiID id, const ImVec2& size_arg, bool border, ImGuiWindowFlags extra_flags)$/;"	f	class:ImGui
BeginChild	imgui.cpp	/^bool ImGui::BeginChild(const char* str_id, const ImVec2& size_arg, bool border, ImGuiWindowFlags extra_flags)$/;"	f	class:ImGui
BeginChildEx	imgui.cpp	/^bool ImGui::BeginChildEx(const char* name, ImGuiID id, const ImVec2& size_arg, bool border, ImGuiWindowFlags flags)$/;"	f	class:ImGui
BeginChildFrame	imgui.cpp	/^bool ImGui::BeginChildFrame(ImGuiID id, const ImVec2& size, ImGuiWindowFlags extra_flags)$/;"	f	class:ImGui
BeginColumns	imgui_tables.cpp	/^void ImGui::BeginColumns(const char* str_id, int columns_count, ImGuiOldColumnFlags flags)$/;"	f	class:ImGui
BeginCombo	imgui_widgets.cpp	/^bool ImGui::BeginCombo(const char* label, const char* preview_value, ImGuiComboFlags flags)$/;"	f	class:ImGui
BeginCount	imgui_internal.h	/^    ImS8                BeginCount;$/;"	m	struct:ImGuiTabBar
BeginCount	imgui_internal.h	/^    short                   BeginCount;                         \/\/ Number of Begin() during the current frame (generally 0 or 1, 1+ if appending via multiple Begin\/End pairs)$/;"	m	struct:ImGuiWindow
BeginDragDropSource	imgui.cpp	/^bool ImGui::BeginDragDropSource(ImGuiDragDropFlags flags)$/;"	f	class:ImGui
BeginDragDropTarget	imgui.cpp	/^bool ImGui::BeginDragDropTarget()$/;"	f	class:ImGui
BeginDragDropTargetCustom	imgui.cpp	/^bool ImGui::BeginDragDropTargetCustom(const ImRect& bb, ImGuiID id)$/;"	f	class:ImGui
BeginGroup	imgui.cpp	/^void ImGui::BeginGroup()$/;"	f	class:ImGui
BeginListBox	imgui_widgets.cpp	/^bool ImGui::BeginListBox(const char* label, const ImVec2& size_arg)$/;"	f	class:ImGui
BeginMainMenuBar	imgui_widgets.cpp	/^bool ImGui::BeginMainMenuBar()$/;"	f	class:ImGui
BeginMenu	imgui_widgets.cpp	/^bool ImGui::BeginMenu(const char* label, bool enabled)$/;"	f	class:ImGui
BeginMenuBar	imgui_widgets.cpp	/^bool ImGui::BeginMenuBar()$/;"	f	class:ImGui
BeginOrder	imgui_internal.h	/^    ImS16               BeginOrder;             \/\/ BeginTabItem() order, used to re-order tabs after toggling ImGuiTabBarFlags_Reorderable$/;"	m	struct:ImGuiTabItem
BeginOrderWithinContext	imgui_internal.h	/^    short                   BeginOrderWithinContext;            \/\/ Begin() order within entire imgui context. This is mostly used for debugging submission order related issues.$/;"	m	struct:ImGuiWindow
BeginOrderWithinParent	imgui_internal.h	/^    short                   BeginOrderWithinParent;             \/\/ Begin() order within immediate parent window, if we are a child window. Otherwise 0.$/;"	m	struct:ImGuiWindow
BeginPopup	imgui.cpp	/^bool ImGui::BeginPopup(const char* str_id, ImGuiWindowFlags flags)$/;"	f	class:ImGui
BeginPopupContextItem	imgui.cpp	/^bool ImGui::BeginPopupContextItem(const char* str_id, ImGuiPopupFlags popup_flags)$/;"	f	class:ImGui
BeginPopupContextVoid	imgui.cpp	/^bool ImGui::BeginPopupContextVoid(const char* str_id, ImGuiPopupFlags popup_flags)$/;"	f	class:ImGui
BeginPopupContextWindow	imgui.cpp	/^bool ImGui::BeginPopupContextWindow(const char* str_id, ImGuiPopupFlags popup_flags)$/;"	f	class:ImGui
BeginPopupContextWindow	imgui.h	/^    static inline bool  BeginPopupContextWindow(const char* str_id, ImGuiMouseButton mb, bool over_items) { return BeginPopupContextWindow(str_id, mb | (over_items ? 0 : ImGuiPopupFlags_NoOpenOverItems)); }$/;"	f	namespace:ImGui
BeginPopupEx	imgui.cpp	/^bool ImGui::BeginPopupEx(ImGuiID id, ImGuiWindowFlags flags)$/;"	f	class:ImGui
BeginPopupModal	imgui.cpp	/^bool ImGui::BeginPopupModal(const char* name, bool* p_open, ImGuiWindowFlags flags)$/;"	f	class:ImGui
BeginPopupStack	imgui_internal.h	/^    ImVector<ImGuiPopupData>BeginPopupStack;                    \/\/ Which level of BeginPopup() we are in (reset every frame)$/;"	m	struct:ImGuiContext
BeginTabBar	imgui_widgets.cpp	/^bool    ImGui::BeginTabBar(const char* str_id, ImGuiTabBarFlags flags)$/;"	f	class:ImGui
BeginTabBarEx	imgui_widgets.cpp	/^bool    ImGui::BeginTabBarEx(ImGuiTabBar* tab_bar, const ImRect& tab_bar_bb, ImGuiTabBarFlags flags)$/;"	f	class:ImGui
BeginTabItem	imgui_widgets.cpp	/^bool    ImGui::BeginTabItem(const char* label, bool* p_open, ImGuiTabItemFlags flags)$/;"	f	class:ImGui
BeginTable	imgui_tables.cpp	/^bool    ImGui::BeginTable(const char* str_id, int columns_count, ImGuiTableFlags flags, const ImVec2& outer_size, float inner_width)$/;"	f	class:ImGui
BeginTableEx	imgui_tables.cpp	/^bool    ImGui::BeginTableEx(const char* name, ImGuiID id, int columns_count, ImGuiTableFlags flags, const ImVec2& outer_size, float inner_width)$/;"	f	class:ImGui
BeginTooltip	imgui.cpp	/^void ImGui::BeginTooltip()$/;"	f	class:ImGui
BeginTooltipEx	imgui.cpp	/^void ImGui::BeginTooltipEx(ImGuiWindowFlags extra_flags, ImGuiTooltipFlags tooltip_flags)$/;"	f	class:ImGui
BeginViewportSideBar	imgui_widgets.cpp	/^bool ImGui::BeginViewportSideBar(const char* name, ImGuiViewport* viewport_p, ImGuiDir dir, float axis_size, ImGuiWindowFlags window_flags)$/;"	f	class:ImGui
Bg0ClipRectForDrawCmd	imgui_internal.h	/^    ImRect                      Bg0ClipRectForDrawCmd;      \/\/ Actual ImDrawCmd clip rect for BG0\/1 channel. This tends to be == OuterWindow->ClipRect at BeginTable() because output in BG0\/BG1 is cpu-clipped$/;"	m	struct:ImGuiTable
Bg2ClipRectForDrawCmd	imgui_internal.h	/^    ImRect                      Bg2ClipRectForDrawCmd;      \/\/ Actual ImDrawCmd clip rect for BG2 channel. This tends to be a correct, tight-fit, because output to BG2 are done by widgets relying on regular ClipRect.$/;"	m	struct:ImGuiTable
Bg2DrawChannelCurrent	imgui_internal.h	/^    ImGuiTableDrawChannelIdx    Bg2DrawChannelCurrent;      \/\/ For Selectable() and other widgets drawing across columns after the freezing line. Index within DrawSplitter.Channels[]$/;"	m	struct:ImGuiTable
Bg2DrawChannelUnfrozen	imgui_internal.h	/^    ImGuiTableDrawChannelIdx    Bg2DrawChannelUnfrozen;$/;"	m	struct:ImGuiTable
BgAlphaVal	imgui_internal.h	/^    float                       BgAlphaVal;             \/\/ Override background alpha$/;"	m	struct:ImGuiNextWindowData
BgClipRect	imgui_internal.h	/^    ImRect                      BgClipRect;                 \/\/ We use this to cpu-clip cell background color fill$/;"	m	struct:ImGuiTable
BgColor	imgui_internal.h	/^    ImU32                       BgColor;    \/\/ Actual color$/;"	m	struct:ImGuiTableCellData
BorderColorLight	imgui_internal.h	/^    ImU32                       BorderColorLight;$/;"	m	struct:ImGuiTable
BorderColorStrong	imgui_internal.h	/^    ImU32                       BorderColorStrong;$/;"	m	struct:ImGuiTable
BorderX1	imgui_internal.h	/^    float                       BorderX1;$/;"	m	struct:ImGuiTable
BorderX2	imgui_internal.h	/^    float                       BorderX2;$/;"	m	struct:ImGuiTable
BringWindowToDisplayBack	imgui.cpp	/^void ImGui::BringWindowToDisplayBack(ImGuiWindow* window)$/;"	f	class:ImGui
BringWindowToDisplayFront	imgui.cpp	/^void ImGui::BringWindowToDisplayFront(ImGuiWindow* window)$/;"	f	class:ImGui
BringWindowToFocusFront	imgui.cpp	/^void ImGui::BringWindowToFocusFront(ImGuiWindow* window)$/;"	f	class:ImGui
Buf	imgui.h	/^    ImVector<char>      Buf;$/;"	m	struct:ImGuiTextBuffer
Buf	imgui.h	/^    char*               Buf;            \/\/ Text buffer                          \/\/ Read-write   \/\/ [Resize] Can replace pointer \/ [Completion,History,Always] Only write to pointed data, don't replace the actual pointer!$/;"	m	struct:ImGuiInputTextCallbackData
Buf	imgui_demo.cpp	/^    ImGuiTextBuffer     Buf;$/;"	m	struct:ExampleAppLog	file:
Buf	imgui_internal.h	/^    ImVector<T>     Buf;        \/\/ Contiguous data$/;"	m	struct:ImPool
Buf	imgui_internal.h	/^    ImVector<char>  Buf;$/;"	m	struct:ImChunkStream
BufCapacityA	imgui_internal.h	/^    int                     BufCapacityA;           \/\/ end-user buffer capacity$/;"	m	struct:ImGuiInputTextState
BufDirty	imgui.h	/^    bool                BufDirty;       \/\/ Set if you modify Buf\/BufTextLen!    \/\/ Write        \/\/ [Completion,History,Always]$/;"	m	struct:ImGuiInputTextCallbackData
BufSize	imgui.h	/^    int                 BufSize;        \/\/ Buffer size (in bytes) = capacity+1  \/\/ Read-only    \/\/ [Resize,Completion,History,Always] Include zero-terminator storage. In C land == ARRAYSIZE(my_char_array), in C++ land: string.capacity()+1$/;"	m	struct:ImGuiInputTextCallbackData
BufTextLen	imgui.h	/^    int                 BufTextLen;     \/\/ Text length (in bytes)               \/\/ Read-write   \/\/ [Resize,Completion,History,Always] Exclude zero-terminator storage. In C land: == strlen(some_text), in C++ land: string.length()$/;"	m	struct:ImGuiInputTextCallbackData
Build	imgui.cpp	/^void ImGuiTextFilter::Build()$/;"	f	class:ImGuiTextFilter
Build	imgui_draw.cpp	/^bool    ImFontAtlas::Build()$/;"	f	class:ImFontAtlas
BuildLookupTable	imgui_draw.cpp	/^void ImFont::BuildLookupTable()$/;"	f	class:ImFont
BuildRanges	imgui_draw.cpp	/^void ImFontGlyphRangesBuilder::BuildRanges(ImVector<ImWchar>* out_ranges)$/;"	f	class:ImFontGlyphRangesBuilder
BuildSortByKey	imgui.cpp	/^void ImGuiStorage::BuildSortByKey()$/;"	f	class:ImGuiStorage
BuildWorkOffsetMax	imgui_internal.h	/^    ImVec2              BuildWorkOffsetMax;     \/\/ Work Area: Offset being built during current frame. Generally <= 0.0f.$/;"	m	struct:ImGuiViewportP
BuildWorkOffsetMin	imgui_internal.h	/^    ImVec2              BuildWorkOffsetMin;     \/\/ Work Area: Offset being built during current frame. Generally >= 0.0f.$/;"	m	struct:ImGuiViewportP
Bullet	imgui_widgets.cpp	/^void ImGui::Bullet()$/;"	f	class:ImGui
BulletText	imgui_widgets.cpp	/^void ImGui::BulletText(const char* fmt, ...)$/;"	f	class:ImGui
BulletTextV	imgui_widgets.cpp	/^void ImGui::BulletTextV(const char* fmt, va_list args)$/;"	f	class:ImGui
Button	imgui_widgets.cpp	/^bool ImGui::Button(const char* label, const ImVec2& size_arg)$/;"	f	class:ImGui
ButtonBehavior	imgui_widgets.cpp	/^bool ImGui::ButtonBehavior(const ImRect& bb, ImGuiID id, bool* out_hovered, bool* out_held, ImGuiButtonFlags flags)$/;"	f	class:ImGui
ButtonEx	imgui_widgets.cpp	/^bool ImGui::ButtonEx(const char* label, const ImVec2& size_arg, ImGuiButtonFlags flags)$/;"	f	class:ImGui
ButtonTextAlign	imgui.h	/^    ImVec2      ButtonTextAlign;            \/\/ Alignment of button text when button is larger than text. Defaults to (0.5f, 0.5f) (centered).$/;"	m	struct:ImGuiStyle
COLUMNS_HIT_RECT_HALF_WIDTH	imgui_tables.cpp	/^static const float COLUMNS_HIT_RECT_HALF_WIDTH = 4.0f;$/;"	v	file:
CalcCustomRectUV	imgui_draw.cpp	/^void ImFontAtlas::CalcCustomRectUV(const ImFontAtlasCustomRect* rect, ImVec2* out_uv_min, ImVec2* out_uv_max) const$/;"	f	class:ImFontAtlas
CalcExtraSpace	imgui_widgets.cpp	/^float ImGuiMenuColumns::CalcExtraSpace(float avail_w) const$/;"	f	class:ImGuiMenuColumns
CalcFontSize	imgui_internal.h	/^    float       CalcFontSize() const    { ImGuiContext& g = *GImGui; float scale = g.FontBaseSize * FontWindowScale; if (ParentWindow) scale *= ParentWindow->FontWindowScale; return scale; }$/;"	f	struct:ImGuiWindow
CalcItemSize	imgui.cpp	/^ImVec2 ImGui::CalcItemSize(ImVec2 size, float default_w, float default_h)$/;"	f	class:ImGui
CalcItemWidth	imgui.cpp	/^float ImGui::CalcItemWidth()$/;"	f	class:ImGui
CalcListClipping	imgui.cpp	/^void ImGui::CalcListClipping(int items_count, float items_height, int* out_items_display_start, int* out_items_display_end)$/;"	f	class:ImGui
CalcMaxPopupHeightFromItemCount	imgui_widgets.cpp	/^static float CalcMaxPopupHeightFromItemCount(int items_count)$/;"	f	file:
CalcNextScrollFromScrollTargetAndClamp	imgui.cpp	/^static ImVec2 CalcNextScrollFromScrollTargetAndClamp(ImGuiWindow* window)$/;"	f	file:
CalcResizePosSizeFromAnyCorner	imgui.cpp	/^static void CalcResizePosSizeFromAnyCorner(ImGuiWindow* window, const ImVec2& corner_target, const ImVec2& corner_norm, ImVec2* out_pos, ImVec2* out_size)$/;"	f	file:
CalcScrollEdgeSnap	imgui.cpp	/^static float CalcScrollEdgeSnap(float target, float snap_min, float snap_max, float snap_threshold, float center_ratio)$/;"	f	file:
CalcTextSize	imgui.cpp	/^ImVec2 ImGui::CalcTextSize(const char* text, const char* text_end, bool hide_text_after_double_hash, float wrap_width)$/;"	f	class:ImGui
CalcTextSizeA	imgui_draw.cpp	/^ImVec2 ImFont::CalcTextSizeA(float size, float max_width, float wrap_width, const char* text_begin, const char* text_end, const char** remaining) const$/;"	f	class:ImFont
CalcTypematicRepeatAmount	imgui.cpp	/^int ImGui::CalcTypematicRepeatAmount(float t0, float t1, float repeat_delay, float repeat_rate)$/;"	f	class:ImGui
CalcWindowAutoFitSize	imgui.cpp	/^static ImVec2 CalcWindowAutoFitSize(ImGuiWindow* window, const ImVec2& size_contents)$/;"	f	file:
CalcWindowContentSizes	imgui.cpp	/^static void CalcWindowContentSizes(ImGuiWindow* window, ImVec2* content_size_current, ImVec2* content_size_ideal)$/;"	f	file:
CalcWindowNextAutoFitSize	imgui.cpp	/^ImVec2 ImGui::CalcWindowNextAutoFitSize(ImGuiWindow* window)$/;"	f	class:ImGui
CalcWindowSizeAfterConstraint	imgui.cpp	/^static ImVec2 CalcWindowSizeAfterConstraint(ImGuiWindow* window, const ImVec2& size_desired)$/;"	f	file:
CalcWordWrapPositionA	imgui_draw.cpp	/^const char* ImFont::CalcWordWrapPositionA(float scale, const char* text, const char* text_end, float wrap_width) const$/;"	f	class:ImFont
CalcWorkRectPos	imgui_internal.h	/^    ImVec2  CalcWorkRectPos(const ImVec2& off_min) const                            { return ImVec2(Pos.x + off_min.x, Pos.y + off_min.y); }$/;"	f	struct:ImGuiViewportP
CalcWorkRectSize	imgui_internal.h	/^    ImVec2  CalcWorkRectSize(const ImVec2& off_min, const ImVec2& off_max) const    { return ImVec2(ImMax(0.0f, Size.x - off_min.x + off_max.x), ImMax(0.0f, Size.y - off_min.y + off_max.y)); }$/;"	f	struct:ImGuiViewportP
CalcWrapWidthForPos	imgui.cpp	/^float ImGui::CalcWrapWidthForPos(const ImVec2& pos, float wrap_pos_x)$/;"	f	class:ImGui
CallContextHooks	imgui.cpp	/^void ImGui::CallContextHooks(ImGuiContext* ctx, ImGuiContextHookType hook_type)$/;"	f	class:ImGui
Callback	imgui_internal.h	/^    ImGuiContextHookCallback    Callback;$/;"	m	struct:ImGuiContextHook
CannotSkipItemsQueue	imgui_internal.h	/^    ImU8                    CannotSkipItemsQueue;           \/\/ Queue of 8 values for the next 8 frames to disable Clipped\/SkipItem$/;"	m	struct:ImGuiTableColumn
Capacity	imgui.h	/^    int                 Capacity;$/;"	m	struct:ImVector
CaptureKeyboardFromApp	imgui.cpp	/^void ImGui::CaptureKeyboardFromApp(bool capture)$/;"	f	class:ImGui
CaptureMouseFromApp	imgui.cpp	/^void ImGui::CaptureMouseFromApp(bool capture)$/;"	f	class:ImGui
CellPadding	imgui.h	/^    ImVec2      CellPadding;                \/\/ Padding within a table cell$/;"	m	struct:ImGuiStyle
CellPaddingX	imgui_internal.h	/^    float                       CellPaddingX;               \/\/ Padding from each borders$/;"	m	struct:ImGuiTable
CellPaddingY	imgui_internal.h	/^    float                       CellPaddingY;$/;"	m	struct:ImGuiTable
CellSpacingX1	imgui_internal.h	/^    float                       CellSpacingX1;              \/\/ Spacing between non-bordered cells$/;"	m	struct:ImGuiTable
CellSpacingX2	imgui_internal.h	/^    float                       CellSpacingX2;$/;"	m	struct:ImGuiTable
ChannelsMerge	imgui.h	/^    inline void     ChannelsMerge()             { _Splitter.Merge(this); }$/;"	f	struct:ImDrawList
ChannelsSetCurrent	imgui.h	/^    inline void     ChannelsSetCurrent(int n)   { _Splitter.SetCurrentChannel(this, n); }$/;"	f	struct:ImDrawList
ChannelsSplit	imgui.h	/^    inline void     ChannelsSplit(int count)    { _Splitter.Split(this, count); }$/;"	f	struct:ImDrawList
Checkbox	imgui_widgets.cpp	/^bool ImGui::Checkbox(const char* label, bool* v)$/;"	f	class:ImGui
CheckboxFlags	imgui_widgets.cpp	/^bool ImGui::CheckboxFlags(const char* label, ImS64* flags, ImS64 flags_value)$/;"	f	class:ImGui
CheckboxFlags	imgui_widgets.cpp	/^bool ImGui::CheckboxFlags(const char* label, ImU64* flags, ImU64 flags_value)$/;"	f	class:ImGui
CheckboxFlags	imgui_widgets.cpp	/^bool ImGui::CheckboxFlags(const char* label, int* flags, int flags_value)$/;"	f	class:ImGui
CheckboxFlags	imgui_widgets.cpp	/^bool ImGui::CheckboxFlags(const char* label, unsigned int* flags, unsigned int flags_value)$/;"	f	class:ImGui
CheckboxFlagsT	imgui_widgets.cpp	/^bool ImGui::CheckboxFlagsT(const char* label, T* flags, T flags_value)$/;"	f	class:ImGui
ChildBorderSize	imgui.h	/^    float       ChildBorderSize;            \/\/ Thickness of border around child windows. Generally set to 0.0f or 1.0f. (Other values are not well tested and more CPU\/GPU costly).$/;"	m	struct:ImGuiStyle
ChildId	imgui_internal.h	/^    ImGuiID                 ChildId;                            \/\/ ID of corresponding item in parent window (for navigation to return from child window to parent window)$/;"	m	struct:ImGuiWindow
ChildRounding	imgui.h	/^    float       ChildRounding;              \/\/ Radius of child window corners rounding. Set to 0.0f to have rectangular windows.$/;"	m	struct:ImGuiStyle
ChildWindowComparer	imgui.cpp	/^static int IMGUI_CDECL ChildWindowComparer(const void* lhs, const void* rhs)$/;"	f	file:
ChildWindows	imgui_internal.h	/^    ImVector<ImGuiWindow*>  ChildWindows;$/;"	m	struct:ImGuiWindowTempData
CircleSegmentCounts	imgui_internal.h	/^    ImU8            CircleSegmentCounts[64];    \/\/ Precomputed segment count for given radius before we calculate it dynamically (to avoid calculation overhead)$/;"	m	struct:ImDrawListSharedData
CircleSegmentMaxError	imgui_internal.h	/^    float           CircleSegmentMaxError;      \/\/ Number of circle segments to use per pixel of radius for AddCircle() etc$/;"	m	struct:ImDrawListSharedData
CircleTessellationMaxError	imgui.h	/^    float       CircleTessellationMaxError; \/\/ Maximum error (in pixels) allowed when using AddCircle()\/AddCircleFilled() or drawing rounded corner rectangles with no explicit segment count specified. Decrease for higher quality but more geometry.$/;"	m	struct:ImGuiStyle
ClampWindowRect	imgui.cpp	/^static inline void ClampWindowRect(ImGuiWindow* window, const ImRect& visibility_rect)$/;"	f	file:
Clear	imgui.h	/^    inline void                 Clear() { _Current = 0; _Count = 1; } \/\/ Do not clear Channels[] so our allocations are reused next frame$/;"	f	struct:ImDrawListSplitter
Clear	imgui.h	/^    inline void     Clear()                 { int size_in_bytes = (IM_UNICODE_CODEPOINT_MAX + 1) \/ 8; UsedChars.resize(size_in_bytes \/ (int)sizeof(ImU32)); memset(UsedChars.Data, 0, (size_t)size_in_bytes); }$/;"	f	struct:ImFontGlyphRangesBuilder
Clear	imgui.h	/^    void                Clear()          { InputBuf[0] = 0; Build(); }$/;"	f	struct:ImGuiTextFilter
Clear	imgui.h	/^    void                Clear() { Data.clear(); }$/;"	f	struct:ImGuiStorage
Clear	imgui.h	/^    void Clear()    { SourceId = SourceParentId = 0; Data = NULL; DataSize = 0; memset(DataType, 0, sizeof(DataType)); DataFrameCount = -1; Preview = Delivery = false; }$/;"	f	struct:ImGuiPayload
Clear	imgui.h	/^    void Clear()    { memset(this, 0, sizeof(*this)); }     \/\/ The ImDrawList are owned by ImGuiContext!$/;"	f	struct:ImDrawData
Clear	imgui_demo.cpp	/^    void    Clear()$/;"	f	struct:ExampleAppLog
Clear	imgui_draw.cpp	/^void    ImFontAtlas::Clear()$/;"	f	class:ImFontAtlas
Clear	imgui_internal.h	/^    void            Clear()                     { Storage.clear(); }$/;"	f	struct:ImBitVector
Clear	imgui_internal.h	/^    void        Clear()                             { for (int n = 0; n < Map.Data.Size; n++) { int idx = Map.Data[n].val_i; if (idx != -1) Buf[idx].~T(); } Map.Clear(); Buf.clear(); FreeIdx = 0; }$/;"	f	struct:ImPool
Clear	imgui_internal.h	/^    void Clear()                    { for (int n = 0; n < IM_ARRAYSIZE(Layers); n++) Layers[n].resize(0); }$/;"	f	struct:ImDrawDataBuilder
Clear	imgui_internal.h	/^    void Clear()        { Window = NULL; ID = FocusScopeId = 0; RectRel = ImRect(); DistBox = DistCenter = DistAxial = FLT_MAX; }$/;"	f	struct:ImGuiNavItemData
ClearActiveID	imgui.cpp	/^void ImGui::ClearActiveID()$/;"	f	class:ImGui
ClearAllBits	imgui_internal.h	/^    void            ClearAllBits()              { memset(Storage, 0, sizeof(Storage)); }$/;"	f	struct:ImBitArray
ClearAllFn	imgui_internal.h	/^    void        (*ClearAllFn)(ImGuiContext* ctx, ImGuiSettingsHandler* handler);                                \/\/ Clear all settings data$/;"	m	struct:ImGuiSettingsHandler
ClearBit	imgui_internal.h	/^    void            ClearBit(int n)             { IM_ASSERT(n < (Storage.Size << 5)); ImBitArrayClearBit(Storage.Data, n); }$/;"	f	struct:ImBitVector
ClearBit	imgui_internal.h	/^    void            ClearBit(int n)             { IM_ASSERT(n < BITCOUNT); ImBitArrayClearBit(Storage, n); }$/;"	f	struct:ImBitArray
ClearDragDrop	imgui.cpp	/^void ImGui::ClearDragDrop()$/;"	f	class:ImGui
ClearFlags	imgui_internal.h	/^    inline void ClearFlags()    { Flags = ImGuiNextItemDataFlags_None; } \/\/ Also cleared manually by ItemAdd()!$/;"	f	struct:ImGuiNextItemData
ClearFlags	imgui_internal.h	/^    inline void ClearFlags()    { Flags = ImGuiNextWindowDataFlags_None; }$/;"	f	struct:ImGuiNextWindowData
ClearFonts	imgui_draw.cpp	/^void    ImFontAtlas::ClearFonts()$/;"	f	class:ImFontAtlas
ClearFreeMemory	imgui_draw.cpp	/^void ImDrawListSplitter::ClearFreeMemory()$/;"	f	class:ImDrawListSplitter
ClearFreeMemory	imgui_internal.h	/^    void        ClearFreeMemory()           { TextW.clear(); TextA.clear(); InitialTextA.clear(); }$/;"	f	struct:ImGuiInputTextState
ClearFreeMemory	imgui_internal.h	/^    void ClearFreeMemory()          { for (int n = 0; n < IM_ARRAYSIZE(Layers); n++) Layers[n].clear(); }$/;"	f	struct:ImDrawDataBuilder
ClearIniSettings	imgui.cpp	/^void ImGui::ClearIniSettings()$/;"	f	class:ImGui
ClearInputCharacters	imgui.cpp	/^void ImGuiIO::ClearInputCharacters()$/;"	f	class:ImGuiIO
ClearInputData	imgui_draw.cpp	/^void    ImFontAtlas::ClearInputData()$/;"	f	class:ImFontAtlas
ClearLog	imgui_demo.cpp	/^    void    ClearLog()$/;"	f	struct:ExampleAppConsole
ClearOutputData	imgui_draw.cpp	/^void    ImFont::ClearOutputData()$/;"	f	class:ImFont
ClearSelection	imgui.h	/^    void                ClearSelection()        { SelectionStart = SelectionEnd = BufTextLen; }$/;"	f	struct:ImGuiInputTextCallbackData
ClearSelection	imgui_internal.h	/^    void        ClearSelection()            { Stb.select_start = Stb.select_end = Stb.cursor; }$/;"	f	struct:ImGuiInputTextState
ClearTexData	imgui_draw.cpp	/^void    ImFontAtlas::ClearTexData()$/;"	f	class:ImFontAtlas
ClearText	imgui_internal.h	/^    void        ClearText()                 { CurLenW = CurLenA = 0; TextW[0] = 0; TextA[0] = 0; CursorClamp(); }$/;"	f	struct:ImGuiInputTextState
ClipRect	imgui.h	/^    ImVec4          ClipRect;           \/\/ 4*4  \/\/ Clipping rectangle (x1, y1, x2, y2). Subtract ImDrawData->DisplayPos to get clipping rectangle in "viewport" coordinates$/;"	m	struct:ImDrawCmd
ClipRect	imgui.h	/^    ImVec4          ClipRect;$/;"	m	struct:ImDrawCmdHeader
ClipRect	imgui_internal.h	/^    ImRect                  ClipRect;                           \/\/ Current clipping\/scissoring rectangle, evolve as we are using PushClipRect(), etc. == DrawList->clip_rect_stack.back().$/;"	m	struct:ImGuiWindow
ClipRect	imgui_internal.h	/^    ImRect                  ClipRect;                       \/\/ Clipping rectangle for the column$/;"	m	struct:ImGuiTableColumn
ClipRect	imgui_internal.h	/^    ImRect              ClipRect;$/;"	m	struct:ImGuiOldColumnData
ClipRectFullscreen	imgui_internal.h	/^    ImVec4          ClipRectFullscreen;         \/\/ Value for PushClipRectFullscreen()$/;"	m	struct:ImDrawListSharedData
ClipWith	imgui_internal.h	/^    void        ClipWith(const ImRect& r)           { Min = ImMax(Min, r.Min); Max = ImMin(Max, r.Max); }                   \/\/ Simple version, may lead to an inverted rectangle, which is fine for Contains\/Overlaps test but not for display.$/;"	f	struct:ImRect
ClipWithFull	imgui_internal.h	/^    void        ClipWithFull(const ImRect& r)       { Min = ImClamp(Min, r.Min, r.Max); Max = ImClamp(Max, r.Min, r.Max); } \/\/ Full version, ensure both points are fully clipped.$/;"	f	struct:ImRect
ClipboardHandlerData	imgui_internal.h	/^    ImVector<char>          ClipboardHandlerData;               \/\/ If no custom clipboard handler is defined$/;"	m	struct:ImGuiContext
ClipboardUserData	imgui.h	/^    void*       ClipboardUserData;$/;"	m	struct:ImGuiIO
CloneOutput	imgui_draw.cpp	/^ImDrawList* ImDrawList::CloneOutput() const$/;"	f	class:ImDrawList
CloseButton	imgui_widgets.cpp	/^bool ImGui::CloseButton(ImGuiID id, const ImVec2& pos)$/;"	f	class:ImGui
CloseCurrentPopup	imgui.cpp	/^void ImGui::CloseCurrentPopup()$/;"	f	class:ImGui
ClosePopupToLevel	imgui.cpp	/^void ImGui::ClosePopupToLevel(int remaining, bool restore_focus_to_window_under_popup)$/;"	f	class:ImGui
ClosePopupsOverWindow	imgui.cpp	/^void ImGui::ClosePopupsOverWindow(ImGuiWindow* ref_window, bool restore_focus_to_window_under_popup)$/;"	f	class:ImGui
CmdBuffer	imgui.h	/^    ImVector<ImDrawCmd>     CmdBuffer;          \/\/ Draw commands. Typically 1 command = 1 GPU draw call, unless the command is a callback.$/;"	m	struct:ImDrawList
CmdLists	imgui.h	/^    ImDrawList**    CmdLists;               \/\/ Array of ImDrawList* to render. The ImDrawList are owned by ImGuiContext and only pointed to from here.$/;"	m	struct:ImDrawData
CmdListsCount	imgui.h	/^    int             CmdListsCount;          \/\/ Number of ImDrawList* to render$/;"	m	struct:ImDrawData
Codepoint	imgui.h	/^    unsigned int    Codepoint : 30;     \/\/ 0x0000..0x10FFFF$/;"	m	struct:ImFontGlyph
Col	imgui_internal.h	/^    ImGuiCol    Col;$/;"	m	struct:ImGuiColorMod
CollapseButton	imgui_widgets.cpp	/^bool ImGui::CollapseButton(ImGuiID id, const ImVec2& pos)$/;"	f	class:ImGui
Collapsed	imgui_internal.h	/^    bool                    Collapsed;                          \/\/ Set when collapsing window to become only title-bar$/;"	m	struct:ImGuiWindow
Collapsed	imgui_internal.h	/^    bool        Collapsed;$/;"	m	struct:ImGuiWindowSettings
CollapsedCond	imgui_internal.h	/^    ImGuiCond                   CollapsedCond;$/;"	m	struct:ImGuiNextWindowData
CollapsedVal	imgui_internal.h	/^    bool                        CollapsedVal;$/;"	m	struct:ImGuiNextWindowData
CollapsingHeader	imgui_widgets.cpp	/^bool ImGui::CollapsingHeader(const char* label, ImGuiTreeNodeFlags flags)$/;"	f	class:ImGui
CollapsingHeader	imgui_widgets.cpp	/^bool ImGui::CollapsingHeader(const char* label, bool* p_visible, ImGuiTreeNodeFlags flags)$/;"	f	class:ImGui
Color	imgui_demo.cpp	/^    ImVec4      Color;      \/\/ An arbitrary variable associated to the document$/;"	m	struct:MyDocument	file:
ColorButton	imgui_widgets.cpp	/^bool ImGui::ColorButton(const char* desc_id, const ImVec4& col, ImGuiColorEditFlags flags, ImVec2 size)$/;"	f	class:ImGui
ColorButtonPosition	imgui.h	/^    ImGuiDir    ColorButtonPosition;        \/\/ Side of the color button in the ColorEdit4 widget (left\/right). Defaults to ImGuiDir_Right.$/;"	m	struct:ImGuiStyle
ColorConvertFloat4ToU32	imgui.cpp	/^ImU32 ImGui::ColorConvertFloat4ToU32(const ImVec4& in)$/;"	f	class:ImGui
ColorConvertHSVtoRGB	imgui.cpp	/^void ImGui::ColorConvertHSVtoRGB(float h, float s, float v, float& out_r, float& out_g, float& out_b)$/;"	f	class:ImGui
ColorConvertRGBtoHSV	imgui.cpp	/^void ImGui::ColorConvertRGBtoHSV(float r, float g, float b, float& out_h, float& out_s, float& out_v)$/;"	f	class:ImGui
ColorConvertU32ToFloat4	imgui.cpp	/^ImVec4 ImGui::ColorConvertU32ToFloat4(ImU32 in)$/;"	f	class:ImGui
ColorEdit3	imgui_widgets.cpp	/^bool ImGui::ColorEdit3(const char* label, float col[3], ImGuiColorEditFlags flags)$/;"	f	class:ImGui
ColorEdit4	imgui_widgets.cpp	/^bool ImGui::ColorEdit4(const char* label, float col[4], ImGuiColorEditFlags flags)$/;"	f	class:ImGui
ColorEditLastColor	imgui_internal.h	/^    float                   ColorEditLastColor[3];$/;"	m	struct:ImGuiContext
ColorEditLastHue	imgui_internal.h	/^    float                   ColorEditLastHue;                   \/\/ Backup of last Hue associated to LastColor[3], so we can restore Hue in lossy RGB<>HSV round trips$/;"	m	struct:ImGuiContext
ColorEditLastSat	imgui_internal.h	/^    float                   ColorEditLastSat;                   \/\/ Backup of last Saturation associated to LastColor[3], so we can restore Saturation in lossy RGB<>HSV round trips$/;"	m	struct:ImGuiContext
ColorEditOptions	imgui_internal.h	/^    ImGuiColorEditFlags     ColorEditOptions;                   \/\/ Store user options for color edit widgets$/;"	m	struct:ImGuiContext
ColorEditOptionsPopup	imgui_widgets.cpp	/^void ImGui::ColorEditOptionsPopup(const float* col, ImGuiColorEditFlags flags)$/;"	f	class:ImGui
ColorPicker3	imgui_widgets.cpp	/^bool ImGui::ColorPicker3(const char* label, float col[3], ImGuiColorEditFlags flags)$/;"	f	class:ImGui
ColorPicker4	imgui_widgets.cpp	/^bool ImGui::ColorPicker4(const char* label, float col[4], ImGuiColorEditFlags flags, const float* ref_col)$/;"	f	class:ImGui
ColorPickerOptionsPopup	imgui_widgets.cpp	/^void ImGui::ColorPickerOptionsPopup(const float* ref_col, ImGuiColorEditFlags flags)$/;"	f	class:ImGui
ColorPickerRef	imgui_internal.h	/^    ImVec4                  ColorPickerRef;                     \/\/ Initial\/reference color at the time of opening the color picker.$/;"	m	struct:ImGuiContext
ColorStack	imgui_internal.h	/^    ImVector<ImGuiColorMod> ColorStack;                         \/\/ Stack for PushStyleColor()\/PopStyleColor() - inherited by Begin()$/;"	m	struct:ImGuiContext
ColorTooltip	imgui_widgets.cpp	/^void ImGui::ColorTooltip(const char* text, const float* col, ImGuiColorEditFlags flags)$/;"	f	class:ImGui
Colored	imgui.h	/^    unsigned int    Colored : 1;        \/\/ Flag to indicate glyph is colored and should generally ignore tinting (make it usable with no shift on little-endian as this is used in loops)$/;"	m	struct:ImFontGlyph
Colors	imgui.h	/^    ImVec4      Colors[ImGuiCol_COUNT];$/;"	m	struct:ImGuiStyle
Column	imgui_internal.h	/^    ImGuiTableColumnIdx         Column;     \/\/ Column number$/;"	m	struct:ImGuiTableCellData
ColumnIndex	imgui.h	/^    ImS16                       ColumnIndex;        \/\/ Index of the column$/;"	m	struct:ImGuiTableColumnSortSpecs
ColumnUserID	imgui.h	/^    ImGuiID                     ColumnUserID;       \/\/ User id of the column (if specified by a TableSetupColumn() call)$/;"	m	struct:ImGuiTableColumnSortSpecs
Columns	imgui_internal.h	/^    ImSpan<ImGuiTableColumn>    Columns;                    \/\/ Point within RawData[]$/;"	m	struct:ImGuiTable
Columns	imgui_internal.h	/^    ImVector<ImGuiOldColumnData> Columns;$/;"	m	struct:ImGuiOldColumns
Columns	imgui_tables.cpp	/^void ImGui::Columns(int columns_count, const char* id, bool border)$/;"	f	class:ImGui
ColumnsAutoFitWidth	imgui_internal.h	/^    float                       ColumnsAutoFitWidth;        \/\/ Sum of ideal column width in order nothing to be clipped, used for auto-fitting and content width submission in outer window$/;"	m	struct:ImGuiTable
ColumnsCount	imgui_internal.h	/^    ImGuiTableColumnIdx         ColumnsCount;$/;"	m	struct:ImGuiTableSettings
ColumnsCount	imgui_internal.h	/^    int                         ColumnsCount;               \/\/ Number of columns declared in BeginTable()$/;"	m	struct:ImGuiTable
ColumnsCountMax	imgui_internal.h	/^    ImGuiTableColumnIdx         ColumnsCountMax;        \/\/ Maximum number of columns this settings instance can store, we can recycle a settings instance with lower number of columns but not higher$/;"	m	struct:ImGuiTableSettings
ColumnsEnabledCount	imgui_internal.h	/^    ImGuiTableColumnIdx         ColumnsEnabledCount;        \/\/ Number of enabled columns (<= ColumnsCount)$/;"	m	struct:ImGuiTable
ColumnsEnabledFixedCount	imgui_internal.h	/^    ImGuiTableColumnIdx         ColumnsEnabledFixedCount;   \/\/ Number of enabled columns (<= ColumnsCount)$/;"	m	struct:ImGuiTable
ColumnsGivenWidth	imgui_internal.h	/^    float                       ColumnsGivenWidth;          \/\/ Sum of current column width$/;"	m	struct:ImGuiTable
ColumnsMinSpacing	imgui.h	/^    float       ColumnsMinSpacing;          \/\/ Minimum horizontal spacing between two columns. Preferably > (FramePadding.x + 1).$/;"	m	struct:ImGuiStyle
ColumnsNames	imgui_internal.h	/^    ImGuiTextBuffer             ColumnsNames;               \/\/ Contiguous buffer holding columns names$/;"	m	struct:ImGuiTable
ColumnsOffset	imgui_internal.h	/^    ImVec1                  ColumnsOffset;          \/\/ Offset to the current column (if ColumnsCurrent > 0). FIXME: This and the above should be a stack to allow use cases like Tree->Column->Tree. Need revamp columns API.$/;"	m	struct:ImGuiWindowTempData
ColumnsStorage	imgui_internal.h	/^    ImVector<ImGuiOldColumns> ColumnsStorage;$/;"	m	struct:ImGuiWindow
Combo	imgui_widgets.cpp	/^bool ImGui::Combo(const char* label, int* current_item, bool (*items_getter)(void*, int, const char**), void* data, int items_count, int popup_max_height_in_items)$/;"	f	class:ImGui
Combo	imgui_widgets.cpp	/^bool ImGui::Combo(const char* label, int* current_item, const char* const items[], int items_count, int height_in_items)$/;"	f	class:ImGui
Combo	imgui_widgets.cpp	/^bool ImGui::Combo(const char* label, int* current_item, const char* items_separated_by_zeros, int height_in_items)$/;"	f	class:ImGui
Commands	imgui_demo.cpp	/^    ImVector<const char*> Commands;$/;"	m	struct:ExampleAppConsole	file:
CompareWithCurrentState	imgui.cpp	/^void ImGuiStackSizes::CompareWithCurrentState()$/;"	f	class:ImGuiStackSizes
CompareWithSortSpecs	imgui_demo.cpp	/^    static int IMGUI_CDECL CompareWithSortSpecs(const void* lhs, const void* rhs)$/;"	f	struct:__anon29::MyItem
ConfigData	imgui.h	/^    ImVector<ImFontConfig>      ConfigData;         \/\/ Configuration data$/;"	m	struct:ImFontAtlas
ConfigData	imgui.h	/^    const ImFontConfig*         ConfigData;         \/\/ 4-8   \/\/ in  \/\/            \/\/ Pointer within ContainerAtlas->ConfigData$/;"	m	struct:ImFont
ConfigDataCount	imgui.h	/^    short                       ConfigDataCount;    \/\/ 2     \/\/ in  \/\/ ~ 1        \/\/ Number of ImFontConfig involved in creating this font. Bigger than 1 when merging multiple font sources into one ImFont.$/;"	m	struct:ImFont
ConfigDragClickToInputText	imgui.h	/^    bool        ConfigDragClickToInputText;     \/\/ = false          \/\/ [BETA] Enable turning DragXXX widgets into text input with a simple mouse click-release (without moving). Not desirable on devices without a keyboard.$/;"	m	struct:ImGuiIO
ConfigFlags	imgui.h	/^    ImGuiConfigFlags   ConfigFlags;             \/\/ = 0              \/\/ See ImGuiConfigFlags_ enum. Set by user\/application. Gamepad\/keyboard navigation options, etc.$/;"	m	struct:ImGuiIO
ConfigInputTextCursorBlink	imgui.h	/^    bool        ConfigInputTextCursorBlink;     \/\/ = true           \/\/ Enable blinking cursor (optional as some users consider it to be distracting).$/;"	m	struct:ImGuiIO
ConfigMacOSXBehaviors	imgui.h	/^    bool        ConfigMacOSXBehaviors;          \/\/ = defined(__APPLE__) \/\/ OS X style: Text editing cursor movement using Alt instead of Ctrl, Shortcuts using Cmd\/Super instead of Ctrl, Line\/Text Start and End using Cmd+Arrows instead of Home\/End, Double click selects by word instead of selecting whole text, Multi-selection in lists uses Cmd\/Super instead of Ctrl.$/;"	m	struct:ImGuiIO
ConfigMemoryCompactTimer	imgui.h	/^    float       ConfigMemoryCompactTimer;       \/\/ = 60.0f          \/\/ Timer (in seconds) to free transient windows\/tables memory buffers when unused. Set to -1.0f to disable.$/;"	m	struct:ImGuiIO
ConfigWindowsMoveFromTitleBarOnly	imgui.h	/^    bool        ConfigWindowsMoveFromTitleBarOnly; \/\/ = false       \/\/ Enable allowing to move windows only when clicking on their title bar. Does not apply to windows without a title bar.$/;"	m	struct:ImGuiIO
ConfigWindowsResizeFromEdges	imgui.h	/^    bool        ConfigWindowsResizeFromEdges;   \/\/ = true           \/\/ Enable resizing of windows from their edges and from the lower-left corner. This requires (io.BackendFlags & ImGuiBackendFlags_HasMouseCursors) because it needs mouse cursor feedback. (This used to be a per-window ImGuiWindowFlags_ResizeFromAnySide flag)$/;"	m	struct:ImGuiIO
ContainerAtlas	imgui.h	/^    ImFontAtlas*                ContainerAtlas;     \/\/ 4-8   \/\/ out \/\/            \/\/ What we has been loaded into$/;"	m	struct:ImFont
Contains	imgui_internal.h	/^    bool        Contains(const ImRect& r) const     { return r.Min.x >= Min.x && r.Min.y >= Min.y && r.Max.x <= Max.x && r.Max.y <= Max.y; }$/;"	f	struct:ImRect
Contains	imgui_internal.h	/^    bool        Contains(const ImVec2& p) const     { return p.x     >= Min.x && p.y     >= Min.y && p.x     <  Max.x && p.y     <  Max.y; }$/;"	f	struct:ImRect
Contains	imgui_internal.h	/^    bool        Contains(const T* p) const          { return (p >= Buf.Data && p < Buf.Data + Buf.Size); }$/;"	f	struct:ImPool
ContentMaxXFrozen	imgui_internal.h	/^    float                   ContentMaxXFrozen;              \/\/ Contents maximum position for frozen rows (apart from headers), from which we can infer content width.$/;"	m	struct:ImGuiTableColumn
ContentMaxXHeadersIdeal	imgui_internal.h	/^    float                   ContentMaxXHeadersIdeal;$/;"	m	struct:ImGuiTableColumn
ContentMaxXHeadersUsed	imgui_internal.h	/^    float                   ContentMaxXHeadersUsed;         \/\/ Contents maximum position for headers rows (regardless of freezing). TableHeader() automatically softclip itself + report ideal desired size, to avoid creating extraneous draw calls$/;"	m	struct:ImGuiTableColumn
ContentMaxXUnfrozen	imgui_internal.h	/^    float                   ContentMaxXUnfrozen;$/;"	m	struct:ImGuiTableColumn
ContentRegionRect	imgui_internal.h	/^    ImRect                  ContentRegionRect;                  \/\/ FIXME: This is currently confusing\/misleading. It is essentially WorkRect but not handling of scrolling. We currently rely on it as right\/bottom aligned sizing operation need some size to rely on.$/;"	m	struct:ImGuiWindow
ContentSize	imgui_internal.h	/^    ImVec2                  ContentSize;                        \/\/ Size of contents\/scrollable client area (calculated from the extents reach of the cursor) from previous frame. Does not include window decoration or window padding.$/;"	m	struct:ImGuiWindow
ContentSizeExplicit	imgui_internal.h	/^    ImVec2                  ContentSizeExplicit;                \/\/ Size of contents\/scrollable client area explicitly request by the user via SetNextWindowContentSize().$/;"	m	struct:ImGuiWindow
ContentSizeIdeal	imgui_internal.h	/^    ImVec2                  ContentSizeIdeal;$/;"	m	struct:ImGuiWindow
ContentSizeVal	imgui_internal.h	/^    ImVec2                      ContentSizeVal;$/;"	m	struct:ImGuiNextWindowData
ContentWidth	imgui_internal.h	/^    float               ContentWidth;           \/\/ Width of label, stored during BeginTabItem() call$/;"	m	struct:ImGuiTabItem
ContextPopupColumn	imgui_internal.h	/^    ImGuiTableColumnIdx         ContextPopupColumn;         \/\/ Column right-clicked on, of -1 if opening context menu from a neutral\/empty spot$/;"	m	struct:ImGuiTable
CornerPosN	imgui.cpp	/^    ImVec2  CornerPosN;$/;"	m	struct:ImGuiResizeGripDef	file:
Count	imgui.cpp	/^    ImU32           Count;$/;"	m	struct:ImGuiStyleVarInfo	file:
Count	imgui_internal.h	/^    int                 Count;$/;"	m	struct:ImGuiOldColumns
CountGrep	imgui.h	/^    int                     CountGrep;$/;"	m	struct:ImGuiTextFilter
Create	imgui_internal.h	/^    void            Create(int sz)              { Storage.resize((sz + 31) >> 5); memset(Storage.Data, 0, (size_t)Storage.Size * sizeof(Storage.Data[0])); }$/;"	f	struct:ImBitVector
CreateContext	imgui.cpp	/^ImGuiContext* ImGui::CreateContext(ImFontAtlas* shared_font_atlas)$/;"	f	class:ImGui
CreateNewWindow	imgui.cpp	/^static ImGuiWindow* CreateNewWindow(const char* name, ImGuiWindowFlags flags)$/;"	f	file:
CreateNewWindowSettings	imgui.cpp	/^ImGuiWindowSettings* ImGui::CreateNewWindowSettings(const char* name)$/;"	f	class:ImGui
CurLenA	imgui_internal.h	/^    int                     CurLenW, CurLenA;       \/\/ we need to maintain our buffer length in both UTF-8 and wchar format. UTF-8 length is valid even if TextA is not.$/;"	m	struct:ImGuiInputTextState
CurLenW	imgui_internal.h	/^    int                     CurLenW, CurLenA;       \/\/ we need to maintain our buffer length in both UTF-8 and wchar format. UTF-8 length is valid even if TextA is not.$/;"	m	struct:ImGuiInputTextState
CurrFrameVisible	imgui_internal.h	/^    int                 CurrFrameVisible;$/;"	m	struct:ImGuiTabBar
CurrIdx	imgui_internal.h	/^    int     CurrIdx;$/;"	m	struct:ImSpanAllocator
CurrLineSize	imgui_internal.h	/^    ImVec2                  CurrLineSize;$/;"	m	struct:ImGuiWindowTempData
CurrLineTextBaseOffset	imgui_internal.h	/^    float                   CurrLineTextBaseOffset; \/\/ Baseline offset (0.0f by default on a new line, generally == style.FramePadding.y when a framed item has been added).$/;"	m	struct:ImGuiWindowTempData
CurrOff	imgui_internal.h	/^    int     CurrOff;$/;"	m	struct:ImSpanAllocator
CurrTabsContentsHeight	imgui_internal.h	/^    float               CurrTabsContentsHeight;$/;"	m	struct:ImGuiTabBar
Current	imgui_internal.h	/^    int                 Current;$/;"	m	struct:ImGuiOldColumns
CurrentColumn	imgui_internal.h	/^    int                         CurrentColumn;$/;"	m	struct:ImGuiTable
CurrentColumns	imgui_internal.h	/^    ImGuiOldColumns*        CurrentColumns;         \/\/ Current columns set$/;"	m	struct:ImGuiWindowTempData
CurrentRow	imgui_internal.h	/^    int                         CurrentRow;$/;"	m	struct:ImGuiTable
CurrentSize	imgui.h	/^    ImVec2  CurrentSize;    \/\/ Read-only.   Current window size.$/;"	m	struct:ImGuiSizeCallbackData
CurrentTabBar	imgui_internal.h	/^    ImGuiTabBar*                    CurrentTabBar;$/;"	m	struct:ImGuiContext
CurrentTabBarStack	imgui_internal.h	/^    ImVector<ImGuiPtrOrIndex>       CurrentTabBarStack;$/;"	m	struct:ImGuiContext
CurrentTable	imgui_internal.h	/^    ImGuiTable*                     CurrentTable;$/;"	m	struct:ImGuiContext
CurrentTableIdx	imgui_internal.h	/^    int                     CurrentTableIdx;        \/\/ Current table index (into g.Tables)$/;"	m	struct:ImGuiWindowTempData
CurrentTableStack	imgui_internal.h	/^    ImVector<ImGuiPtrOrIndex>       CurrentTableStack;$/;"	m	struct:ImGuiContext
CurrentWindow	imgui_internal.h	/^    ImGuiWindow*            CurrentWindow;                      \/\/ Window being drawn into$/;"	m	struct:ImGuiContext
CurrentWindowStack	imgui_internal.h	/^    ImVector<ImGuiWindow*>  CurrentWindowStack;$/;"	m	struct:ImGuiContext
CursorAnim	imgui_internal.h	/^    float                   CursorAnim;             \/\/ timer for cursor blink, reset on every user action so the cursor reappears immediately$/;"	m	struct:ImGuiInputTextState
CursorAnimReset	imgui_internal.h	/^    void        CursorAnimReset()           { CursorAnim = -0.30f; }                                   \/\/ After a user-input the cursor stays on for a while without blinking$/;"	f	struct:ImGuiInputTextState
CursorClamp	imgui_internal.h	/^    void        CursorClamp()               { Stb.cursor = ImMin(Stb.cursor, CurLenW); Stb.select_start = ImMin(Stb.select_start, CurLenW); Stb.select_end = ImMin(Stb.select_end, CurLenW); }$/;"	f	struct:ImGuiInputTextState
CursorFollow	imgui_internal.h	/^    bool                    CursorFollow;           \/\/ set when we want scrolling to follow the current cursor position (not always!)$/;"	m	struct:ImGuiInputTextState
CursorMaxPos	imgui_internal.h	/^    ImVec2                  CursorMaxPos;           \/\/ Used to implicitly calculate ContentSize at the beginning of next frame, for scrolling range and auto-resize. Always growing during the frame.$/;"	m	struct:ImGuiWindowTempData
CursorPos	imgui.h	/^    int                 CursorPos;      \/\/                                      \/\/ Read-write   \/\/ [Completion,History,Always]$/;"	m	struct:ImGuiInputTextCallbackData
CursorPos	imgui_internal.h	/^    ImVec2                  CursorPos;              \/\/ Current emitting position, in absolute coordinates.$/;"	m	struct:ImGuiWindowTempData
CursorPosPrevLine	imgui_internal.h	/^    ImVec2                  CursorPosPrevLine;$/;"	m	struct:ImGuiWindowTempData
CursorStartPos	imgui_internal.h	/^    ImVec2                  CursorStartPos;         \/\/ Initial position after Begin(), generally ~ window position + WindowPadding.$/;"	m	struct:ImGuiWindowTempData
CurveTessellationTol	imgui.h	/^    float       CurveTessellationTol;       \/\/ Tessellation tolerance when using PathBezierCurveTo() without a specific number of segments. Decrease for highly tessellated curves (higher quality, more polygons), increase to reduce quality.$/;"	m	struct:ImGuiStyle
CurveTessellationTol	imgui_internal.h	/^    float           CurveTessellationTol;       \/\/ Tessellation tolerance when using PathBezierCurveTo()$/;"	m	struct:ImDrawListSharedData
CustomRect	imgui.h	/^    typedef ImFontAtlasCustomRect    CustomRect;         \/\/ OBSOLETED in 1.72+$/;"	t	struct:ImFontAtlas
CustomRects	imgui.h	/^    ImVector<ImFontAtlasCustomRect> CustomRects;    \/\/ Rectangles for packing custom texture data into the atlas.$/;"	m	struct:ImFontAtlas
DC	imgui_internal.h	/^    ImGuiWindowTempData     DC;                                 \/\/ Temporary per-window data, reset at the beginning of the frame. This used to be called ImGuiDrawContext, hence the "DC" variable name.$/;"	m	struct:ImGuiWindow
DRAGDROP_HOLD_TO_OPEN_TIMER	imgui_widgets.cpp	/^static const float          DRAGDROP_HOLD_TO_OPEN_TIMER = 0.70f;    \/\/ Time for drag-hold to activate items accepting the ImGuiButtonFlags_PressedOnDragDropHold button behavior.$/;"	v	file:
DRAG_MOUSE_THRESHOLD_FACTOR	imgui_widgets.cpp	/^static const float          DRAG_MOUSE_THRESHOLD_FACTOR = 0.50f;    \/\/ Multiplier for the default value of io.MouseDragThreshold to make DragFloat\/DragInt react faster to mouse drags.$/;"	v	file:
Data	imgui.h	/^    ImVector<ImGuiStoragePair>      Data;$/;"	m	struct:ImGuiStorage
Data	imgui.h	/^    T*                  Data;$/;"	m	struct:ImVector
Data	imgui.h	/^    void*           Data;               \/\/ Data (copied and owned by dear imgui)$/;"	m	struct:ImGuiPayload
Data	imgui_internal.h	/^    ImU8        Data[8];        \/\/ Can fit any data up to ImGuiDataType_COUNT$/;"	m	struct:ImGuiDataTypeTempStorage
Data	imgui_internal.h	/^    T*                  Data;$/;"	m	struct:ImSpan
DataEnd	imgui_internal.h	/^    T*                  DataEnd;$/;"	m	struct:ImSpan
DataFrameCount	imgui.h	/^    int             DataFrameCount;     \/\/ Data timestamp$/;"	m	struct:ImGuiPayload
DataSize	imgui.h	/^    int             DataSize;           \/\/ Data size$/;"	m	struct:ImGuiPayload
DataType	imgui.h	/^    char            DataType[32 + 1];   \/\/ Data type tag (short user-supplied string, 32 characters max)$/;"	m	struct:ImGuiPayload
DataTypeApplyOp	imgui_widgets.cpp	/^void ImGui::DataTypeApplyOp(ImGuiDataType data_type, int op, void* output, const void* arg1, const void* arg2)$/;"	f	class:ImGui
DataTypeApplyOpFromText	imgui_widgets.cpp	/^bool ImGui::DataTypeApplyOpFromText(const char* buf, const char* initial_value_buf, ImGuiDataType data_type, void* p_data, const char* format)$/;"	f	class:ImGui
DataTypeClamp	imgui_widgets.cpp	/^bool ImGui::DataTypeClamp(ImGuiDataType data_type, void* p_data, const void* p_min, const void* p_max)$/;"	f	class:ImGui
DataTypeClampT	imgui_widgets.cpp	/^static bool DataTypeClampT(T* v, const T* v_min, const T* v_max)$/;"	f	file:
DataTypeCompare	imgui_widgets.cpp	/^int ImGui::DataTypeCompare(ImGuiDataType data_type, const void* arg_1, const void* arg_2)$/;"	f	class:ImGui
DataTypeCompareT	imgui_widgets.cpp	/^static int DataTypeCompareT(const T* lhs, const T* rhs)$/;"	f	file:
DataTypeFormatString	imgui_widgets.cpp	/^int ImGui::DataTypeFormatString(char* buf, int buf_size, ImGuiDataType data_type, const void* p_data, const char* format)$/;"	f	class:ImGui
DataTypeGetInfo	imgui_widgets.cpp	/^const ImGuiDataTypeInfo* ImGui::DataTypeGetInfo(ImGuiDataType data_type)$/;"	f	class:ImGui
DeIndexAllBuffers	imgui_draw.cpp	/^void ImDrawData::DeIndexAllBuffers()$/;"	f	class:ImDrawData
DebugCheckVersionAndDataLayout	imgui.cpp	/^bool ImGui::DebugCheckVersionAndDataLayout(const char* version, size_t sz_io, size_t sz_style, size_t sz_vec2, size_t sz_vec4, size_t sz_vert, size_t sz_idx)$/;"	f	class:ImGui
DebugDrawItemRect	imgui_internal.h	/^    inline void             DebugDrawItemRect(ImU32 col = IM_COL32(255,0,0,255))    { ImGuiContext& g = *GImGui; ImGuiWindow* window = g.CurrentWindow; GetForegroundDrawList(window)->AddRect(window->DC.LastItemRect.Min, window->DC.LastItemRect.Max, col); }$/;"	f	namespace:ImGui
DebugItemPickerActive	imgui_internal.h	/^    bool                    DebugItemPickerActive;              \/\/ Item picker is active (started with DebugStartItemPicker())$/;"	m	struct:ImGuiContext
DebugItemPickerBreakId	imgui_internal.h	/^    ImGuiID                 DebugItemPickerBreakId;             \/\/ Will call IM_DEBUG_BREAK() when encountering this id$/;"	m	struct:ImGuiContext
DebugMetricsConfig	imgui_internal.h	/^    ImGuiMetricsConfig      DebugMetricsConfig;$/;"	m	struct:ImGuiContext
DebugNodeColumns	imgui.cpp	/^void ImGui::DebugNodeColumns(ImGuiOldColumns* columns)$/;"	f	class:ImGui
DebugNodeColumns	imgui.cpp	/^void ImGui::DebugNodeColumns(ImGuiOldColumns*) {}$/;"	f	class:ImGui
DebugNodeDrawCmdShowMeshAndBoundingBox	imgui.cpp	/^void ImGui::DebugNodeDrawCmdShowMeshAndBoundingBox(ImDrawList* out_draw_list, const ImDrawList* draw_list, const ImDrawCmd* draw_cmd, bool show_mesh, bool show_aabb)$/;"	f	class:ImGui
DebugNodeDrawCmdShowMeshAndBoundingBox	imgui.cpp	/^void ImGui::DebugNodeDrawCmdShowMeshAndBoundingBox(ImDrawList*, const ImDrawList*, const ImDrawCmd*, bool, bool) {}$/;"	f	class:ImGui
DebugNodeDrawList	imgui.cpp	/^void ImGui::DebugNodeDrawList(ImGuiWindow* window, const ImDrawList* draw_list, const char* label)$/;"	f	class:ImGui
DebugNodeDrawList	imgui.cpp	/^void ImGui::DebugNodeDrawList(ImGuiWindow*, const ImDrawList*, const char*) {}$/;"	f	class:ImGui
DebugNodeStorage	imgui.cpp	/^void ImGui::DebugNodeStorage(ImGuiStorage* storage, const char* label)$/;"	f	class:ImGui
DebugNodeStorage	imgui.cpp	/^void ImGui::DebugNodeStorage(ImGuiStorage*, const char*) {}$/;"	f	class:ImGui
DebugNodeTabBar	imgui.cpp	/^void ImGui::DebugNodeTabBar(ImGuiTabBar* tab_bar, const char* label)$/;"	f	class:ImGui
DebugNodeTabBar	imgui.cpp	/^void ImGui::DebugNodeTabBar(ImGuiTabBar*, const char*) {}$/;"	f	class:ImGui
DebugNodeTable	imgui_tables.cpp	/^void ImGui::DebugNodeTable(ImGuiTable* table)$/;"	f	class:ImGui
DebugNodeTable	imgui_tables.cpp	/^void ImGui::DebugNodeTable(ImGuiTable*) {}$/;"	f	class:ImGui
DebugNodeTableGetSizingPolicyDesc	imgui_tables.cpp	/^static const char* DebugNodeTableGetSizingPolicyDesc(ImGuiTableFlags sizing_policy)$/;"	f	file:
DebugNodeTableSettings	imgui_tables.cpp	/^void ImGui::DebugNodeTableSettings(ImGuiTableSettings* settings)$/;"	f	class:ImGui
DebugNodeTableSettings	imgui_tables.cpp	/^void ImGui::DebugNodeTableSettings(ImGuiTableSettings*) {}$/;"	f	class:ImGui
DebugNodeViewport	imgui.cpp	/^void ImGui::DebugNodeViewport(ImGuiViewportP* viewport)$/;"	f	class:ImGui
DebugNodeViewport	imgui.cpp	/^void ImGui::DebugNodeViewport(ImGuiViewportP*) {}$/;"	f	class:ImGui
DebugNodeWindow	imgui.cpp	/^void ImGui::DebugNodeWindow(ImGuiWindow* window, const char* label)$/;"	f	class:ImGui
DebugNodeWindow	imgui.cpp	/^void ImGui::DebugNodeWindow(ImGuiWindow*, const char*) {}$/;"	f	class:ImGui
DebugNodeWindowSettings	imgui.cpp	/^void ImGui::DebugNodeWindowSettings(ImGuiWindowSettings* settings)$/;"	f	class:ImGui
DebugNodeWindowSettings	imgui.cpp	/^void ImGui::DebugNodeWindowSettings(ImGuiWindowSettings*) {}$/;"	f	class:ImGui
DebugNodeWindowsList	imgui.cpp	/^void ImGui::DebugNodeWindowsList(ImVector<ImGuiWindow*>* windows, const char* label)$/;"	f	class:ImGui
DebugNodeWindowsList	imgui.cpp	/^void ImGui::DebugNodeWindowsList(ImVector<ImGuiWindow*>*, const char*) {}$/;"	f	class:ImGui
DebugRenderViewportThumbnail	imgui.cpp	/^void ImGui::DebugRenderViewportThumbnail(ImDrawList* draw_list, ImGuiViewportP* viewport, const ImRect& bb)$/;"	f	class:ImGui
DebugStartItemPicker	imgui_internal.h	/^    inline void             DebugStartItemPicker()                                  { ImGuiContext& g = *GImGui; g.DebugItemPickerActive = true; }$/;"	f	namespace:ImGui
DeclColumns	imgui_widgets.cpp	/^float ImGuiMenuColumns::DeclColumns(float w0, float w1, float w2) \/\/ not using va_arg because they promote float to double$/;"	f	class:ImGuiMenuColumns
DeclColumnsCount	imgui_internal.h	/^    ImGuiTableColumnIdx         DeclColumnsCount;           \/\/ Count calls to TableSetupColumn()$/;"	m	struct:ImGuiTable
Decode85	imgui_draw.cpp	/^static void         Decode85(const unsigned char* src, unsigned char* dst)$/;"	f	file:
Decode85Byte	imgui_draw.cpp	/^static unsigned int Decode85Byte(char c)                                    { return c >= '\\\\' ? c-36 : c-35; }$/;"	f	file:
DeleteChars	imgui_widgets.cpp	/^void ImGuiInputTextCallbackData::DeleteChars(int pos, int bytes_count)$/;"	f	class:ImGuiInputTextCallbackData
Delivery	imgui.h	/^    bool            Delivery;           \/\/ Set when AcceptDragDropPayload() was called and mouse button is released over the target item.$/;"	m	struct:ImGuiPayload
DeltaTime	imgui.h	/^    float       DeltaTime;                      \/\/ = 1.0f\/60.0f     \/\/ Time elapsed since last frame, in seconds.$/;"	m	struct:ImGuiIO
Descent	imgui.h	/^    float                       Ascent, Descent;    \/\/ 4+4   \/\/ out \/\/            \/\/ Ascent: distance from top to bottom of e.g. 'A' [0..FontSize]$/;"	m	struct:ImFont
DesiredSize	imgui.h	/^    ImVec2  DesiredSize;    \/\/ Read-write.  Desired size, based on user's mouse position. Write to this field to restrain resizing.$/;"	m	struct:ImGuiSizeCallbackData
DestroyContext	imgui.cpp	/^void ImGui::DestroyContext(ImGuiContext* ctx)$/;"	f	class:ImGui
DimBgRatio	imgui_internal.h	/^    float                   DimBgRatio;                         \/\/ 0.0..1.0 animation when fading in a dimming background (for modal window and CTRL+TAB list)$/;"	m	struct:ImGuiContext
Dirty	imgui_demo.cpp	/^    bool        Dirty;      \/\/ Set when the document has been modified$/;"	m	struct:MyDocument	file:
DirtyLookupTables	imgui.h	/^    bool                        DirtyLookupTables;  \/\/ 1     \/\/ out \/\/$/;"	m	struct:ImFont
DisableInputsFrames	imgui_internal.h	/^    ImS8                    DisableInputsFrames;                \/\/ Disable window interactions for N frames$/;"	m	struct:ImGuiWindow
DisplayContents	imgui_demo.cpp	/^    static void DisplayContents(MyDocument* doc)$/;"	f	struct:MyDocument
DisplayContextMenu	imgui_demo.cpp	/^    static void DisplayContextMenu(MyDocument* doc)$/;"	f	struct:MyDocument
DisplayEnd	imgui.h	/^    int     DisplayEnd;$/;"	m	struct:ImGuiListClipper
DisplayFramebufferScale	imgui.h	/^    ImVec2      DisplayFramebufferScale;        \/\/ = (1, 1)         \/\/ For retina display or other situations where window coordinates are different from framebuffer coordinates. This generally ends up in ImDrawData::FramebufferScale.$/;"	m	struct:ImGuiIO
DisplayOrder	imgui_internal.h	/^    ImGuiTableColumnIdx     DisplayOrder;                   \/\/ Index within Table's IndexToDisplayOrder[] (column may be reordered by users)$/;"	m	struct:ImGuiTableColumn
DisplayOrder	imgui_internal.h	/^    ImGuiTableColumnIdx     DisplayOrder;$/;"	m	struct:ImGuiTableColumnSettings
DisplayOrderToIndex	imgui_internal.h	/^    ImSpan<ImGuiTableColumnIdx> DisplayOrderToIndex;        \/\/ Point within RawData[]. Store display order of columns (when not reordered, the values are 0...Count-1)$/;"	m	struct:ImGuiTable
DisplayPos	imgui.h	/^    ImVec2          DisplayPos;             \/\/ Top-left position of the viewport to render (== top-left of the orthogonal projection matrix to use) (== GetMainViewport()->Pos for the main viewport, == (0.0) in most single-viewport applications)$/;"	m	struct:ImDrawData
DisplaySafeAreaPadding	imgui.h	/^    ImVec2      DisplaySafeAreaPadding;     \/\/ If you cannot see the edges of your screen (e.g. on a TV) increase the safe area padding. Apply to popups\/tooltips as well regular windows. NB: Prefer configuring your TV sets correctly!$/;"	m	struct:ImGuiStyle
DisplaySize	imgui.h	/^    ImVec2          DisplaySize;            \/\/ Size of the viewport to render (== GetMainViewport()->Size for the main viewport, == io.DisplaySize in most single-viewport applications)$/;"	m	struct:ImDrawData
DisplaySize	imgui.h	/^    ImVec2      DisplaySize;                    \/\/ <unset>          \/\/ Main display size, in pixels (generally == GetMainViewport()->Size)$/;"	m	struct:ImGuiIO
DisplayStart	imgui.h	/^    int     DisplayStart;$/;"	m	struct:ImGuiListClipper
DisplayWindowPadding	imgui.h	/^    ImVec2      DisplayWindowPadding;       \/\/ Window position are clamped to be visible within the display area or monitors by at least this amount. Only applies to regular windows.$/;"	m	struct:ImGuiStyle
DistAxial	imgui_internal.h	/^    float               DistAxial;      \/\/      Move    \/\/ Best candidate axial distance to current NavId$/;"	m	struct:ImGuiNavItemData
DistBox	imgui_internal.h	/^    float               DistBox;        \/\/      Move    \/\/ Best candidate box distance to current NavId$/;"	m	struct:ImGuiNavItemData
DistCenter	imgui_internal.h	/^    float               DistCenter;     \/\/      Move    \/\/ Best candidate center distance to current NavId$/;"	m	struct:ImGuiNavItemData
DoForceClose	imgui_demo.cpp	/^    void DoForceClose() { Open = false; Dirty = false; }$/;"	f	struct:MyDocument
DoOpen	imgui_demo.cpp	/^    void DoOpen()       { Open = true; }$/;"	f	struct:MyDocument
DoQueueClose	imgui_demo.cpp	/^    void DoQueueClose() { WantClose = true; }$/;"	f	struct:MyDocument
DoSave	imgui_demo.cpp	/^    void DoSave()       { Dirty = false; }$/;"	f	struct:MyDocument
Documents	imgui_demo.cpp	/^    ImVector<MyDocument> Documents;$/;"	m	struct:ExampleAppDocuments	file:
DragBehavior	imgui_widgets.cpp	/^bool ImGui::DragBehavior(ImGuiID id, ImGuiDataType data_type, void* p_v, float v_speed, const void* p_min, const void* p_max, const char* format, ImGuiSliderFlags flags)$/;"	f	class:ImGui
DragBehaviorT	imgui_widgets.cpp	/^bool ImGui::DragBehaviorT(ImGuiDataType data_type, TYPE* v, float v_speed, const TYPE v_min, const TYPE v_max, const char* format, ImGuiSliderFlags flags)$/;"	f	class:ImGui
DragCurrentAccum	imgui_internal.h	/^    float                   DragCurrentAccum;                   \/\/ Accumulator for dragging modification. Always high-precision, not rounded by end-user precision settings$/;"	m	struct:ImGuiContext
DragCurrentAccumDirty	imgui_internal.h	/^    bool                    DragCurrentAccumDirty;$/;"	m	struct:ImGuiContext
DragDropAcceptFlags	imgui_internal.h	/^    ImGuiDragDropFlags      DragDropAcceptFlags;$/;"	m	struct:ImGuiContext
DragDropAcceptFrameCount	imgui_internal.h	/^    int                     DragDropAcceptFrameCount;           \/\/ Last time a target expressed a desire to accept the source$/;"	m	struct:ImGuiContext
DragDropAcceptIdCurr	imgui_internal.h	/^    ImGuiID                 DragDropAcceptIdCurr;               \/\/ Target item id (set at the time of accepting the payload)$/;"	m	struct:ImGuiContext
DragDropAcceptIdCurrRectSurface	imgui_internal.h	/^    float                   DragDropAcceptIdCurrRectSurface;    \/\/ Target item surface (we resolve overlapping targets by prioritizing the smaller surface)$/;"	m	struct:ImGuiContext
DragDropAcceptIdPrev	imgui_internal.h	/^    ImGuiID                 DragDropAcceptIdPrev;               \/\/ Target item id from previous frame (we need to store this to allow for overlapping drag and drop targets)$/;"	m	struct:ImGuiContext
DragDropActive	imgui_internal.h	/^    bool                    DragDropActive;$/;"	m	struct:ImGuiContext
DragDropHoldJustPressedId	imgui_internal.h	/^    ImGuiID                 DragDropHoldJustPressedId;          \/\/ Set when holding a payload just made ButtonBehavior() return a press.$/;"	m	struct:ImGuiContext
DragDropMouseButton	imgui_internal.h	/^    int                     DragDropMouseButton;$/;"	m	struct:ImGuiContext
DragDropPayload	imgui_internal.h	/^    ImGuiPayload            DragDropPayload;$/;"	m	struct:ImGuiContext
DragDropPayloadBufHeap	imgui_internal.h	/^    ImVector<unsigned char> DragDropPayloadBufHeap;             \/\/ We don't expose the ImVector<> directly, ImGuiPayload only holds pointer+size$/;"	m	struct:ImGuiContext
DragDropPayloadBufLocal	imgui_internal.h	/^    unsigned char           DragDropPayloadBufLocal[16];        \/\/ Local buffer for small payloads$/;"	m	struct:ImGuiContext
DragDropSourceFlags	imgui_internal.h	/^    ImGuiDragDropFlags      DragDropSourceFlags;$/;"	m	struct:ImGuiContext
DragDropSourceFrameCount	imgui_internal.h	/^    int                     DragDropSourceFrameCount;$/;"	m	struct:ImGuiContext
DragDropTargetId	imgui_internal.h	/^    ImGuiID                 DragDropTargetId;$/;"	m	struct:ImGuiContext
DragDropTargetRect	imgui_internal.h	/^    ImRect                  DragDropTargetRect;                 \/\/ Store rectangle of current target candidate (we favor small targets when overlapping)$/;"	m	struct:ImGuiContext
DragDropWithinSource	imgui_internal.h	/^    bool                    DragDropWithinSource;               \/\/ Set when within a BeginDragDropXXX\/EndDragDropXXX block for a drag source.$/;"	m	struct:ImGuiContext
DragDropWithinTarget	imgui_internal.h	/^    bool                    DragDropWithinTarget;               \/\/ Set when within a BeginDragDropXXX\/EndDragDropXXX block for a drag target.$/;"	m	struct:ImGuiContext
DragFloat	imgui.h	/^    static inline bool  DragFloat(const char* label, float* v, float v_speed, float v_min, float v_max, const char* format, float power)    { return DragScalar(label, ImGuiDataType_Float, v, v_speed, &v_min, &v_max, format, power); }$/;"	f	namespace:ImGui
DragFloat	imgui_widgets.cpp	/^bool ImGui::DragFloat(const char* label, float* v, float v_speed, float v_min, float v_max, const char* format, ImGuiSliderFlags flags)$/;"	f	class:ImGui
DragFloat2	imgui.h	/^    static inline bool  DragFloat2(const char* label, float v[2], float v_speed, float v_min, float v_max, const char* format, float power) { return DragScalarN(label, ImGuiDataType_Float, v, 2, v_speed, &v_min, &v_max, format, power); }$/;"	f	namespace:ImGui
DragFloat2	imgui_widgets.cpp	/^bool ImGui::DragFloat2(const char* label, float v[2], float v_speed, float v_min, float v_max, const char* format, ImGuiSliderFlags flags)$/;"	f	class:ImGui
DragFloat3	imgui.h	/^    static inline bool  DragFloat3(const char* label, float v[3], float v_speed, float v_min, float v_max, const char* format, float power) { return DragScalarN(label, ImGuiDataType_Float, v, 3, v_speed, &v_min, &v_max, format, power); }$/;"	f	namespace:ImGui
DragFloat3	imgui_widgets.cpp	/^bool ImGui::DragFloat3(const char* label, float v[3], float v_speed, float v_min, float v_max, const char* format, ImGuiSliderFlags flags)$/;"	f	class:ImGui
DragFloat4	imgui.h	/^    static inline bool  DragFloat4(const char* label, float v[4], float v_speed, float v_min, float v_max, const char* format, float power) { return DragScalarN(label, ImGuiDataType_Float, v, 4, v_speed, &v_min, &v_max, format, power); }$/;"	f	namespace:ImGui
DragFloat4	imgui_widgets.cpp	/^bool ImGui::DragFloat4(const char* label, float v[4], float v_speed, float v_min, float v_max, const char* format, ImGuiSliderFlags flags)$/;"	f	class:ImGui
DragFloatRange2	imgui_widgets.cpp	/^bool ImGui::DragFloatRange2(const char* label, float* v_current_min, float* v_current_max, float v_speed, float v_min, float v_max, const char* format, const char* format_max, ImGuiSliderFlags flags)$/;"	f	class:ImGui
DragInt	imgui_widgets.cpp	/^bool ImGui::DragInt(const char* label, int* v, float v_speed, int v_min, int v_max, const char* format, ImGuiSliderFlags flags)$/;"	f	class:ImGui
DragInt2	imgui_widgets.cpp	/^bool ImGui::DragInt2(const char* label, int v[2], float v_speed, int v_min, int v_max, const char* format, ImGuiSliderFlags flags)$/;"	f	class:ImGui
DragInt3	imgui_widgets.cpp	/^bool ImGui::DragInt3(const char* label, int v[3], float v_speed, int v_min, int v_max, const char* format, ImGuiSliderFlags flags)$/;"	f	class:ImGui
DragInt4	imgui_widgets.cpp	/^bool ImGui::DragInt4(const char* label, int v[4], float v_speed, int v_min, int v_max, const char* format, ImGuiSliderFlags flags)$/;"	f	class:ImGui
DragIntRange2	imgui_widgets.cpp	/^bool ImGui::DragIntRange2(const char* label, int* v_current_min, int* v_current_max, float v_speed, int v_min, int v_max, const char* format, const char* format_max, ImGuiSliderFlags flags)$/;"	f	class:ImGui
DragScalar	imgui_widgets.cpp	/^bool ImGui::DragScalar(const char* label, ImGuiDataType data_type, void* p_data, float v_speed, const void* p_min, const void* p_max, const char* format, ImGuiSliderFlags flags)$/;"	f	class:ImGui
DragScalar	imgui_widgets.cpp	/^bool ImGui::DragScalar(const char* label, ImGuiDataType data_type, void* p_data, float v_speed, const void* p_min, const void* p_max, const char* format, float power)$/;"	f	class:ImGui
DragScalarN	imgui_widgets.cpp	/^bool ImGui::DragScalarN(const char* label, ImGuiDataType data_type, void* p_data, int components, float v_speed, const void* p_min, const void* p_max, const char* format, ImGuiSliderFlags flags)$/;"	f	class:ImGui
DragScalarN	imgui_widgets.cpp	/^bool ImGui::DragScalarN(const char* label, ImGuiDataType data_type, void* p_data, int components, float v_speed, const void* p_min, const void* p_max, const char* format, float power)$/;"	f	class:ImGui
DragSpeedDefaultRatio	imgui_internal.h	/^    float                   DragSpeedDefaultRatio;              \/\/ If speed == 0.0f, uses (max-min) * DragSpeedDefaultRatio$/;"	m	struct:ImGuiContext
Draw	imgui.cpp	/^bool ImGuiTextFilter::Draw(const char* label, float width)$/;"	f	class:ImGuiTextFilter
Draw	imgui_demo.cpp	/^    void    Draw(const char* title, bool* p_open = NULL)$/;"	f	struct:ExampleAppLog
Draw	imgui_demo.cpp	/^    void    Draw(const char* title, bool* p_open)$/;"	f	struct:ExampleAppConsole
DrawChannelCurrent	imgui_internal.h	/^    ImGuiTableDrawChannelIdx DrawChannelCurrent;            \/\/ Index within DrawSplitter.Channels[]$/;"	m	struct:ImGuiTableColumn
DrawChannelFrozen	imgui_internal.h	/^    ImGuiTableDrawChannelIdx DrawChannelFrozen;$/;"	m	struct:ImGuiTableColumn
DrawChannelUnfrozen	imgui_internal.h	/^    ImGuiTableDrawChannelIdx DrawChannelUnfrozen;$/;"	m	struct:ImGuiTableColumn
DrawChannelsTempMergeBuffer	imgui_internal.h	/^    ImVector<ImDrawChannel>         DrawChannelsTempMergeBuffer;$/;"	m	struct:ImGuiContext
DrawDataBuilder	imgui_internal.h	/^    ImDrawDataBuilder   DrawDataBuilder;$/;"	m	struct:ImGuiViewportP
DrawDataP	imgui_internal.h	/^    ImDrawData          DrawDataP;$/;"	m	struct:ImGuiViewportP
DrawList	imgui_internal.h	/^    ImDrawList*             DrawList;                           \/\/ == &DrawListInst (for backward compatibility reason with code using imgui_internal.h we keep this a pointer)$/;"	m	struct:ImGuiWindow
DrawListInst	imgui_internal.h	/^    ImDrawList              DrawListInst;$/;"	m	struct:ImGuiWindow
DrawListSharedData	imgui_internal.h	/^    ImDrawListSharedData    DrawListSharedData;$/;"	m	struct:ImGuiContext
DrawLists	imgui_internal.h	/^    ImDrawList*         DrawLists[2];           \/\/ Convenience background (0) and foreground (1) draw lists. We use them to draw software mouser cursor when io.MouseDrawCursor is set and to draw most debug overlays.$/;"	m	struct:ImGuiViewportP
DrawListsLastFrame	imgui_internal.h	/^    int                 DrawListsLastFrame[2];  \/\/ Last frame number the background (0) and foreground (1) draw lists were used$/;"	m	struct:ImGuiViewportP
DrawSplitter	imgui_internal.h	/^    ImDrawListSplitter          DrawSplitter;               \/\/ We carry our own ImDrawList splitter to allow recursion (FIXME: could be stored outside, worst case we need 1 splitter per recursing table)$/;"	m	struct:ImGuiTable
DstFont	imgui.h	/^    ImFont*         DstFont;$/;"	m	struct:ImFontConfig
DstIndex	imgui_draw.cpp	/^    int                 DstIndex;           \/\/ Index into atlas->Fonts[] and dst_tmp_array[]$/;"	m	struct:ImFontBuildSrcData	file:
Dummy	imgui_widgets.cpp	/^void ImGui::Dummy(const ImVec2& size)$/;"	f	class:ImGui
DummyDrawChannel	imgui_internal.h	/^    ImGuiTableDrawChannelIdx    DummyDrawChannel;           \/\/ Redirect non-visible columns here.$/;"	m	struct:ImGuiTable
EditTableColumnsFlags	imgui_demo.cpp	/^static void EditTableColumnsFlags(ImGuiTableColumnFlags* p_flags)$/;"	f	file:
EditTableSizingFlags	imgui_demo.cpp	/^static void EditTableSizingFlags(ImGuiTableFlags* p_flags)$/;"	f	file:
Edited	imgui_internal.h	/^    bool                    Edited;                 \/\/ edited this frame$/;"	m	struct:ImGuiInputTextState
ElemCount	imgui.h	/^    unsigned int    ElemCount;          \/\/ 4    \/\/ Number of indices (multiple of 3) to be rendered as triangles. Vertices are stored in the callee ImDrawList's vtx_buffer[] array, indices in idx_buffer[].$/;"	m	struct:ImDrawCmd
EllipsisChar	imgui.h	/^    ImWchar                     EllipsisChar;       \/\/ 2     \/\/ out \/\/ = -1       \/\/ Character used for ellipsis rendering.$/;"	m	struct:ImFont
EllipsisChar	imgui.h	/^    ImWchar         EllipsisChar;           \/\/ -1       \/\/ Explicitly specify unicode codepoint of ellipsis character. When fonts are being merged first specified ellipsis will be used.$/;"	m	struct:ImFontConfig
EmitItem	imgui_internal.h	/^    bool        EmitItem;$/;"	m	struct:ImGuiGroupData
EmptyString	imgui.cpp	/^char ImGuiTextBuffer::EmptyString[1] = { 0 };$/;"	m	class:ImGuiTextBuffer	file:
EmptyString	imgui.h	/^    IMGUI_API static char EmptyString[1];$/;"	m	struct:ImGuiTextBuffer
EnabledMaskByDisplayOrder	imgui_internal.h	/^    ImU64                       EnabledMaskByDisplayOrder;  \/\/ Column DisplayOrder -> IsEnabled map$/;"	m	struct:ImGuiTable
EnabledMaskByIndex	imgui_internal.h	/^    ImU64                       EnabledMaskByIndex;         \/\/ Column Index -> IsEnabled map (== not hidden by user\/api) in a format adequate for iterating column without touching cold data$/;"	m	struct:ImGuiTable
End	imgui.cpp	/^void ImGui::End()$/;"	f	class:ImGui
End	imgui.cpp	/^void ImGuiListClipper::End()$/;"	f	class:ImGuiListClipper
EndChild	imgui.cpp	/^void ImGui::EndChild()$/;"	f	class:ImGui
EndChildFrame	imgui.cpp	/^void ImGui::EndChildFrame()$/;"	f	class:ImGui
EndColumns	imgui_tables.cpp	/^void ImGui::EndColumns()$/;"	f	class:ImGui
EndCombo	imgui_widgets.cpp	/^void ImGui::EndCombo()$/;"	f	class:ImGui
EndDragDropSource	imgui.cpp	/^void ImGui::EndDragDropSource()$/;"	f	class:ImGui
EndDragDropTarget	imgui.cpp	/^void ImGui::EndDragDropTarget()$/;"	f	class:ImGui
EndFrame	imgui.cpp	/^void ImGui::EndFrame()$/;"	f	class:ImGui
EndGroup	imgui.cpp	/^void ImGui::EndGroup()$/;"	f	class:ImGui
EndListBox	imgui_widgets.cpp	/^void ImGui::EndListBox()$/;"	f	class:ImGui
EndMainMenuBar	imgui_widgets.cpp	/^void ImGui::EndMainMenuBar()$/;"	f	class:ImGui
EndMenu	imgui_widgets.cpp	/^void ImGui::EndMenu()$/;"	f	class:ImGui
EndMenuBar	imgui_widgets.cpp	/^void ImGui::EndMenuBar()$/;"	f	class:ImGui
EndPopup	imgui.cpp	/^void ImGui::EndPopup()$/;"	f	class:ImGui
EndTabBar	imgui_widgets.cpp	/^void    ImGui::EndTabBar()$/;"	f	class:ImGui
EndTabItem	imgui_widgets.cpp	/^void    ImGui::EndTabItem()$/;"	f	class:ImGui
EndTable	imgui_tables.cpp	/^void    ImGui::EndTable()$/;"	f	class:ImGui
EndTooltip	imgui.cpp	/^void ImGui::EndTooltip()$/;"	f	class:ImGui
ErrorCheckEndFrameRecover	imgui.cpp	/^void    ImGui::ErrorCheckEndFrameRecover(ImGuiErrorLogCallback log_callback, void* user_data)$/;"	f	class:ImGui
ErrorCheckEndFrameSanityChecks	imgui.cpp	/^static void ImGui::ErrorCheckEndFrameSanityChecks()$/;"	f	class:ImGui
ErrorCheckNewFrameSanityChecks	imgui.cpp	/^static void ImGui::ErrorCheckNewFrameSanityChecks()$/;"	f	class:ImGui
EventChar	imgui.h	/^    ImWchar             EventChar;      \/\/ Character input                      \/\/ Read-write   \/\/ [CharFilter] Replace character with another one, or set to zero to drop. return 1 is equivalent to setting EventChar=0;$/;"	m	struct:ImGuiInputTextCallbackData
EventFlag	imgui.h	/^    ImGuiInputTextFlags EventFlag;      \/\/ One ImGuiInputTextFlags_Callback*    \/\/ Read-only$/;"	m	struct:ImGuiInputTextCallbackData
EventKey	imgui.h	/^    ImGuiKey            EventKey;       \/\/ Key pressed (Up\/Down\/TAB)            \/\/ Read-only    \/\/ [Completion,History]$/;"	m	struct:ImGuiInputTextCallbackData
ExampleAppConsole	imgui_demo.cpp	/^    ExampleAppConsole()$/;"	f	struct:ExampleAppConsole
ExampleAppConsole	imgui_demo.cpp	/^struct ExampleAppConsole$/;"	s	file:
ExampleAppDocuments	imgui_demo.cpp	/^    ExampleAppDocuments()$/;"	f	struct:ExampleAppDocuments
ExampleAppDocuments	imgui_demo.cpp	/^struct ExampleAppDocuments$/;"	s	file:
ExampleAppLog	imgui_demo.cpp	/^    ExampleAppLog()$/;"	f	struct:ExampleAppLog
ExampleAppLog	imgui_demo.cpp	/^struct ExampleAppLog$/;"	s	file:
ExecCommand	imgui_demo.cpp	/^    void    ExecCommand(const char* command_line)$/;"	f	struct:ExampleAppConsole
Expand	imgui_internal.h	/^    void        Expand(const ImVec2& amount)        { Min.x -= amount.x; Min.y -= amount.y; Max.x += amount.x; Max.y += amount.y; }$/;"	f	struct:ImRect
Expand	imgui_internal.h	/^    void        Expand(const float amount)          { Min.x -= amount;   Min.y -= amount;   Max.x += amount;   Max.y += amount; }$/;"	f	struct:ImRect
FONT_ATLAS_DEFAULT_TEX_CURSOR_DATA	imgui_draw.cpp	/^static const ImVec2 FONT_ATLAS_DEFAULT_TEX_CURSOR_DATA[ImGuiMouseCursor_COUNT][3] =$/;"	v	file:
FONT_ATLAS_DEFAULT_TEX_DATA_H	imgui_draw.cpp	/^const int FONT_ATLAS_DEFAULT_TEX_DATA_H = 27;$/;"	v
FONT_ATLAS_DEFAULT_TEX_DATA_PIXELS	imgui_draw.cpp	/^static const char FONT_ATLAS_DEFAULT_TEX_DATA_PIXELS[FONT_ATLAS_DEFAULT_TEX_DATA_W * FONT_ATLAS_DEFAULT_TEX_DATA_H + 1] =$/;"	v	file:
FONT_ATLAS_DEFAULT_TEX_DATA_W	imgui_draw.cpp	/^const int FONT_ATLAS_DEFAULT_TEX_DATA_W = 108; \/\/ Actual texture will be 2 times that + 1 spacing.$/;"	v
FallbackAdvanceX	imgui.h	/^    float                       FallbackAdvanceX;   \/\/ 4     \/\/ out \/\/ = FallbackGlyph->AdvanceX$/;"	m	struct:ImFont
FallbackChar	imgui.h	/^    ImWchar                     FallbackChar;       \/\/ 2     \/\/ in  \/\/ = '?'      \/\/ Replacement character if a glyph isn't found. Only set via SetFallbackChar()$/;"	m	struct:ImFont
FallbackGlyph	imgui.h	/^    const ImFontGlyph*          FallbackGlyph;      \/\/ 4-8   \/\/ out \/\/ = FindGlyph(FontFallbackChar)$/;"	m	struct:ImFont
Filter	imgui_demo.cpp	/^    ImGuiTextFilter       Filter;$/;"	m	struct:ExampleAppConsole	file:
Filter	imgui_demo.cpp	/^    ImGuiTextFilter     Filter;$/;"	m	struct:ExampleAppLog	file:
Filters	imgui.h	/^    ImVector<ImGuiTextRange>Filters;$/;"	m	struct:ImGuiTextFilter
FindBestWindowPosForPopup	imgui.cpp	/^ImVec2 ImGui::FindBestWindowPosForPopup(ImGuiWindow* window)$/;"	f	class:ImGui
FindBestWindowPosForPopupEx	imgui.cpp	/^ImVec2 ImGui::FindBestWindowPosForPopupEx(const ImVec2& ref_pos, const ImVec2& size, ImGuiDir* last_dir, const ImRect& r_outer, const ImRect& r_avoid, ImGuiPopupPositionPolicy policy)$/;"	f	class:ImGui
FindGlyph	imgui_draw.cpp	/^const ImFontGlyph* ImFont::FindGlyph(ImWchar c) const$/;"	f	class:ImFont
FindGlyphNoFallback	imgui_draw.cpp	/^const ImFontGlyph* ImFont::FindGlyphNoFallback(ImWchar c) const$/;"	f	class:ImFont
FindHoveredWindow	imgui.cpp	/^static void FindHoveredWindow()$/;"	f	file:
FindOrCreateColumns	imgui_tables.cpp	/^ImGuiOldColumns* ImGui::FindOrCreateColumns(ImGuiWindow* window, ImGuiID id)$/;"	f	class:ImGui
FindOrCreateWindowSettings	imgui.cpp	/^ImGuiWindowSettings* ImGui::FindOrCreateWindowSettings(const char* name)$/;"	f	class:ImGui
FindRenderedTextEnd	imgui.cpp	/^const char* ImGui::FindRenderedTextEnd(const char* text, const char* text_end)$/;"	f	class:ImGui
FindSettingsHandler	imgui.cpp	/^ImGuiSettingsHandler* ImGui::FindSettingsHandler(const char* type_name)$/;"	f	class:ImGui
FindWindowByID	imgui.cpp	/^ImGuiWindow* ImGui::FindWindowByID(ImGuiID id)$/;"	f	class:ImGui
FindWindowByName	imgui.cpp	/^ImGuiWindow* ImGui::FindWindowByName(const char* name)$/;"	f	class:ImGui
FindWindowFocusIndex	imgui.cpp	/^static int ImGui::FindWindowFocusIndex(ImGuiWindow* window)$/;"	f	class:ImGui
FindWindowNavFocusable	imgui.cpp	/^static ImGuiWindow* FindWindowNavFocusable(int i_start, int i_stop, int dir) \/\/ FIXME-OPT O(N)$/;"	f	file:
FindWindowSettings	imgui.cpp	/^ImGuiWindowSettings* ImGui::FindWindowSettings(ImGuiID id)$/;"	f	class:ImGui
FixRectCornerFlags	imgui_draw.cpp	/^static inline ImDrawFlags FixRectCornerFlags(ImDrawFlags flags)$/;"	f	file:
Flags	imgui.h	/^    ImDrawListFlags         Flags;              \/\/ Flags, you may poke into these to adjust anti-aliasing settings per-primitive.$/;"	m	struct:ImDrawList
Flags	imgui.h	/^    ImFontAtlasFlags            Flags;              \/\/ Build flags (see ImFontAtlasFlags_)$/;"	m	struct:ImFontAtlas
Flags	imgui.h	/^    ImGuiInputTextFlags Flags;          \/\/ What user passed to InputText()      \/\/ Read-only$/;"	m	struct:ImGuiInputTextCallbackData
Flags	imgui.h	/^    ImGuiViewportFlags  Flags;                  \/\/ See ImGuiViewportFlags_$/;"	m	struct:ImGuiViewport
Flags	imgui_internal.h	/^    ImGuiNextItemDataFlags      Flags;$/;"	m	struct:ImGuiNextItemData
Flags	imgui_internal.h	/^    ImGuiNextWindowDataFlags    Flags;$/;"	m	struct:ImGuiNextWindowData
Flags	imgui_internal.h	/^    ImGuiOldColumnFlags Flags;              \/\/ Not exposed$/;"	m	struct:ImGuiOldColumnData
Flags	imgui_internal.h	/^    ImGuiOldColumnFlags Flags;$/;"	m	struct:ImGuiOldColumns
Flags	imgui_internal.h	/^    ImGuiTabBarFlags    Flags;$/;"	m	struct:ImGuiTabBar
Flags	imgui_internal.h	/^    ImGuiTabItemFlags   Flags;$/;"	m	struct:ImGuiTabItem
Flags	imgui_internal.h	/^    ImGuiTableColumnFlags   Flags;                          \/\/ Flags after some patching (not directly same as provided by user). See ImGuiTableColumnFlags_$/;"	m	struct:ImGuiTableColumn
Flags	imgui_internal.h	/^    ImGuiTableFlags             Flags;$/;"	m	struct:ImGuiTable
Flags	imgui_internal.h	/^    ImGuiWindowFlags        Flags;                              \/\/ See enum ImGuiWindowFlags_$/;"	m	struct:ImGuiWindow
FlattenIntoSingleLayer	imgui.cpp	/^void ImDrawDataBuilder::FlattenIntoSingleLayer()$/;"	f	class:ImDrawDataBuilder
Floor	imgui_internal.h	/^    void        Floor()                             { Min.x = IM_FLOOR(Min.x); Min.y = IM_FLOOR(Min.y); Max.x = IM_FLOOR(Max.x); Max.y = IM_FLOOR(Max.y); }$/;"	f	struct:ImRect
FocusCounterRegular	imgui_internal.h	/^    int                     FocusCounterRegular;    \/\/ (Legacy Focus\/Tabbing system) Sequential counter, start at -1 and increase as assigned via FocusableItemRegister() (FIXME-NAV: Needs redesign)$/;"	m	struct:ImGuiWindowTempData
FocusCounterTabStop	imgui_internal.h	/^    int                     FocusCounterTabStop;    \/\/ (Legacy Focus\/Tabbing system) Same, but only count widgets which you can Tab through.$/;"	m	struct:ImGuiWindowTempData
FocusOrder	imgui_internal.h	/^    short                   FocusOrder;                         \/\/ Order within WindowsFocusOrder[], altered when windows are focused.$/;"	m	struct:ImGuiWindow
FocusScopeId	imgui_internal.h	/^    ImGuiID                     FocusScopeId;   \/\/ Set by SetNextItemMultiSelectData() (!= 0 signify value has been set, so it's an alternate version of HasSelectionData, we don't use Flags for this because they are cleared too early. This is mostly used for debugging)$/;"	m	struct:ImGuiNextItemData
FocusScopeId	imgui_internal.h	/^    ImGuiID             FocusScopeId;   \/\/ Init,Move    \/\/ Best candidate focus scope ID$/;"	m	struct:ImGuiNavItemData
FocusScopeStack	imgui_internal.h	/^    ImVector<ImGuiID>       FocusScopeStack;                    \/\/ Stack for PushFocusScope()\/PopFocusScope() - not inherited by Begin(), unless child window$/;"	m	struct:ImGuiContext
FocusTopMostWindowUnderOne	imgui.cpp	/^void ImGui::FocusTopMostWindowUnderOne(ImGuiWindow* under_this_window, ImGuiWindow* ignore_window)$/;"	f	class:ImGui
FocusWindow	imgui.cpp	/^void ImGui::FocusWindow(ImGuiWindow* window)$/;"	f	class:ImGui
FocusableItemRegister	imgui.cpp	/^bool ImGui::FocusableItemRegister(ImGuiWindow* window, ImGuiID id)$/;"	f	class:ImGui
FocusableItemUnregister	imgui.cpp	/^void ImGui::FocusableItemUnregister(ImGuiWindow* window)$/;"	f	class:ImGui
Font	imgui.h	/^    ImFont*         Font;           \/\/ Input    \/\/ For custom font glyphs only: target font$/;"	m	struct:ImFontAtlasCustomRect
Font	imgui_internal.h	/^    ImFont*                 Font;                               \/\/ (Shortcut) == FontStack.empty() ? IO.Font : FontStack.back()$/;"	m	struct:ImGuiContext
Font	imgui_internal.h	/^    ImFont*         Font;                       \/\/ Current\/default font (optional, for simplified AddText overload)$/;"	m	struct:ImDrawListSharedData
FontAllowUserScaling	imgui.h	/^    bool        FontAllowUserScaling;           \/\/ = false          \/\/ Allow user scaling text of individual window with CTRL+Wheel.$/;"	m	struct:ImGuiIO
FontAtlasOwnedByContext	imgui_internal.h	/^    bool                    FontAtlasOwnedByContext;            \/\/ IO.Fonts-> is owned by the ImGuiContext and will be destructed along with it.$/;"	m	struct:ImGuiContext
FontBaseSize	imgui_internal.h	/^    float                   FontBaseSize;                       \/\/ (Shortcut) == IO.FontGlobalScale * Font->Scale * Font->FontSize. Base text height.$/;"	m	struct:ImGuiContext
FontBuilderFlags	imgui.h	/^    unsigned int                FontBuilderFlags;   \/\/ Shared flags (for all fonts) for custom font builder. THIS IS BUILD IMPLEMENTATION DEPENDENT. Per-font override is also available in ImFontConfig.$/;"	m	struct:ImFontAtlas
FontBuilderFlags	imgui.h	/^    unsigned int    FontBuilderFlags;       \/\/ 0        \/\/ Settings for custom font builder. THIS IS BUILDER IMPLEMENTATION DEPENDENT. Leave as zero if unsure.$/;"	m	struct:ImFontConfig
FontBuilderIO	imgui.h	/^    const ImFontBuilderIO*      FontBuilderIO;      \/\/ Opaque interface to a font builder (default to stb_truetype, can be changed to use FreeType by defining IMGUI_ENABLE_FREETYPE).$/;"	m	struct:ImFontAtlas
FontBuilder_Build	imgui_internal.h	/^    bool    (*FontBuilder_Build)(ImFontAtlas* atlas);$/;"	m	struct:ImFontBuilderIO
FontData	imgui.h	/^    void*           FontData;               \/\/          \/\/ TTF\/OTF data$/;"	m	struct:ImFontConfig
FontDataOwnedByAtlas	imgui.h	/^    bool            FontDataOwnedByAtlas;   \/\/ true     \/\/ TTF\/OTF data ownership taken by the container ImFontAtlas (will delete memory itself).$/;"	m	struct:ImFontConfig
FontDataSize	imgui.h	/^    int             FontDataSize;           \/\/          \/\/ TTF\/OTF data size$/;"	m	struct:ImFontConfig
FontDefault	imgui.h	/^    ImFont*     FontDefault;                    \/\/ = NULL           \/\/ Font to use on NewFrame(). Use NULL to uses Fonts->Fonts[0].$/;"	m	struct:ImGuiIO
FontGlobalScale	imgui.h	/^    float       FontGlobalScale;                \/\/ = 1.0f           \/\/ Global scale all fonts$/;"	m	struct:ImGuiIO
FontInfo	imgui_draw.cpp	/^    stbtt_fontinfo      FontInfo;$/;"	m	struct:ImFontBuildSrcData	file:
FontNo	imgui.h	/^    int             FontNo;                 \/\/ 0        \/\/ Index of font within TTF\/OTF file$/;"	m	struct:ImFontConfig
FontSize	imgui.h	/^    float                       FontSize;           \/\/ 4     \/\/ in  \/\/            \/\/ Height of characters\/line, set during loading (don't change after loading)$/;"	m	struct:ImFont
FontSize	imgui_internal.h	/^    float                   FontSize;                           \/\/ (Shortcut) == FontBaseSize * g.CurrentWindow->FontWindowScale == window->FontSize(). Text height for current window.$/;"	m	struct:ImGuiContext
FontSize	imgui_internal.h	/^    float           FontSize;                   \/\/ Current\/default font size (optional, for simplified AddText overload)$/;"	m	struct:ImDrawListSharedData
FontStack	imgui_internal.h	/^    ImVector<ImFont*>       FontStack;                          \/\/ Stack for PushFont()\/PopFont() - inherited by Begin()$/;"	m	struct:ImGuiContext
FontWindowScale	imgui_internal.h	/^    float                   FontWindowScale;                    \/\/ User scale multiplier per-window, via SetWindowFontScale()$/;"	m	struct:ImGuiWindow
Fonts	imgui.h	/^    ImFontAtlas*Fonts;                          \/\/ <auto>           \/\/ Font atlas: load, rasterize and pack one or more fonts into a single texture.$/;"	m	struct:ImGuiIO
Fonts	imgui.h	/^    ImVector<ImFont*>           Fonts;              \/\/ Hold all the fonts returned by AddFont*. Fonts[0] is the default font upon calling ImGui::NewFrame(), use ImGui::PushFont()\/PopFont() to change the current font.$/;"	m	struct:ImFontAtlas
FrameBorderSize	imgui.h	/^    float       FrameBorderSize;            \/\/ Thickness of border around frames. Generally set to 0.0f or 1.0f. (Other values are not well tested and more CPU\/GPU costly).$/;"	m	struct:ImGuiStyle
FrameCount	imgui_internal.h	/^    int                     FrameCount;$/;"	m	struct:ImGuiContext
FrameCountEnded	imgui_internal.h	/^    int                     FrameCountEnded;$/;"	m	struct:ImGuiContext
FrameCountRendered	imgui_internal.h	/^    int                     FrameCountRendered;$/;"	m	struct:ImGuiContext
FramePadding	imgui.h	/^    ImVec2      FramePadding;               \/\/ Padding within a framed rectangle (used by most widgets).$/;"	m	struct:ImGuiStyle
FramePadding	imgui_internal.h	/^    ImVec2              FramePadding;           \/\/ style.FramePadding locked at the time of BeginTabBar()$/;"	m	struct:ImGuiTabBar
FrameRounding	imgui.h	/^    float       FrameRounding;              \/\/ Radius of frame corners rounding. Set to 0.0f to have rectangular frame (used by most widgets).$/;"	m	struct:ImGuiStyle
FramebufferScale	imgui.h	/^    ImVec2          FramebufferScale;       \/\/ Amount of pixels for each unit of DisplaySize. Based on io.DisplayFramebufferScale. Generally (1,1) on normal display, (2,2) on OSX with Retina display.$/;"	m	struct:ImDrawData
Framerate	imgui.h	/^    float       Framerate;                      \/\/ Application framerate estimate, in frame per second. Solely for convenience. Rolling average estimation based on io.DeltaTime over 120 frames.$/;"	m	struct:ImGuiIO
FramerateSecPerFrame	imgui_internal.h	/^    float                   FramerateSecPerFrame[120];          \/\/ Calculate estimate of framerate for user over the last 2 seconds.$/;"	m	struct:ImGuiContext
FramerateSecPerFrameAccum	imgui_internal.h	/^    float                   FramerateSecPerFrameAccum;$/;"	m	struct:ImGuiContext
FramerateSecPerFrameIdx	imgui_internal.h	/^    int                     FramerateSecPerFrameIdx;$/;"	m	struct:ImGuiContext
FreeIdx	imgui_internal.h	/^    ImPoolIdx       FreeIdx;    \/\/ Next free idx to use$/;"	m	struct:ImPool
FreeWrapper	imgui.cpp	/^static void    FreeWrapper(void* ptr, void* user_data)        { IM_UNUSED(user_data); IM_UNUSED(ptr); IM_ASSERT(0); }$/;"	f	file:
FreeWrapper	imgui.cpp	/^static void    FreeWrapper(void* ptr, void* user_data)        { IM_UNUSED(user_data); free(ptr); }$/;"	f	file:
FreezeColumnsCount	imgui_internal.h	/^    ImGuiTableColumnIdx         FreezeColumnsCount;         \/\/ Actual frozen columns count (== FreezeColumnsRequest, or == 0 when no scrolling offset)$/;"	m	struct:ImGuiTable
FreezeColumnsRequest	imgui_internal.h	/^    ImGuiTableColumnIdx         FreezeColumnsRequest;       \/\/ Requested frozen columns count$/;"	m	struct:ImGuiTable
FreezeRowsCount	imgui_internal.h	/^    ImGuiTableColumnIdx         FreezeRowsCount;            \/\/ Actual frozen row count (== FreezeRowsRequest, or == 0 when no scrolling offset)$/;"	m	struct:ImGuiTable
FreezeRowsRequest	imgui_internal.h	/^    ImGuiTableColumnIdx         FreezeRowsRequest;          \/\/ Requested frozen rows count$/;"	m	struct:ImGuiTable
GCrc32LookupTable	imgui.cpp	/^static const ImU32 GCrc32LookupTable[256] =$/;"	v	file:
GDataTypeInfo	imgui_widgets.cpp	/^static const ImGuiDataTypeInfo GDataTypeInfo[] =$/;"	v	file:
GImAllocatorAllocFunc	imgui.cpp	/^static ImGuiMemAllocFunc    GImAllocatorAllocFunc = MallocWrapper;$/;"	v	file:
GImAllocatorFreeFunc	imgui.cpp	/^static ImGuiMemFreeFunc     GImAllocatorFreeFunc = FreeWrapper;$/;"	v	file:
GImAllocatorUserData	imgui.cpp	/^static void*                GImAllocatorUserData = NULL;$/;"	v	file:
GStyleVarInfo	imgui.cpp	/^static const ImGuiStyleVarInfo GStyleVarInfo[] =$/;"	v	file:
GcAwakeTransientWindowBuffers	imgui.cpp	/^void ImGui::GcAwakeTransientWindowBuffers(ImGuiWindow* window)$/;"	f	class:ImGui
GcCompactAll	imgui_internal.h	/^    bool                    GcCompactAll;                       \/\/ Request full GC$/;"	m	struct:ImGuiContext
GcCompactTransientMiscBuffers	imgui.cpp	/^void ImGui::GcCompactTransientMiscBuffers()$/;"	f	class:ImGui
GcCompactTransientWindowBuffers	imgui.cpp	/^void ImGui::GcCompactTransientWindowBuffers(ImGuiWindow* window)$/;"	f	class:ImGui
GetActiveID	imgui_internal.h	/^    inline ImGuiID          GetActiveID()   { ImGuiContext& g = *GImGui; return g.ActiveId; }$/;"	f	namespace:ImGui
GetAllocatorFunctions	imgui.cpp	/^void ImGui::GetAllocatorFunctions(ImGuiMemAllocFunc* p_alloc_func, ImGuiMemFreeFunc* p_free_func, void** p_user_data)$/;"	f	class:ImGui
GetArea	imgui_internal.h	/^    float       GetArea() const                     { return (Max.x - Min.x) * (Max.y - Min.y); }$/;"	f	struct:ImRect
GetArenaSizeInBytes	imgui_internal.h	/^    inline int   GetArenaSizeInBytes()              { return CurrOff; }$/;"	f	struct:ImSpanAllocator
GetBL	imgui_internal.h	/^    ImVec2      GetBL() const                       { return ImVec2(Min.x, Max.y); }  \/\/ Bottom-left$/;"	f	struct:ImRect
GetBR	imgui_internal.h	/^    ImVec2      GetBR() const                       { return Max; }                   \/\/ Bottom-right$/;"	f	struct:ImRect
GetBackgroundDrawList	imgui.cpp	/^ImDrawList* ImGui::GetBackgroundDrawList()$/;"	f	class:ImGui
GetBackgroundDrawList	imgui.cpp	/^ImDrawList* ImGui::GetBackgroundDrawList(ImGuiViewport* viewport)$/;"	f	class:ImGui
GetBit	imgui.h	/^    inline bool     GetBit(size_t n) const  { int off = (int)(n >> 5); ImU32 mask = 1u << (n & 31); return (UsedChars[off] & mask) != 0; }  \/\/ Get bit n in the array$/;"	f	struct:ImFontGlyphRangesBuilder
GetBool	imgui.cpp	/^bool ImGuiStorage::GetBool(ImGuiID key, bool default_val) const$/;"	f	class:ImGuiStorage
GetBoolRef	imgui.cpp	/^bool* ImGuiStorage::GetBoolRef(ImGuiID key, bool default_val)$/;"	f	class:ImGuiStorage
GetBuildWorkRect	imgui_internal.h	/^    ImRect  GetBuildWorkRect() const    { ImVec2 pos = CalcWorkRectPos(BuildWorkOffsetMin); ImVec2 size = CalcWorkRectSize(BuildWorkOffsetMin, BuildWorkOffsetMax); return ImRect(pos.x, pos.y, pos.x + size.x, pos.y + size.y); }$/;"	f	struct:ImGuiViewportP
GetByIndex	imgui_internal.h	/^    T*          GetByIndex(ImPoolIdx n)             { return &Buf[n]; }$/;"	f	struct:ImPool
GetByKey	imgui_internal.h	/^    T*          GetByKey(ImGuiID key)               { int idx = Map.GetInt(key, -1); return (idx != -1) ? &Buf[idx] : NULL; }$/;"	f	struct:ImPool
GetCenter	imgui.h	/^    ImVec2              GetCenter() const       { return ImVec2(Pos.x + Size.x * 0.5f, Pos.y + Size.y * 0.5f); }$/;"	f	struct:ImGuiViewport
GetCenter	imgui_internal.h	/^    ImVec2      GetCenter() const                   { return ImVec2((Min.x + Max.x) * 0.5f, (Min.y + Max.y) * 0.5f); }$/;"	f	struct:ImRect
GetCharAdvance	imgui.h	/^    float                       GetCharAdvance(ImWchar c) const     { return ((int)c < IndexAdvanceX.Size) ? IndexAdvanceX[(int)c] : FallbackAdvanceX; }$/;"	f	struct:ImFont
GetClipRectMax	imgui.h	/^    inline ImVec2   GetClipRectMax() const { const ImVec4& cr = _ClipRectStack.back(); return ImVec2(cr.z, cr.w); }$/;"	f	struct:ImDrawList
GetClipRectMin	imgui.h	/^    inline ImVec2   GetClipRectMin() const { const ImVec4& cr = _ClipRectStack.back(); return ImVec2(cr.x, cr.y); }$/;"	f	struct:ImDrawList
GetClipboardText	imgui.cpp	/^const char* ImGui::GetClipboardText()$/;"	f	class:ImGui
GetClipboardTextFn	imgui.h	/^    const char* (*GetClipboardTextFn)(void* user_data);$/;"	m	struct:ImGuiIO
GetClipboardTextFn_DefaultImpl	imgui.cpp	/^static const char* GetClipboardTextFn_DefaultImpl(void*)$/;"	f	file:
GetColorU32	imgui.cpp	/^ImU32 ImGui::GetColorU32(ImGuiCol idx, float alpha_mul)$/;"	f	class:ImGui
GetColorU32	imgui.cpp	/^ImU32 ImGui::GetColorU32(ImU32 col)$/;"	f	class:ImGui
GetColorU32	imgui.cpp	/^ImU32 ImGui::GetColorU32(const ImVec4& col)$/;"	f	class:ImGui
GetColumnIndex	imgui_tables.cpp	/^int ImGui::GetColumnIndex()$/;"	f	class:ImGui
GetColumnNormFromOffset	imgui_tables.cpp	/^float ImGui::GetColumnNormFromOffset(const ImGuiOldColumns* columns, float offset)$/;"	f	class:ImGui
GetColumnOffset	imgui_tables.cpp	/^float ImGui::GetColumnOffset(int column_index)$/;"	f	class:ImGui
GetColumnOffsetFromNorm	imgui_tables.cpp	/^float ImGui::GetColumnOffsetFromNorm(const ImGuiOldColumns* columns, float offset_norm)$/;"	f	class:ImGui
GetColumnSettings	imgui_internal.h	/^    ImGuiTableColumnSettings*   GetColumnSettings()     { return (ImGuiTableColumnSettings*)(this + 1); }$/;"	f	struct:ImGuiTableSettings
GetColumnWidth	imgui_tables.cpp	/^float ImGui::GetColumnWidth(int column_index)$/;"	f	class:ImGui
GetColumnWidthEx	imgui_tables.cpp	/^static float GetColumnWidthEx(ImGuiOldColumns* columns, int column_index, bool before_resize = false)$/;"	f	file:
GetColumnsCount	imgui_tables.cpp	/^int ImGui::GetColumnsCount()$/;"	f	class:ImGui
GetColumnsID	imgui_tables.cpp	/^ImGuiID ImGui::GetColumnsID(const char* str_id, int columns_count)$/;"	f	class:ImGui
GetContentRegionAvail	imgui.cpp	/^ImVec2 ImGui::GetContentRegionAvail()$/;"	f	class:ImGui
GetContentRegionAvailWidth	imgui.h	/^    static inline float GetContentRegionAvailWidth()        { return GetContentRegionAvail().x; }$/;"	f	namespace:ImGui
GetContentRegionMax	imgui.cpp	/^ImVec2 ImGui::GetContentRegionMax()$/;"	f	class:ImGui
GetContentRegionMaxAbs	imgui.cpp	/^ImVec2 ImGui::GetContentRegionMaxAbs()$/;"	f	class:ImGui
GetCurrentContext	imgui.cpp	/^ImGuiContext* ImGui::GetCurrentContext()$/;"	f	class:ImGui
GetCurrentTable	imgui_internal.h	/^    inline    ImGuiTable*   GetCurrentTable() { ImGuiContext& g = *GImGui; return g.CurrentTable; }$/;"	f	namespace:ImGui
GetCurrentWindow	imgui_internal.h	/^    inline    ImGuiWindow*  GetCurrentWindow()          { ImGuiContext& g = *GImGui; g.CurrentWindow->WriteAccessed = true; return g.CurrentWindow; }$/;"	f	namespace:ImGui
GetCurrentWindowRead	imgui_internal.h	/^    inline    ImGuiWindow*  GetCurrentWindowRead()      { ImGuiContext& g = *GImGui; return g.CurrentWindow; }$/;"	f	namespace:ImGui
GetCursorPos	imgui.cpp	/^ImVec2 ImGui::GetCursorPos()$/;"	f	class:ImGui
GetCursorPosX	imgui.cpp	/^float ImGui::GetCursorPosX()$/;"	f	class:ImGui
GetCursorPosY	imgui.cpp	/^float ImGui::GetCursorPosY()$/;"	f	class:ImGui
GetCursorScreenPos	imgui.cpp	/^ImVec2 ImGui::GetCursorScreenPos()$/;"	f	class:ImGui
GetCursorStartPos	imgui.cpp	/^ImVec2 ImGui::GetCursorStartPos()$/;"	f	class:ImGui
GetCustomRectByIndex	imgui.h	/^    ImFontAtlasCustomRect*      GetCustomRectByIndex(int index) { IM_ASSERT(index >= 0); return &CustomRects[index]; }$/;"	f	struct:ImFontAtlas
GetDebugName	imgui.h	/^    const char*                 GetDebugName() const                { return ConfigData ? ConfigData->Name : "<unknown>"; }$/;"	f	struct:ImFont
GetDefaultCompressedFontDataTTFBase85	imgui_draw.cpp	/^static const char* GetDefaultCompressedFontDataTTFBase85()$/;"	f	file:
GetDefaultFont	imgui_internal.h	/^    inline ImFont*          GetDefaultFont() { ImGuiContext& g = *GImGui; return g.IO.FontDefault ? g.IO.FontDefault : g.IO.Fonts->Fonts[0]; }$/;"	f	namespace:ImGui
GetDragDropPayload	imgui.cpp	/^const ImGuiPayload* ImGui::GetDragDropPayload()$/;"	f	class:ImGui
GetDraggedColumnOffset	imgui_tables.cpp	/^static float GetDraggedColumnOffset(ImGuiOldColumns* columns, int column_index)$/;"	f	file:
GetDrawData	imgui.cpp	/^ImDrawData* ImGui::GetDrawData()$/;"	f	class:ImGui
GetDrawListCount	imgui_internal.h	/^    int  GetDrawListCount() const   { int count = 0; for (int n = 0; n < IM_ARRAYSIZE(Layers); n++) count += Layers[n].Size; return count; }$/;"	f	struct:ImDrawDataBuilder
GetDrawListSharedData	imgui.cpp	/^ImDrawListSharedData* ImGui::GetDrawListSharedData()$/;"	f	class:ImGui
GetFallbackWindowNameForWindowingList	imgui.cpp	/^static const char* GetFallbackWindowNameForWindowingList(ImGuiWindow* window)$/;"	f	file:
GetFloat	imgui.cpp	/^float ImGuiStorage::GetFloat(ImGuiID key, float default_val) const$/;"	f	class:ImGuiStorage
GetFloatRef	imgui.cpp	/^float* ImGuiStorage::GetFloatRef(ImGuiID key, float default_val)$/;"	f	class:ImGuiStorage
GetFocusID	imgui_internal.h	/^    inline ImGuiID          GetFocusID()    { ImGuiContext& g = *GImGui; return g.NavId; }$/;"	f	namespace:ImGui
GetFocusScope	imgui_internal.h	/^    inline ImGuiID          GetFocusScope()                 { ImGuiContext& g = *GImGui; return g.CurrentWindow->DC.NavFocusScopeIdCurrent; }   \/\/ Focus scope we are outputting into, set by PushFocusScope()$/;"	f	namespace:ImGui
GetFocusedFocusScope	imgui_internal.h	/^    inline ImGuiID          GetFocusedFocusScope()          { ImGuiContext& g = *GImGui; return g.NavFocusScopeId; }                            \/\/ Focus scope which is actually active$/;"	f	namespace:ImGui
GetFont	imgui.cpp	/^ImFont* ImGui::GetFont()$/;"	f	class:ImGui
GetFontSize	imgui.cpp	/^float ImGui::GetFontSize()$/;"	f	class:ImGui
GetFontTexUvWhitePixel	imgui.cpp	/^ImVec2 ImGui::GetFontTexUvWhitePixel()$/;"	f	class:ImGui
GetForegroundDrawList	imgui.cpp	/^ImDrawList* ImGui::GetForegroundDrawList()$/;"	f	class:ImGui
GetForegroundDrawList	imgui.cpp	/^ImDrawList* ImGui::GetForegroundDrawList(ImGuiViewport* viewport)$/;"	f	class:ImGui
GetForegroundDrawList	imgui_internal.h	/^    inline ImDrawList*      GetForegroundDrawList(ImGuiWindow* window) { IM_UNUSED(window); return GetForegroundDrawList(); } \/\/ This seemingly unnecessary wrapper simplifies compatibility between the 'master' and 'docking' branches.$/;"	f	namespace:ImGui
GetFrameCount	imgui.cpp	/^int ImGui::GetFrameCount()$/;"	f	class:ImGui
GetFrameHeight	imgui.cpp	/^float ImGui::GetFrameHeight()$/;"	f	class:ImGui
GetFrameHeightWithSpacing	imgui.cpp	/^float ImGui::GetFrameHeightWithSpacing()$/;"	f	class:ImGui
GetGlyphRangesChineseFull	imgui_draw.cpp	/^const ImWchar*  ImFontAtlas::GetGlyphRangesChineseFull()$/;"	f	class:ImFontAtlas
GetGlyphRangesChineseSimplifiedCommon	imgui_draw.cpp	/^const ImWchar*  ImFontAtlas::GetGlyphRangesChineseSimplifiedCommon()$/;"	f	class:ImFontAtlas
GetGlyphRangesCyrillic	imgui_draw.cpp	/^const ImWchar*  ImFontAtlas::GetGlyphRangesCyrillic()$/;"	f	class:ImFontAtlas
GetGlyphRangesDefault	imgui_draw.cpp	/^const ImWchar*   ImFontAtlas::GetGlyphRangesDefault()$/;"	f	class:ImFontAtlas
GetGlyphRangesJapanese	imgui_draw.cpp	/^const ImWchar*  ImFontAtlas::GetGlyphRangesJapanese()$/;"	f	class:ImFontAtlas
GetGlyphRangesKorean	imgui_draw.cpp	/^const ImWchar*  ImFontAtlas::GetGlyphRangesKorean()$/;"	f	class:ImFontAtlas
GetGlyphRangesThai	imgui_draw.cpp	/^const ImWchar*  ImFontAtlas::GetGlyphRangesThai()$/;"	f	class:ImFontAtlas
GetGlyphRangesVietnamese	imgui_draw.cpp	/^const ImWchar*  ImFontAtlas::GetGlyphRangesVietnamese()$/;"	f	class:ImFontAtlas
GetHeight	imgui_internal.h	/^    float       GetHeight() const                   { return Max.y - Min.y; }$/;"	f	struct:ImRect
GetHoveredID	imgui.cpp	/^ImGuiID ImGui::GetHoveredID()$/;"	f	class:ImGui
GetID	imgui.cpp	/^ImGuiID ImGui::GetID(const char* str_id)$/;"	f	class:ImGui
GetID	imgui.cpp	/^ImGuiID ImGui::GetID(const char* str_id_begin, const char* str_id_end)$/;"	f	class:ImGui
GetID	imgui.cpp	/^ImGuiID ImGui::GetID(const void* ptr_id)$/;"	f	class:ImGui
GetID	imgui.cpp	/^ImGuiID ImGuiWindow::GetID(const char* str, const char* str_end)$/;"	f	class:ImGuiWindow
GetID	imgui.cpp	/^ImGuiID ImGuiWindow::GetID(const void* ptr)$/;"	f	class:ImGuiWindow
GetID	imgui.cpp	/^ImGuiID ImGuiWindow::GetID(int n)$/;"	f	class:ImGuiWindow
GetIDFromRectangle	imgui.cpp	/^ImGuiID ImGuiWindow::GetIDFromRectangle(const ImRect& r_abs)$/;"	f	class:ImGuiWindow
GetIDNoKeepAlive	imgui.cpp	/^ImGuiID ImGuiWindow::GetIDNoKeepAlive(const char* str, const char* str_end)$/;"	f	class:ImGuiWindow
GetIDNoKeepAlive	imgui.cpp	/^ImGuiID ImGuiWindow::GetIDNoKeepAlive(const void* ptr)$/;"	f	class:ImGuiWindow
GetIDNoKeepAlive	imgui.cpp	/^ImGuiID ImGuiWindow::GetIDNoKeepAlive(int n)$/;"	f	class:ImGuiWindow
GetIDWithSeed	imgui.cpp	/^ImGuiID ImGui::GetIDWithSeed(const char* str, const char* str_end, ImGuiID seed)$/;"	f	class:ImGui
GetIO	imgui.cpp	/^ImGuiIO& ImGui::GetIO()$/;"	f	class:ImGui
GetIndex	imgui_internal.h	/^    ImPoolIdx   GetIndex(const T* p) const          { IM_ASSERT(p >= Buf.Data && p < Buf.Data + Buf.Size); return (ImPoolIdx)(p - Buf.Data); }$/;"	f	struct:ImPool
GetInputTextState	imgui_internal.h	/^    inline ImGuiInputTextState* GetInputTextState(ImGuiID id)   { ImGuiContext& g = *GImGui; return (g.InputTextState.ID == id) ? &g.InputTextState : NULL; } \/\/ Get input text state if active$/;"	f	namespace:ImGui
GetInt	imgui.cpp	/^int ImGuiStorage::GetInt(ImGuiID key, int default_val) const$/;"	f	class:ImGuiStorage
GetIntRef	imgui.cpp	/^int* ImGuiStorage::GetIntRef(ImGuiID key, int default_val)$/;"	f	class:ImGuiStorage
GetItemID	imgui_internal.h	/^    inline ImGuiID          GetItemID()     { ImGuiContext& g = *GImGui; return g.CurrentWindow->DC.LastItemId; }   \/\/ Get ID of last item (~~ often same ImGui::GetID(label) beforehand)$/;"	f	namespace:ImGui
GetItemRectMax	imgui.cpp	/^ImVec2 ImGui::GetItemRectMax()$/;"	f	class:ImGui
GetItemRectMin	imgui.cpp	/^ImVec2 ImGui::GetItemRectMin()$/;"	f	class:ImGui
GetItemRectSize	imgui.cpp	/^ImVec2 ImGui::GetItemRectSize()$/;"	f	class:ImGui
GetItemStatusFlags	imgui_internal.h	/^    inline ImGuiItemStatusFlags GetItemStatusFlags() { ImGuiContext& g = *GImGui; return g.CurrentWindow->DC.LastItemStatusFlags; }$/;"	f	namespace:ImGui
GetItemsFlags	imgui_internal.h	/^    inline ImGuiItemFlags   GetItemsFlags() { ImGuiContext& g = *GImGui; return g.CurrentWindow->DC.ItemFlags; }$/;"	f	namespace:ImGui
GetKeyIndex	imgui.cpp	/^int ImGui::GetKeyIndex(ImGuiKey imgui_key)$/;"	f	class:ImGui
GetKeyPressedAmount	imgui.cpp	/^int ImGui::GetKeyPressedAmount(int key_index, float repeat_delay, float repeat_rate)$/;"	f	class:ImGui
GetMainRect	imgui_internal.h	/^    ImRect  GetMainRect() const         { return ImRect(Pos.x, Pos.y, Pos.x + Size.x, Pos.y + Size.y); }$/;"	f	struct:ImGuiViewportP
GetMainViewport	imgui.cpp	/^ImGuiViewport* ImGui::GetMainViewport()$/;"	f	class:ImGui
GetMergedKeyModFlags	imgui.cpp	/^ImGuiKeyModFlags ImGui::GetMergedKeyModFlags()$/;"	f	class:ImGui
GetMinimumStepAtDecimalPrecision	imgui_widgets.cpp	/^static float GetMinimumStepAtDecimalPrecision(int decimal_precision)$/;"	f	file:
GetMouseCursor	imgui.cpp	/^ImGuiMouseCursor ImGui::GetMouseCursor()$/;"	f	class:ImGui
GetMouseCursorTexData	imgui_draw.cpp	/^bool ImFontAtlas::GetMouseCursorTexData(ImGuiMouseCursor cursor_type, ImVec2* out_offset, ImVec2* out_size, ImVec2 out_uv_border[2], ImVec2 out_uv_fill[2])$/;"	f	class:ImFontAtlas
GetMouseDragDelta	imgui.cpp	/^ImVec2 ImGui::GetMouseDragDelta(ImGuiMouseButton button, float lock_threshold)$/;"	f	class:ImGui
GetMousePos	imgui.cpp	/^ImVec2 ImGui::GetMousePos()$/;"	f	class:ImGui
GetMousePosOnOpeningCurrentPopup	imgui.cpp	/^ImVec2 ImGui::GetMousePosOnOpeningCurrentPopup()$/;"	f	class:ImGui
GetName	imgui_internal.h	/^    char* GetName()             { return (char*)(this + 1); }$/;"	f	struct:ImGuiWindowSettings
GetNavInputAmount	imgui.cpp	/^float ImGui::GetNavInputAmount(ImGuiNavInput n, ImGuiInputReadMode mode)$/;"	f	class:ImGui
GetNavInputAmount2d	imgui.cpp	/^ImVec2 ImGui::GetNavInputAmount2d(ImGuiNavDirSourceFlags dir_sources, ImGuiInputReadMode mode, float slow_factor, float fast_factor)$/;"	f	class:ImGui
GetOrAddByKey	imgui_internal.h	/^    T*          GetOrAddByKey(ImGuiID key)          { int* p_idx = Map.GetIntRef(key, -1); if (*p_idx != -1) return &Buf[*p_idx]; *p_idx = FreeIdx; return Add(); }$/;"	f	struct:ImPool
GetOverlayDrawList	imgui.h	/^    static inline ImDrawList* GetOverlayDrawList()          { return GetForegroundDrawList(); }$/;"	f	namespace:ImGui
GetRedoAvailCount	imgui_internal.h	/^    int         GetRedoAvailCount() const   { return STB_TEXTEDIT_UNDOSTATECOUNT - Stb.undostate.redo_point; }$/;"	f	struct:ImGuiInputTextState
GetResizeBorderRect	imgui.cpp	/^static ImRect GetResizeBorderRect(ImGuiWindow* window, int border_n, float perp_padding, float thickness)$/;"	f	file:
GetScrollMaxX	imgui.cpp	/^float ImGui::GetScrollMaxX()$/;"	f	class:ImGui
GetScrollMaxY	imgui.cpp	/^float ImGui::GetScrollMaxY()$/;"	f	class:ImGui
GetScrollX	imgui.cpp	/^float ImGui::GetScrollX()$/;"	f	class:ImGui
GetScrollY	imgui.cpp	/^float ImGui::GetScrollY()$/;"	f	class:ImGui
GetSize	imgui_internal.h	/^    ImVec2      GetSize() const                     { return ImVec2(Max.x - Min.x, Max.y - Min.y); }$/;"	f	struct:ImRect
GetSize	imgui_internal.h	/^    int         GetSize() const                     { return Buf.Size; }$/;"	f	struct:ImPool
GetSkipItemForListClipping	imgui.cpp	/^static bool GetSkipItemForListClipping()$/;"	f	file:
GetSpan	imgui_internal.h	/^    inline void  GetSpan(int n, ImSpan<T>* span)    { span->set((T*)GetSpanPtrBegin(n), (T*)GetSpanPtrEnd(n)); }$/;"	f	struct:ImSpanAllocator
GetSpanPtrBegin	imgui_internal.h	/^    inline void* GetSpanPtrBegin(int n)             { IM_ASSERT(n >= 0 && n < CHUNKS && CurrIdx == CHUNKS); return (void*)(BasePtr + Offsets[n]); }$/;"	f	struct:ImSpanAllocator
GetSpanPtrEnd	imgui_internal.h	/^    inline void* GetSpanPtrEnd(int n)               { IM_ASSERT(n >= 0 && n < CHUNKS && CurrIdx == CHUNKS); return (void*)(BasePtr + Offsets[n] + Sizes[n]); }$/;"	f	struct:ImSpanAllocator
GetStateStorage	imgui.cpp	/^ImGuiStorage* ImGui::GetStateStorage()$/;"	f	class:ImGui
GetStyle	imgui.cpp	/^ImGuiStyle& ImGui::GetStyle()$/;"	f	class:ImGui
GetStyleColorName	imgui.cpp	/^const char* ImGui::GetStyleColorName(ImGuiCol idx)$/;"	f	class:ImGui
GetStyleColorVec4	imgui.cpp	/^const ImVec4& ImGui::GetStyleColorVec4(ImGuiCol idx)$/;"	f	class:ImGui
GetStyleVarInfo	imgui.cpp	/^static const ImGuiStyleVarInfo* GetStyleVarInfo(ImGuiStyleVar idx)$/;"	f	file:
GetTL	imgui_internal.h	/^    ImVec2      GetTL() const                       { return Min; }                   \/\/ Top-left$/;"	f	struct:ImRect
GetTR	imgui_internal.h	/^    ImVec2      GetTR() const                       { return ImVec2(Max.x, Min.y); }  \/\/ Top-right$/;"	f	struct:ImRect
GetTabBarFromTabBarRef	imgui_widgets.cpp	/^static ImGuiTabBar* GetTabBarFromTabBarRef(const ImGuiPtrOrIndex& ref)$/;"	f	file:
GetTabBarRefFromTabBar	imgui_widgets.cpp	/^static ImGuiPtrOrIndex GetTabBarRefFromTabBar(ImGuiTabBar* tab_bar)$/;"	f	file:
GetTabName	imgui_internal.h	/^    const char*         GetTabName(const ImGuiTabItem* tab) const$/;"	f	struct:ImGuiTabBar
GetTabOrder	imgui_internal.h	/^    int                 GetTabOrder(const ImGuiTabItem* tab) const  { return Tabs.index_from_ptr(tab); }$/;"	f	struct:ImGuiTabBar
GetTexDataAsAlpha8	imgui_draw.cpp	/^void    ImFontAtlas::GetTexDataAsAlpha8(unsigned char** out_pixels, int* out_width, int* out_height, int* out_bytes_per_pixel)$/;"	f	class:ImFontAtlas
GetTexDataAsRGBA32	imgui_draw.cpp	/^void    ImFontAtlas::GetTexDataAsRGBA32(unsigned char** out_pixels, int* out_width, int* out_height, int* out_bytes_per_pixel)$/;"	f	class:ImFontAtlas
GetTextLineHeight	imgui.cpp	/^float ImGui::GetTextLineHeight()$/;"	f	class:ImGui
GetTextLineHeightWithSpacing	imgui.cpp	/^float ImGui::GetTextLineHeightWithSpacing()$/;"	f	class:ImGui
GetTime	imgui.cpp	/^double ImGui::GetTime()$/;"	f	class:ImGui
GetTopMostPopupModal	imgui.cpp	/^ImGuiWindow* ImGui::GetTopMostPopupModal()$/;"	f	class:ImGui
GetTreeNodeToLabelSpacing	imgui_widgets.cpp	/^float ImGui::GetTreeNodeToLabelSpacing()$/;"	f	class:ImGui
GetUndoAvailCount	imgui_internal.h	/^    int         GetUndoAvailCount() const   { return Stb.undostate.undo_point; }$/;"	f	struct:ImGuiInputTextState
GetVarPtr	imgui.cpp	/^    void*           GetVarPtr(ImGuiStyle* style) const { return (void*)((unsigned char*)style + Offset); }$/;"	f	struct:ImGuiStyleVarInfo
GetVersion	imgui.cpp	/^const char* ImGui::GetVersion()$/;"	f	class:ImGui
GetViewportDrawList	imgui.cpp	/^static ImDrawList* GetViewportDrawList(ImGuiViewportP* viewport, size_t drawlist_no, const char* drawlist_name)$/;"	f	file:
GetVoidPtr	imgui.cpp	/^void* ImGuiStorage::GetVoidPtr(ImGuiID key) const$/;"	f	class:ImGuiStorage
GetVoidPtrRef	imgui.cpp	/^void** ImGuiStorage::GetVoidPtrRef(ImGuiID key, void* default_val)$/;"	f	class:ImGuiStorage
GetWidth	imgui_internal.h	/^    float       GetWidth() const                    { return Max.x - Min.x; }$/;"	f	struct:ImRect
GetWindowAllowedExtentRect	imgui.cpp	/^ImRect ImGui::GetWindowAllowedExtentRect(ImGuiWindow* window)$/;"	f	class:ImGui
GetWindowBgColorIdxFromFlags	imgui.cpp	/^static ImGuiCol GetWindowBgColorIdxFromFlags(ImGuiWindowFlags flags)$/;"	f	file:
GetWindowContentRegionMax	imgui.cpp	/^ImVec2 ImGui::GetWindowContentRegionMax()$/;"	f	class:ImGui
GetWindowContentRegionMin	imgui.cpp	/^ImVec2 ImGui::GetWindowContentRegionMin()$/;"	f	class:ImGui
GetWindowContentRegionWidth	imgui.cpp	/^float ImGui::GetWindowContentRegionWidth()$/;"	f	class:ImGui
GetWindowDrawList	imgui.cpp	/^ImDrawList* ImGui::GetWindowDrawList()$/;"	f	class:ImGui
GetWindowHeight	imgui.cpp	/^float ImGui::GetWindowHeight()$/;"	f	class:ImGui
GetWindowPos	imgui.cpp	/^ImVec2 ImGui::GetWindowPos()$/;"	f	class:ImGui
GetWindowResizeBorderID	imgui.cpp	/^ImGuiID ImGui::GetWindowResizeBorderID(ImGuiWindow* window, ImGuiDir dir)$/;"	f	class:ImGui
GetWindowResizeCornerID	imgui.cpp	/^ImGuiID ImGui::GetWindowResizeCornerID(ImGuiWindow* window, int n)$/;"	f	class:ImGui
GetWindowScrollbarID	imgui_widgets.cpp	/^ImGuiID ImGui::GetWindowScrollbarID(ImGuiWindow* window, ImGuiAxis axis)$/;"	f	class:ImGui
GetWindowScrollbarRect	imgui_widgets.cpp	/^ImRect ImGui::GetWindowScrollbarRect(ImGuiWindow* window, ImGuiAxis axis)$/;"	f	class:ImGui
GetWindowSize	imgui.cpp	/^ImVec2 ImGui::GetWindowSize()$/;"	f	class:ImGui
GetWindowWidth	imgui.cpp	/^float ImGui::GetWindowWidth()$/;"	f	class:ImGui
GetWorkCenter	imgui.h	/^    ImVec2              GetWorkCenter() const   { return ImVec2(WorkPos.x + WorkSize.x * 0.5f, WorkPos.y + WorkSize.y * 0.5f); }$/;"	f	struct:ImGuiViewport
GetWorkRect	imgui_internal.h	/^    ImRect  GetWorkRect() const         { return ImRect(WorkPos.x, WorkPos.y, WorkPos.x + WorkSize.x, WorkPos.y + WorkSize.y); }$/;"	f	struct:ImGuiViewportP
GlyphAdvanceX	imgui.h	/^    float           GlyphAdvanceX;  \/\/ Input    \/\/ For custom font glyphs only: glyph xadvance$/;"	m	struct:ImFontAtlasCustomRect
GlyphExtraSpacing	imgui.h	/^    ImVec2          GlyphExtraSpacing;      \/\/ 0, 0     \/\/ Extra spacing (in pixels) between glyphs. Only X axis is supported for now.$/;"	m	struct:ImFontConfig
GlyphID	imgui.h	/^    unsigned int    GlyphID;        \/\/ Input    \/\/ For custom font glyphs only (ID < 0x110000)$/;"	m	struct:ImFontAtlasCustomRect
GlyphMaxAdvanceX	imgui.h	/^    float           GlyphMaxAdvanceX;       \/\/ FLT_MAX  \/\/ Maximum AdvanceX for glyphs$/;"	m	struct:ImFontConfig
GlyphMinAdvanceX	imgui.h	/^    float           GlyphMinAdvanceX;       \/\/ 0        \/\/ Minimum AdvanceX for glyphs, set Min to align font icons, set both Min\/Max to enforce mono-space font$/;"	m	struct:ImFontConfig
GlyphOffset	imgui.h	/^    ImVec2          GlyphOffset;            \/\/ 0, 0     \/\/ Offset all glyphs from this font input.$/;"	m	struct:ImFontConfig
GlyphOffset	imgui.h	/^    ImVec2          GlyphOffset;    \/\/ Input    \/\/ For custom font glyphs only: glyph display offset$/;"	m	struct:ImFontAtlasCustomRect
GlyphRanges	imgui.h	/^    const ImWchar*  GlyphRanges;            \/\/ NULL     \/\/ Pointer to a user-provided list of Unicode range (2 value per range, values are inclusive, zero-terminated list). THE ARRAY DATA NEEDS TO PERSIST AS LONG AS THE FONT IS ALIVE.$/;"	m	struct:ImFontConfig
GlyphRangesBuilder	imgui.h	/^    typedef ImFontGlyphRangesBuilder GlyphRangesBuilder; \/\/ OBSOLETED in 1.67+$/;"	t	struct:ImFontAtlas
Glyphs	imgui.h	/^    ImVector<ImFontGlyph>       Glyphs;             \/\/ 12-16 \/\/ out \/\/            \/\/ All glyphs.$/;"	m	struct:ImFont
GlyphsCount	imgui_draw.cpp	/^    int                 GlyphsCount;        \/\/ Glyph count (excluding missing glyphs and glyphs already set by an earlier source font)$/;"	m	struct:ImFontBuildSrcData	file:
GlyphsCount	imgui_draw.cpp	/^    int                 GlyphsCount;$/;"	m	struct:ImFontBuildDstData	file:
GlyphsHighest	imgui_draw.cpp	/^    int                 GlyphsHighest;      \/\/ Highest requested codepoint$/;"	m	struct:ImFontBuildSrcData	file:
GlyphsHighest	imgui_draw.cpp	/^    int                 GlyphsHighest;$/;"	m	struct:ImFontBuildDstData	file:
GlyphsList	imgui_draw.cpp	/^    ImVector<int>       GlyphsList;         \/\/ Glyph codepoints list (flattened version of GlyphsMap)$/;"	m	struct:ImFontBuildSrcData	file:
GlyphsSet	imgui_draw.cpp	/^    ImBitVector         GlyphsSet;          \/\/ Glyph bit map (random access, 1-bit per codepoint. This will be a maximum of 8KB)$/;"	m	struct:ImFontBuildSrcData	file:
GlyphsSet	imgui_draw.cpp	/^    ImBitVector         GlyphsSet;          \/\/ This is used to resolve collision when multiple sources are merged into a same destination font.$/;"	m	struct:ImFontBuildDstData	file:
GrabMinSize	imgui.h	/^    float       GrabMinSize;                \/\/ Minimum width\/height of a grab box for slider\/scrollbar.$/;"	m	struct:ImGuiStyle
GrabRounding	imgui.h	/^    float       GrabRounding;               \/\/ Radius of grabs corners rounding. Set to 0.0f to have rectangular slider grabs.$/;"	m	struct:ImGuiStyle
GroupOffset	imgui_internal.h	/^    ImVec1                  GroupOffset;$/;"	m	struct:ImGuiWindowTempData
GroupStack	imgui_internal.h	/^    ImVector<ImGuiGroupData>GroupStack;                         \/\/ Stack for BeginGroup()\/EndGroup() - not inherited by Begin()$/;"	m	struct:ImGuiContext
GrowIndex	imgui_draw.cpp	/^void ImFont::GrowIndex(int new_size)$/;"	f	class:ImFont
HSV	imgui.h	/^    static ImColor HSV(float h, float s, float v, float a = 1.0f)   { float r, g, b; ImGui::ColorConvertHSVtoRGB(h, s, v, r, g, b); return ImColor(r, g, b, a); }$/;"	f	struct:ImColor
HasCloseButton	imgui_internal.h	/^    bool                    HasCloseButton;                     \/\/ Set when the window has a close button (p_open != NULL)$/;"	m	struct:ImGuiWindow
HasSelection	imgui.h	/^    bool                HasSelection() const    { return SelectionStart != SelectionEnd; }$/;"	f	struct:ImGuiInputTextCallbackData
HasSelection	imgui_internal.h	/^    bool        HasSelection() const        { return Stb.select_start != Stb.select_end; }$/;"	f	struct:ImGuiInputTextState
Height	imgui.h	/^    unsigned short  Width, Height;  \/\/ Input    \/\/ Desired rectangle dimension$/;"	m	struct:ImFontAtlasCustomRect
HeldHeaderColumn	imgui_internal.h	/^    ImGuiTableColumnIdx         HeldHeaderColumn;           \/\/ Index of column header being held.$/;"	m	struct:ImGuiTable
HelpMarker	imgui_demo.cpp	/^static void HelpMarker(const char* desc)$/;"	f	file:
Hidden	imgui_internal.h	/^    bool                    Hidden;                             \/\/ Do not display (== HiddenFrames*** > 0)$/;"	m	struct:ImGuiWindow
HiddenFramesCanSkipItems	imgui_internal.h	/^    ImS8                    HiddenFramesCanSkipItems;           \/\/ Hide the window for N frames$/;"	m	struct:ImGuiWindow
HiddenFramesCannotSkipItems	imgui_internal.h	/^    ImS8                    HiddenFramesCannotSkipItems;        \/\/ Hide the window for N frames while allowing items to be submitted so we can measure their size$/;"	m	struct:ImGuiWindow
HiddenFramesForRenderOnly	imgui_internal.h	/^    ImS8                    HiddenFramesForRenderOnly;          \/\/ Hide the window until frame N at Render() time only$/;"	m	struct:ImGuiWindow
History	imgui_demo.cpp	/^    ImVector<char*>       History;$/;"	m	struct:ExampleAppConsole	file:
HistoryPos	imgui_demo.cpp	/^    int                   HistoryPos;    \/\/ -1: new line, 0..History.Size-1 browsing history.$/;"	m	struct:ExampleAppConsole	file:
HitTestHoleOffset	imgui_internal.h	/^    ImVec2ih                HitTestHoleOffset;$/;"	m	struct:ImGuiWindow
HitTestHoleSize	imgui_internal.h	/^    ImVec2ih                HitTestHoleSize;                    \/\/ Define an optional rectangular hole where mouse will pass-through the window.$/;"	m	struct:ImGuiWindow
HookId	imgui_internal.h	/^    ImGuiID                     HookId;     \/\/ A unique ID assigned by AddContextHook()$/;"	m	struct:ImGuiContextHook
HookIdNext	imgui_internal.h	/^    ImGuiID                             HookIdNext;             \/\/ Next available HookId$/;"	m	struct:ImGuiContext
Hooks	imgui_internal.h	/^    ImVector<ImGuiContextHook>          Hooks;                  \/\/ Hooks for extensions (e.g. test engine)$/;"	m	struct:ImGuiContext
HostBackupClipRect	imgui_internal.h	/^    ImRect              HostBackupClipRect;     \/\/ Backup of ClipRect during PushColumnsBackground()\/PopColumnsBackground()$/;"	m	struct:ImGuiOldColumns
HostBackupColumnsOffset	imgui_internal.h	/^    ImVec1                      HostBackupColumnsOffset;    \/\/ Backup of OuterWindow->DC.ColumnsOffset at the end of BeginTable()$/;"	m	struct:ImGuiTable
HostBackupCurrLineSize	imgui_internal.h	/^    ImVec2                      HostBackupCurrLineSize;     \/\/ Backup of InnerWindow->DC.CurrLineSize at the end of BeginTable()$/;"	m	struct:ImGuiTable
HostBackupCursorMaxPos	imgui_internal.h	/^    ImVec2                      HostBackupCursorMaxPos;     \/\/ Backup of InnerWindow->DC.CursorMaxPos at the end of BeginTable()$/;"	m	struct:ImGuiTable
HostBackupInnerClipRect	imgui_internal.h	/^    ImRect                      HostBackupInnerClipRect;    \/\/ Backup of InnerWindow->ClipRect during PushTableBackground()\/PopTableBackground()$/;"	m	struct:ImGuiTable
HostBackupItemWidth	imgui_internal.h	/^    float                       HostBackupItemWidth;        \/\/ Backup of OuterWindow->DC.ItemWidth at the end of BeginTable()$/;"	m	struct:ImGuiTable
HostBackupItemWidthStackSize	imgui_internal.h	/^    int                         HostBackupItemWidthStackSize;\/\/ Backup of OuterWindow->DC.ItemWidthStack.Size at the end of BeginTable()$/;"	m	struct:ImGuiTable
HostBackupParentWorkRect	imgui_internal.h	/^    ImRect                      HostBackupParentWorkRect;   \/\/ Backup of InnerWindow->ParentWorkRect at the end of BeginTable()$/;"	m	struct:ImGuiTable
HostBackupParentWorkRect	imgui_internal.h	/^    ImRect              HostBackupParentWorkRect;\/\/Backup of WorkRect at the time of BeginColumns()$/;"	m	struct:ImGuiOldColumns
HostBackupPrevLineSize	imgui_internal.h	/^    ImVec2                      HostBackupPrevLineSize;     \/\/ Backup of InnerWindow->DC.PrevLineSize at the end of BeginTable()$/;"	m	struct:ImGuiTable
HostBackupWorkRect	imgui_internal.h	/^    ImRect                      HostBackupWorkRect;         \/\/ Backup of InnerWindow->WorkRect at the end of BeginTable()$/;"	m	struct:ImGuiTable
HostClipRect	imgui_internal.h	/^    ImRect                      HostClipRect;               \/\/ This is used to check if we can eventually merge our columns draw calls into the current draw call of the current window.$/;"	m	struct:ImGuiTable
HostCursorMaxPosX	imgui_internal.h	/^    float               HostCursorMaxPosX;      \/\/ Backup of CursorMaxPos at the time of BeginColumns()$/;"	m	struct:ImGuiOldColumns
HostCursorPosY	imgui_internal.h	/^    float               HostCursorPosY;         \/\/ Backup of CursorPos at the time of BeginColumns()$/;"	m	struct:ImGuiOldColumns
HostIndentX	imgui_internal.h	/^    float                       HostIndentX;$/;"	m	struct:ImGuiTable
HostInitialClipRect	imgui_internal.h	/^    ImRect              HostInitialClipRect;    \/\/ Backup of ClipRect at the time of BeginColumns()$/;"	m	struct:ImGuiOldColumns
HostSkipItems	imgui_internal.h	/^    bool                        HostSkipItems;              \/\/ Backup of InnerWindow->SkipItem at the end of BeginTable(), because we will overwrite InnerWindow->SkipItem on a per-column basis$/;"	m	struct:ImGuiTable
HoveredColumnBody	imgui_internal.h	/^    ImGuiTableColumnIdx         HoveredColumnBody;          \/\/ Index of column whose visible region is being hovered. Important: == ColumnsCount when hovering empty region after the right-most column!$/;"	m	struct:ImGuiTable
HoveredColumnBorder	imgui_internal.h	/^    ImGuiTableColumnIdx         HoveredColumnBorder;        \/\/ Index of column whose right-border is being hovered (for resizing).$/;"	m	struct:ImGuiTable
HoveredId	imgui_internal.h	/^    ImGuiID                 HoveredId;                          \/\/ Hovered widget, filled during the frame$/;"	m	struct:ImGuiContext
HoveredIdAllowOverlap	imgui_internal.h	/^    bool                    HoveredIdAllowOverlap;$/;"	m	struct:ImGuiContext
HoveredIdDisabled	imgui_internal.h	/^    bool                    HoveredIdDisabled;                  \/\/ At least one widget passed the rect test, but has been discarded by disabled flag or popup inhibit. May be true even if HoveredId == 0.$/;"	m	struct:ImGuiContext
HoveredIdNotActiveTimer	imgui_internal.h	/^    float                   HoveredIdNotActiveTimer;            \/\/ Measure contiguous hovering time where the item has not been active$/;"	m	struct:ImGuiContext
HoveredIdPreviousFrame	imgui_internal.h	/^    ImGuiID                 HoveredIdPreviousFrame;$/;"	m	struct:ImGuiContext
HoveredIdPreviousFrameUsingMouseWheel	imgui_internal.h	/^    bool                    HoveredIdPreviousFrameUsingMouseWheel;$/;"	m	struct:ImGuiContext
HoveredIdTimer	imgui_internal.h	/^    float                   HoveredIdTimer;                     \/\/ Measure contiguous hovering time$/;"	m	struct:ImGuiContext
HoveredIdUsingMouseWheel	imgui_internal.h	/^    bool                    HoveredIdUsingMouseWheel;           \/\/ Hovered widget will use mouse wheel. Blocks scrolling the underlying window.$/;"	m	struct:ImGuiContext
HoveredWindow	imgui_internal.h	/^    ImGuiWindow*            HoveredWindow;                      \/\/ Window the mouse is hovering. Will typically catch mouse inputs.$/;"	m	struct:ImGuiContext
HoveredWindowUnderMovingWindow	imgui_internal.h	/^    ImGuiWindow*            HoveredWindowUnderMovingWindow;     \/\/ Hovered window ignoring MovingWindow. Only set if MovingWindow is set.$/;"	m	struct:ImGuiContext
ID	imgui_demo.cpp	/^    int         ID;$/;"	m	struct:__anon29::MyItem	file:
ID	imgui_internal.h	/^    ImGuiID                     ID;                     \/\/ Set to 0 to invalidate\/delete the setting$/;"	m	struct:ImGuiTableSettings
ID	imgui_internal.h	/^    ImGuiID                     ID;$/;"	m	struct:ImGuiTable
ID	imgui_internal.h	/^    ImGuiID                 ID;                                 \/\/ == ImHashStr(Name)$/;"	m	struct:ImGuiWindow
ID	imgui_internal.h	/^    ImGuiID                 ID;                     \/\/ widget id owning the text state$/;"	m	struct:ImGuiInputTextState
ID	imgui_internal.h	/^    ImGuiID             ID;                     \/\/ Zero for tab-bars used by docking$/;"	m	struct:ImGuiTabBar
ID	imgui_internal.h	/^    ImGuiID             ID;             \/\/ Init,Move    \/\/ Best candidate item ID$/;"	m	struct:ImGuiNavItemData
ID	imgui_internal.h	/^    ImGuiID             ID;$/;"	m	struct:ImGuiOldColumns
ID	imgui_internal.h	/^    ImGuiID             ID;$/;"	m	struct:ImGuiTabItem
ID	imgui_internal.h	/^    ImGuiID     ID;$/;"	m	struct:ImGuiWindowSettings
IDStack	imgui_internal.h	/^    ImVector<ImGuiID>       IDStack;                            \/\/ ID stack. ID are hashes seeded with the value at the top of the stack. (In theory this should be in the TempData structure)$/;"	m	struct:ImGuiWindow
IMGUI_API	imgui.h	/^#define IMGUI_API$/;"	d
IMGUI_CDECL	imgui_demo.cpp	/^#define IMGUI_CDECL /;"	d	file:
IMGUI_CDECL	imgui_demo.cpp	/^#define IMGUI_CDECL$/;"	d	file:
IMGUI_CDECL	imgui_internal.h	/^#define IMGUI_CDECL /;"	d
IMGUI_CHECKVERSION	imgui.h	/^#define IMGUI_CHECKVERSION(/;"	d
IMGUI_DEBUG_INI_SETTINGS	imgui.cpp	/^#define IMGUI_DEBUG_INI_SETTINGS /;"	d	file:
IMGUI_DEBUG_LOG	imgui_internal.h	/^#define IMGUI_DEBUG_LOG(/;"	d
IMGUI_DEBUG_LOG_NAV	imgui_internal.h	/^#define IMGUI_DEBUG_LOG_NAV(/;"	d
IMGUI_DEBUG_LOG_POPUP	imgui_internal.h	/^#define IMGUI_DEBUG_LOG_POPUP(/;"	d
IMGUI_DEBUG_NAV_RECTS	imgui.cpp	/^#define IMGUI_DEBUG_NAV_RECTS /;"	d	file:
IMGUI_DEBUG_NAV_SCORING	imgui.cpp	/^#define IMGUI_DEBUG_NAV_SCORING /;"	d	file:
IMGUI_DEFINE_MATH_OPERATORS	imgui.cpp	/^#define IMGUI_DEFINE_MATH_OPERATORS$/;"	d	file:
IMGUI_DEFINE_MATH_OPERATORS	imgui_draw.cpp	/^#define IMGUI_DEFINE_MATH_OPERATORS$/;"	d	file:
IMGUI_DEFINE_MATH_OPERATORS	imgui_tables.cpp	/^#define IMGUI_DEFINE_MATH_OPERATORS$/;"	d	file:
IMGUI_DEFINE_MATH_OPERATORS	imgui_widgets.cpp	/^#define IMGUI_DEFINE_MATH_OPERATORS$/;"	d	file:
IMGUI_DISABLE_DEFAULT_FILE_FUNCTIONS	imgui_internal.h	/^#define IMGUI_DISABLE_DEFAULT_FILE_FUNCTIONS$/;"	d
IMGUI_DISABLE_TTY_FUNCTIONS	imgui_internal.h	/^#define IMGUI_DISABLE_TTY_FUNCTIONS /;"	d
IMGUI_DISABLE_WIN32_DEFAULT_CLIPBOARD_FUNCTIONS	imgui.cpp	/^#define IMGUI_DISABLE_WIN32_DEFAULT_CLIPBOARD_FUNCTIONS$/;"	d	file:
IMGUI_DISABLE_WIN32_DEFAULT_IME_FUNCTIONS	imgui.cpp	/^#define IMGUI_DISABLE_WIN32_DEFAULT_IME_FUNCTIONS$/;"	d	file:
IMGUI_DISABLE_WIN32_FUNCTIONS	imgui.cpp	/^#define IMGUI_DISABLE_WIN32_FUNCTIONS$/;"	d	file:
IMGUI_ENABLE_STB_TRUETYPE	imgui_internal.h	/^#define IMGUI_ENABLE_STB_TRUETYPE$/;"	d
IMGUI_HAS_TABLE	imgui.h	/^#define IMGUI_HAS_TABLE$/;"	d
IMGUI_IMPL_API	imgui.h	/^#define IMGUI_IMPL_API /;"	d
IMGUI_PAYLOAD_TYPE_COLOR_3F	imgui.h	/^#define IMGUI_PAYLOAD_TYPE_COLOR_3F /;"	d
IMGUI_PAYLOAD_TYPE_COLOR_4F	imgui.h	/^#define IMGUI_PAYLOAD_TYPE_COLOR_4F /;"	d
IMGUI_STB_NAMESPACE	imgui_draw.cpp	/^namespace IMGUI_STB_NAMESPACE$/;"	n	file:
IMGUI_TABLE_MAX_COLUMNS	imgui_internal.h	/^#define IMGUI_TABLE_MAX_COLUMNS /;"	d
IMGUI_TABLE_MAX_DRAW_CHANNELS	imgui_internal.h	/^#define IMGUI_TABLE_MAX_DRAW_CHANNELS /;"	d
IMGUI_TEST_ENGINE_ID_INFO	imgui_internal.h	/^#define IMGUI_TEST_ENGINE_ID_INFO(/;"	d
IMGUI_TEST_ENGINE_ID_INFO2	imgui_internal.h	/^#define IMGUI_TEST_ENGINE_ID_INFO2(/;"	d
IMGUI_TEST_ENGINE_ITEM_ADD	imgui_internal.h	/^#define IMGUI_TEST_ENGINE_ITEM_ADD(/;"	d
IMGUI_TEST_ENGINE_ITEM_INFO	imgui_internal.h	/^#define IMGUI_TEST_ENGINE_ITEM_INFO(/;"	d
IMGUI_TEST_ENGINE_LOG	imgui_internal.h	/^#define IMGUI_TEST_ENGINE_LOG(/;"	d
IMGUI_VERSION	imgui.h	/^#define IMGUI_VERSION /;"	d
IMGUI_VERSION_NUM	imgui.h	/^#define IMGUI_VERSION_NUM /;"	d
IM_ALLOC	imgui.h	/^#define IM_ALLOC(/;"	d
IM_ARRAYSIZE	imgui.h	/^#define IM_ARRAYSIZE(/;"	d
IM_ASSERT	imgui.h	/^#define IM_ASSERT(/;"	d
IM_ASSERT_PARANOID	imgui_internal.h	/^#define IM_ASSERT_PARANOID(/;"	d
IM_ASSERT_USER_ERROR	imgui_internal.h	/^#define IM_ASSERT_USER_ERROR(/;"	d
IM_CLAMP	imgui_demo.cpp	/^#define IM_CLAMP(/;"	d	file:
IM_COL32	imgui.h	/^#define IM_COL32(/;"	d
IM_COL32_A_MASK	imgui.h	/^#define IM_COL32_A_MASK /;"	d
IM_COL32_A_SHIFT	imgui.h	/^#define IM_COL32_A_SHIFT /;"	d
IM_COL32_BLACK	imgui.h	/^#define IM_COL32_BLACK /;"	d
IM_COL32_BLACK_TRANS	imgui.h	/^#define IM_COL32_BLACK_TRANS /;"	d
IM_COL32_B_SHIFT	imgui.h	/^#define IM_COL32_B_SHIFT /;"	d
IM_COL32_DISABLE	imgui_internal.h	/^#define IM_COL32_DISABLE /;"	d
IM_COL32_G_SHIFT	imgui.h	/^#define IM_COL32_G_SHIFT /;"	d
IM_COL32_R_SHIFT	imgui.h	/^#define IM_COL32_R_SHIFT /;"	d
IM_COL32_WHITE	imgui.h	/^#define IM_COL32_WHITE /;"	d
IM_DEBUG_BREAK	imgui_internal.h	/^#define IM_DEBUG_BREAK(/;"	d
IM_DELETE	imgui.h	/^template<typename T> void IM_DELETE(T* p)   { if (p) { p->~T(); ImGui::MemFree(p); } }$/;"	f
IM_DRAWLIST_ARCFAST_SAMPLE_MAX	imgui_internal.h	/^#define IM_DRAWLIST_ARCFAST_SAMPLE_MAX /;"	d
IM_DRAWLIST_ARCFAST_TABLE_SIZE	imgui_internal.h	/^#define IM_DRAWLIST_ARCFAST_TABLE_SIZE /;"	d
IM_DRAWLIST_CIRCLE_AUTO_SEGMENT_CALC	imgui_internal.h	/^#define IM_DRAWLIST_CIRCLE_AUTO_SEGMENT_CALC(/;"	d
IM_DRAWLIST_CIRCLE_AUTO_SEGMENT_CALC_ERROR	imgui_internal.h	/^#define IM_DRAWLIST_CIRCLE_AUTO_SEGMENT_CALC_ERROR(/;"	d
IM_DRAWLIST_CIRCLE_AUTO_SEGMENT_CALC_R	imgui_internal.h	/^#define IM_DRAWLIST_CIRCLE_AUTO_SEGMENT_CALC_R(/;"	d
IM_DRAWLIST_CIRCLE_AUTO_SEGMENT_MAX	imgui_internal.h	/^#define IM_DRAWLIST_CIRCLE_AUTO_SEGMENT_MAX /;"	d
IM_DRAWLIST_CIRCLE_AUTO_SEGMENT_MIN	imgui_internal.h	/^#define IM_DRAWLIST_CIRCLE_AUTO_SEGMENT_MIN /;"	d
IM_DRAWLIST_TEX_LINES_WIDTH_MAX	imgui.h	/^#define IM_DRAWLIST_TEX_LINES_WIDTH_MAX /;"	d
IM_F32_TO_INT8_SAT	imgui_internal.h	/^#define IM_F32_TO_INT8_SAT(/;"	d
IM_F32_TO_INT8_UNBOUND	imgui_internal.h	/^#define IM_F32_TO_INT8_UNBOUND(/;"	d
IM_FIXNORMAL2F	imgui_draw.cpp	/^#define IM_FIXNORMAL2F(/;"	d	file:
IM_FIXNORMAL2F_MAX_INVLEN2	imgui_draw.cpp	/^#define IM_FIXNORMAL2F_MAX_INVLEN2 /;"	d	file:
IM_FLOOR	imgui_internal.h	/^#define IM_FLOOR(/;"	d
IM_FMTARGS	imgui.h	/^#define IM_FMTARGS(/;"	d
IM_FMTLIST	imgui.h	/^#define IM_FMTLIST(/;"	d
IM_FREE	imgui.h	/^#define IM_FREE(/;"	d
IM_MAX	imgui_demo.cpp	/^#define IM_MAX(/;"	d	file:
IM_MEMALIGN	imgui_internal.h	/^#define IM_MEMALIGN(/;"	d
IM_MIN	imgui_demo.cpp	/^#define IM_MIN(/;"	d	file:
IM_NEW	imgui.h	/^#define IM_NEW(/;"	d
IM_NEWLINE	imgui_demo.cpp	/^#define IM_NEWLINE /;"	d	file:
IM_NEWLINE	imgui_internal.h	/^#define IM_NEWLINE /;"	d
IM_NORMALIZE2F_OVER_ZERO	imgui_draw.cpp	/^#define IM_NORMALIZE2F_OVER_ZERO(/;"	d	file:
IM_OFFSETOF	imgui.h	/^#define IM_OFFSETOF(/;"	d
IM_PI	imgui_internal.h	/^#define IM_PI /;"	d
IM_PLACEMENT_NEW	imgui.h	/^#define IM_PLACEMENT_NEW(/;"	d
IM_PRId64	imgui_demo.cpp	/^#define IM_PRId64 /;"	d	file:
IM_PRIu64	imgui_demo.cpp	/^#define IM_PRIu64 /;"	d	file:
IM_ROUND	imgui_internal.h	/^#define IM_ROUND(/;"	d
IM_ROUNDUP_TO_EVEN	imgui_internal.h	/^#define IM_ROUNDUP_TO_EVEN(/;"	d
IM_S16_MAX	imgui_widgets.cpp	/^static const signed short   IM_S16_MAX = 32767;$/;"	v	file:
IM_S16_MIN	imgui_widgets.cpp	/^static const signed short   IM_S16_MIN = -32768;$/;"	v	file:
IM_S32_MAX	imgui_widgets.cpp	/^static const ImS32          IM_S32_MAX = INT_MAX;    \/\/ (2147483647), (0x7FFFFFFF)$/;"	v	file:
IM_S32_MIN	imgui_widgets.cpp	/^static const ImS32          IM_S32_MIN = INT_MIN;    \/\/ (-2147483647 - 1), (0x80000000);$/;"	v	file:
IM_S64_MAX	imgui_widgets.cpp	/^static const ImS64          IM_S64_MAX = 9223372036854775807LL;$/;"	v	file:
IM_S64_MAX	imgui_widgets.cpp	/^static const ImS64          IM_S64_MAX = LLONG_MAX;  \/\/ (9223372036854775807ll);$/;"	v	file:
IM_S64_MIN	imgui_widgets.cpp	/^static const ImS64          IM_S64_MIN = -9223372036854775807LL - 1;$/;"	v	file:
IM_S64_MIN	imgui_widgets.cpp	/^static const ImS64          IM_S64_MIN = LLONG_MIN;  \/\/ (-9223372036854775807ll - 1ll);$/;"	v	file:
IM_S8_MAX	imgui_widgets.cpp	/^static const signed char    IM_S8_MAX  = 127;$/;"	v	file:
IM_S8_MIN	imgui_widgets.cpp	/^static const signed char    IM_S8_MIN  = -128;$/;"	v	file:
IM_STATIC_ASSERT	imgui_internal.h	/^#define IM_STATIC_ASSERT(/;"	d
IM_TABSIZE	imgui_internal.h	/^#define IM_TABSIZE /;"	d
IM_U16_MAX	imgui_widgets.cpp	/^static const unsigned short IM_U16_MAX = 0xFFFF;$/;"	v	file:
IM_U16_MIN	imgui_widgets.cpp	/^static const unsigned short IM_U16_MIN = 0;$/;"	v	file:
IM_U32_MAX	imgui_widgets.cpp	/^static const ImU32          IM_U32_MAX = UINT_MAX;   \/\/ (0xFFFFFFFF)$/;"	v	file:
IM_U32_MIN	imgui_widgets.cpp	/^static const ImU32          IM_U32_MIN = 0;$/;"	v	file:
IM_U64_MAX	imgui_widgets.cpp	/^static const ImU64          IM_U64_MAX = (2ULL * 9223372036854775807LL + 1);$/;"	v	file:
IM_U64_MAX	imgui_widgets.cpp	/^static const ImU64          IM_U64_MAX = ULLONG_MAX; \/\/ (0xFFFFFFFFFFFFFFFFull);$/;"	v	file:
IM_U64_MIN	imgui_widgets.cpp	/^static const ImU64          IM_U64_MIN = 0;$/;"	v	file:
IM_U8_MAX	imgui_widgets.cpp	/^static const unsigned char  IM_U8_MAX  = 0xFF;$/;"	v	file:
IM_U8_MIN	imgui_widgets.cpp	/^static const unsigned char  IM_U8_MIN  = 0;$/;"	v	file:
IM_UNICODE_CODEPOINT_INVALID	imgui.h	/^#define IM_UNICODE_CODEPOINT_INVALID /;"	d
IM_UNICODE_CODEPOINT_MAX	imgui.h	/^#define IM_UNICODE_CODEPOINT_MAX /;"	d
IM_UNUSED	imgui.h	/^#define IM_UNUSED(/;"	d
INCLUDE_STB_TEXTEDIT_H	imstb_textedit.h	/^#define INCLUDE_STB_TEXTEDIT_H$/;"	d
IO	imgui_internal.h	/^    ImGuiIO                 IO;$/;"	m	struct:ImGuiContext
IdealMaxPos	imgui_internal.h	/^    ImVec2                  IdealMaxPos;            \/\/ Used to implicitly calculate ContentSizeIdeal at the beginning of next frame, for auto-resize only. Always growing during the frame.$/;"	m	struct:ImGuiWindowTempData
IdxBuffer	imgui.h	/^    ImVector<ImDrawIdx>     IdxBuffer;          \/\/ Index buffer. Each command consume ImDrawCmd::ElemCount of those$/;"	m	struct:ImDrawList
IdxOffset	imgui.h	/^    unsigned int    IdxOffset;          \/\/ 4    \/\/ Start offset in index buffer. Always equal to sum of ElemCount drawn so far.$/;"	m	struct:ImDrawCmd
ImAbs	imgui_internal.h	/^static inline double ImAbs(double x)            { return fabs(x); }$/;"	f
ImAbs	imgui_internal.h	/^static inline float  ImAbs(float x)             { return fabsf(x); }$/;"	f
ImAbs	imgui_internal.h	/^static inline int    ImAbs(int x)               { return x < 0 ? -x : x; }$/;"	f
ImAcos	imgui_internal.h	/^#define ImAcos(/;"	d
ImAcos01	imgui_draw.cpp	/^static inline float ImAcos01(float x)$/;"	f	file:
ImAddClampOverflow	imgui_internal.h	/^template<typename T> static inline T ImAddClampOverflow(T a, T b, T mn, T mx)   { if (b < 0 && (a < mn - b)) return mn; if (b > 0 && (a > mx - b)) return mx; return a + b; }$/;"	f
ImAlphaBlendColors	imgui.cpp	/^IMGUI_API ImU32 ImAlphaBlendColors(ImU32 col_a, ImU32 col_b)$/;"	f
ImAtan2	imgui_internal.h	/^#define ImAtan2(/;"	d
ImAtof	imgui_internal.h	/^#define ImAtof(/;"	d
ImAtoi	imgui_widgets.cpp	/^static const char* ImAtoi(const char* src, TYPE* output)$/;"	f	file:
ImBezierCubicCalc	imgui_draw.cpp	/^ImVec2 ImBezierCubicCalc(const ImVec2& p1, const ImVec2& p2, const ImVec2& p3, const ImVec2& p4, float t)$/;"	f
ImBezierCubicClosestPoint	imgui.cpp	/^ImVec2 ImBezierCubicClosestPoint(const ImVec2& p1, const ImVec2& p2, const ImVec2& p3, const ImVec2& p4, const ImVec2& p, int num_segments)$/;"	f
ImBezierCubicClosestPointCasteljau	imgui.cpp	/^ImVec2 ImBezierCubicClosestPointCasteljau(const ImVec2& p1, const ImVec2& p2, const ImVec2& p3, const ImVec2& p4, const ImVec2& p, float tess_tol)$/;"	f
ImBezierCubicClosestPointCasteljauStep	imgui.cpp	/^static void ImBezierCubicClosestPointCasteljauStep(const ImVec2& p, ImVec2& p_closest, ImVec2& p_last, float& p_closest_dist2, float x1, float y1, float x2, float y2, float x3, float y3, float x4, float y4, float tess_tol, int level)$/;"	f	file:
ImBezierQuadraticCalc	imgui_draw.cpp	/^ImVec2 ImBezierQuadraticCalc(const ImVec2& p1, const ImVec2& p2, const ImVec2& p3, float t)$/;"	f
ImBitArray	imgui_internal.h	/^    ImBitArray()                                { }$/;"	f	struct:ImBitArray
ImBitArray	imgui_internal.h	/^struct IMGUI_API ImBitArray$/;"	s
ImBitArrayClearBit	imgui_internal.h	/^inline void     ImBitArrayClearBit(ImU32* arr, int n)           { ImU32 mask = (ImU32)1 << (n & 31); arr[n >> 5] &= ~mask; }$/;"	f
ImBitArraySetBit	imgui_internal.h	/^inline void     ImBitArraySetBit(ImU32* arr, int n)             { ImU32 mask = (ImU32)1 << (n & 31); arr[n >> 5] |= mask; }$/;"	f
ImBitArraySetBitRange	imgui_internal.h	/^inline void     ImBitArraySetBitRange(ImU32* arr, int n, int n2) \/\/ Works on range [n..n2)$/;"	f
ImBitArrayTestBit	imgui_internal.h	/^inline bool     ImBitArrayTestBit(const ImU32* arr, int n)      { ImU32 mask = (ImU32)1 << (n & 31); return (arr[n >> 5] & mask) != 0; }$/;"	f
ImBitVector	imgui_internal.h	/^struct IMGUI_API ImBitVector$/;"	s
ImCeil	imgui_internal.h	/^#define ImCeil(/;"	d
ImCharIsBlankA	imgui_internal.h	/^static inline bool      ImCharIsBlankA(char c)          { return c == ' ' || c == '\\t'; }$/;"	f
ImCharIsBlankW	imgui_internal.h	/^static inline bool      ImCharIsBlankW(unsigned int c)  { return c == ' ' || c == '\\t' || c == 0x3000; }$/;"	f
ImChunkStream	imgui_internal.h	/^struct IMGUI_API ImChunkStream$/;"	s
ImClamp	imgui_internal.h	/^static inline ImVec2 ImClamp(const ImVec2& v, const ImVec2& mn, ImVec2 mx)      { return ImVec2((v.x < mn.x) ? mn.x : (v.x > mx.x) ? mx.x : v.x, (v.y < mn.y) ? mn.y : (v.y > mx.y) ? mx.y : v.y); }$/;"	f
ImClamp	imgui_internal.h	/^template<typename T> static inline T ImClamp(T v, T mn, T mx)                   { return (v < mn) ? mn : (v > mx) ? mx : v; }$/;"	f
ImColor	imgui.h	/^    ImColor()                                                       { Value.x = Value.y = Value.z = Value.w = 0.0f; }$/;"	f	struct:ImColor
ImColor	imgui.h	/^    ImColor(ImU32 rgba)                                             { float sc = 1.0f \/ 255.0f; Value.x = (float)((rgba >> IM_COL32_R_SHIFT) & 0xFF) * sc; Value.y = (float)((rgba >> IM_COL32_G_SHIFT) & 0xFF) * sc; Value.z = (float)((rgba >> IM_COL32_B_SHIFT) & 0xFF) * sc; Value.w = (float)((rgba >> IM_COL32_A_SHIFT) & 0xFF) * sc; }$/;"	f	struct:ImColor
ImColor	imgui.h	/^    ImColor(const ImVec4& col)                                      { Value = col; }$/;"	f	struct:ImColor
ImColor	imgui.h	/^    ImColor(float r, float g, float b, float a = 1.0f)              { Value.x = r; Value.y = g; Value.z = b; Value.w = a; }$/;"	f	struct:ImColor
ImColor	imgui.h	/^    ImColor(int r, int g, int b, int a = 255)                       { float sc = 1.0f \/ 255.0f; Value.x = (float)r * sc; Value.y = (float)g * sc; Value.z = (float)b * sc; Value.w = (float)a * sc; }$/;"	f	struct:ImColor
ImColor	imgui.h	/^struct ImColor$/;"	s
ImCos	imgui_internal.h	/^#define ImCos(/;"	d
ImDot	imgui_internal.h	/^static inline float  ImDot(const ImVec2& a, const ImVec2& b)                    { return a.x * b.x + a.y * b.y; }$/;"	f
ImDrawCallback	imgui.h	/^typedef void (*ImDrawCallback)(const ImDrawList* parent_list, const ImDrawCmd* cmd);$/;"	t
ImDrawCallback_ResetRenderState	imgui.h	/^#define ImDrawCallback_ResetRenderState /;"	d
ImDrawChannel	imgui.h	/^struct ImDrawChannel$/;"	s
ImDrawCmd	imgui.h	/^    ImDrawCmd() { memset(this, 0, sizeof(*this)); } \/\/ Also ensure our padding fields are zeroed$/;"	f	struct:ImDrawCmd
ImDrawCmd	imgui.h	/^struct ImDrawCmd$/;"	s
ImDrawCmdHeader	imgui.h	/^struct ImDrawCmdHeader$/;"	s
ImDrawCmd_HeaderCompare	imgui_draw.cpp	/^#define ImDrawCmd_HeaderCompare(/;"	d	file:
ImDrawCmd_HeaderCopy	imgui_draw.cpp	/^#define ImDrawCmd_HeaderCopy(/;"	d	file:
ImDrawCmd_HeaderSize	imgui_draw.cpp	/^#define ImDrawCmd_HeaderSize /;"	d	file:
ImDrawCornerFlags	imgui.h	/^typedef ImDrawFlags ImDrawCornerFlags;$/;"	t
ImDrawCornerFlags_	imgui.h	/^enum ImDrawCornerFlags_$/;"	g
ImDrawCornerFlags_All	imgui.h	/^    ImDrawCornerFlags_All       = ImDrawFlags_RoundCornersAll,          \/\/ Was == 0x0F prior to 1.82$/;"	e	enum:ImDrawCornerFlags_
ImDrawCornerFlags_Bot	imgui.h	/^    ImDrawCornerFlags_Bot       = ImDrawCornerFlags_BotLeft | ImDrawCornerFlags_BotRight,$/;"	e	enum:ImDrawCornerFlags_
ImDrawCornerFlags_BotLeft	imgui.h	/^    ImDrawCornerFlags_BotLeft   = ImDrawFlags_RoundCornersBottomLeft,   \/\/ Was == 0x04 (1 << 2) prior to 1.82.$/;"	e	enum:ImDrawCornerFlags_
ImDrawCornerFlags_BotRight	imgui.h	/^    ImDrawCornerFlags_BotRight  = ImDrawFlags_RoundCornersBottomRight,  \/\/ Was == 0x08 (1 << 3) prior to 1.82.$/;"	e	enum:ImDrawCornerFlags_
ImDrawCornerFlags_Left	imgui.h	/^    ImDrawCornerFlags_Left      = ImDrawCornerFlags_TopLeft | ImDrawCornerFlags_BotLeft,$/;"	e	enum:ImDrawCornerFlags_
ImDrawCornerFlags_None	imgui.h	/^    ImDrawCornerFlags_None      = ImDrawFlags_RoundCornersNone,         \/\/ Was == 0 prior to 1.82, this is now == ImDrawFlags_RoundCornersNone which is != 0 and not implicit$/;"	e	enum:ImDrawCornerFlags_
ImDrawCornerFlags_Right	imgui.h	/^    ImDrawCornerFlags_Right     = ImDrawCornerFlags_TopRight | ImDrawCornerFlags_BotRight$/;"	e	enum:ImDrawCornerFlags_
ImDrawCornerFlags_Top	imgui.h	/^    ImDrawCornerFlags_Top       = ImDrawCornerFlags_TopLeft | ImDrawCornerFlags_TopRight,$/;"	e	enum:ImDrawCornerFlags_
ImDrawCornerFlags_TopLeft	imgui.h	/^    ImDrawCornerFlags_TopLeft   = ImDrawFlags_RoundCornersTopLeft,      \/\/ Was == 0x01 (1 << 0) prior to 1.82. Order matches ImDrawFlags_NoRoundCorner* flag (we exploit this internally).$/;"	e	enum:ImDrawCornerFlags_
ImDrawCornerFlags_TopRight	imgui.h	/^    ImDrawCornerFlags_TopRight  = ImDrawFlags_RoundCornersTopRight,     \/\/ Was == 0x02 (1 << 1) prior to 1.82.$/;"	e	enum:ImDrawCornerFlags_
ImDrawData	imgui.h	/^    ImDrawData()    { Clear(); }$/;"	f	struct:ImDrawData
ImDrawData	imgui.h	/^struct ImDrawData$/;"	s
ImDrawDataBuilder	imgui_internal.h	/^struct ImDrawDataBuilder$/;"	s
ImDrawFlags	imgui.h	/^typedef int ImDrawFlags;            \/\/ -> enum ImDrawFlags_          \/\/ Flags: for ImDrawList functions$/;"	t
ImDrawFlags_	imgui.h	/^enum ImDrawFlags_$/;"	g
ImDrawFlags_Closed	imgui.h	/^    ImDrawFlags_Closed                      = 1 << 0, \/\/ PathStroke(), AddPolyline(): specify that shape should be closed (Important: this is always == 1 for legacy reason)$/;"	e	enum:ImDrawFlags_
ImDrawFlags_None	imgui.h	/^    ImDrawFlags_None                        = 0,$/;"	e	enum:ImDrawFlags_
ImDrawFlags_RoundCornersAll	imgui.h	/^    ImDrawFlags_RoundCornersAll             = ImDrawFlags_RoundCornersTopLeft | ImDrawFlags_RoundCornersTopRight | ImDrawFlags_RoundCornersBottomLeft | ImDrawFlags_RoundCornersBottomRight,$/;"	e	enum:ImDrawFlags_
ImDrawFlags_RoundCornersBottom	imgui.h	/^    ImDrawFlags_RoundCornersBottom          = ImDrawFlags_RoundCornersBottomLeft | ImDrawFlags_RoundCornersBottomRight,$/;"	e	enum:ImDrawFlags_
ImDrawFlags_RoundCornersBottomLeft	imgui.h	/^    ImDrawFlags_RoundCornersBottomLeft      = 1 << 6, \/\/ AddRect(), AddRectFilled(), PathRect(): enable rounding bottom-left corner only (when rounding > 0.0f, we default to all corners). Was 0x04.$/;"	e	enum:ImDrawFlags_
ImDrawFlags_RoundCornersBottomRight	imgui.h	/^    ImDrawFlags_RoundCornersBottomRight     = 1 << 7, \/\/ AddRect(), AddRectFilled(), PathRect(): enable rounding bottom-right corner only (when rounding > 0.0f, we default to all corners). Wax 0x08.$/;"	e	enum:ImDrawFlags_
ImDrawFlags_RoundCornersDefault_	imgui.h	/^    ImDrawFlags_RoundCornersDefault_        = ImDrawFlags_RoundCornersAll, \/\/ Default to ALL corners if none of the _RoundCornersXX flags are specified.$/;"	e	enum:ImDrawFlags_
ImDrawFlags_RoundCornersLeft	imgui.h	/^    ImDrawFlags_RoundCornersLeft            = ImDrawFlags_RoundCornersBottomLeft | ImDrawFlags_RoundCornersTopLeft,$/;"	e	enum:ImDrawFlags_
ImDrawFlags_RoundCornersMask_	imgui.h	/^    ImDrawFlags_RoundCornersMask_           = ImDrawFlags_RoundCornersAll | ImDrawFlags_RoundCornersNone$/;"	e	enum:ImDrawFlags_
ImDrawFlags_RoundCornersNone	imgui.h	/^    ImDrawFlags_RoundCornersNone            = 1 << 8, \/\/ AddRect(), AddRectFilled(), PathRect(): disable rounding on all corners (when rounding > 0.0f). This is NOT zero, NOT an implicit flag!$/;"	e	enum:ImDrawFlags_
ImDrawFlags_RoundCornersRight	imgui.h	/^    ImDrawFlags_RoundCornersRight           = ImDrawFlags_RoundCornersBottomRight | ImDrawFlags_RoundCornersTopRight,$/;"	e	enum:ImDrawFlags_
ImDrawFlags_RoundCornersTop	imgui.h	/^    ImDrawFlags_RoundCornersTop             = ImDrawFlags_RoundCornersTopLeft | ImDrawFlags_RoundCornersTopRight,$/;"	e	enum:ImDrawFlags_
ImDrawFlags_RoundCornersTopLeft	imgui.h	/^    ImDrawFlags_RoundCornersTopLeft         = 1 << 4, \/\/ AddRect(), AddRectFilled(), PathRect(): enable rounding top-left corner only (when rounding > 0.0f, we default to all corners). Was 0x01.$/;"	e	enum:ImDrawFlags_
ImDrawFlags_RoundCornersTopRight	imgui.h	/^    ImDrawFlags_RoundCornersTopRight        = 1 << 5, \/\/ AddRect(), AddRectFilled(), PathRect(): enable rounding top-right corner only (when rounding > 0.0f, we default to all corners). Was 0x02.$/;"	e	enum:ImDrawFlags_
ImDrawIdx	imgui.h	/^typedef unsigned short ImDrawIdx;$/;"	t
ImDrawList	imgui.h	/^    ImDrawList(const ImDrawListSharedData* shared_data) { memset(this, 0, sizeof(*this)); _Data = shared_data; }$/;"	f	struct:ImDrawList
ImDrawList	imgui.h	/^struct ImDrawList$/;"	s
ImDrawListFlags	imgui.h	/^typedef int ImDrawListFlags;        \/\/ -> enum ImDrawListFlags_      \/\/ Flags: for ImDrawList instance$/;"	t
ImDrawListFlags_	imgui.h	/^enum ImDrawListFlags_$/;"	g
ImDrawListFlags_AllowVtxOffset	imgui.h	/^    ImDrawListFlags_AllowVtxOffset          = 1 << 3   \/\/ Can emit 'VtxOffset > 0' to allow large meshes. Set when 'ImGuiBackendFlags_RendererHasVtxOffset' is enabled.$/;"	e	enum:ImDrawListFlags_
ImDrawListFlags_AntiAliasedFill	imgui.h	/^    ImDrawListFlags_AntiAliasedFill         = 1 << 2,  \/\/ Enable anti-aliased edge around filled shapes (rounded rectangles, circles).$/;"	e	enum:ImDrawListFlags_
ImDrawListFlags_AntiAliasedLines	imgui.h	/^    ImDrawListFlags_AntiAliasedLines        = 1 << 0,  \/\/ Enable anti-aliased lines\/borders (*2 the number of triangles for 1.0f wide line or lines thin enough to be drawn using textures, otherwise *3 the number of triangles)$/;"	e	enum:ImDrawListFlags_
ImDrawListFlags_AntiAliasedLinesUseTex	imgui.h	/^    ImDrawListFlags_AntiAliasedLinesUseTex  = 1 << 1,  \/\/ Enable anti-aliased lines\/borders using textures when possible. Require backend to render with bilinear filtering.$/;"	e	enum:ImDrawListFlags_
ImDrawListFlags_None	imgui.h	/^    ImDrawListFlags_None                    = 0,$/;"	e	enum:ImDrawListFlags_
ImDrawListSharedData	imgui_draw.cpp	/^ImDrawListSharedData::ImDrawListSharedData()$/;"	f	class:ImDrawListSharedData
ImDrawListSharedData	imgui_internal.h	/^struct IMGUI_API ImDrawListSharedData$/;"	s
ImDrawListSplitter	imgui.h	/^    inline ImDrawListSplitter()  { memset(this, 0, sizeof(*this)); }$/;"	f	struct:ImDrawListSplitter
ImDrawListSplitter	imgui.h	/^struct ImDrawListSplitter$/;"	s
ImDrawVert	imgui.h	/^struct ImDrawVert$/;"	s
ImFabs	imgui_internal.h	/^#define ImFabs(/;"	d
ImFileClose	imgui.cpp	/^bool    ImFileClose(ImFileHandle f)     { return fclose(f) == 0; }$/;"	f
ImFileClose	imgui_internal.h	/^static inline bool          ImFileClose(ImFileHandle)                               { return false; }$/;"	f
ImFileGetSize	imgui.cpp	/^ImU64   ImFileGetSize(ImFileHandle f)   { long off = 0, sz = 0; return ((off = ftell(f)) != -1 && !fseek(f, 0, SEEK_END) && (sz = ftell(f)) != -1 && !fseek(f, off, SEEK_SET)) ? (ImU64)sz : (ImU64)-1; }$/;"	f
ImFileGetSize	imgui_internal.h	/^static inline ImU64         ImFileGetSize(ImFileHandle)                             { return (ImU64)-1; }$/;"	f
ImFileHandle	imgui_internal.h	/^typedef FILE* ImFileHandle;$/;"	t
ImFileHandle	imgui_internal.h	/^typedef void* ImFileHandle;$/;"	t
ImFileLoadToMemory	imgui.cpp	/^void*   ImFileLoadToMemory(const char* filename, const char* mode, size_t* out_file_size, int padding_bytes)$/;"	f
ImFileOpen	imgui.cpp	/^ImFileHandle ImFileOpen(const char* filename, const char* mode)$/;"	f
ImFileOpen	imgui_internal.h	/^static inline ImFileHandle  ImFileOpen(const char*, const char*)                    { return NULL; }$/;"	f
ImFileRead	imgui.cpp	/^ImU64   ImFileRead(void* data, ImU64 sz, ImU64 count, ImFileHandle f)           { return fread(data, (size_t)sz, (size_t)count, f); }$/;"	f
ImFileRead	imgui_internal.h	/^static inline ImU64         ImFileRead(void*, ImU64, ImU64, ImFileHandle)           { return 0; }$/;"	f
ImFileWrite	imgui.cpp	/^ImU64   ImFileWrite(const void* data, ImU64 sz, ImU64 count, ImFileHandle f)    { return fwrite(data, (size_t)sz, (size_t)count, f); }$/;"	f
ImFileWrite	imgui_internal.h	/^static inline ImU64         ImFileWrite(const void*, ImU64, ImU64, ImFileHandle)    { return 0; }$/;"	f
ImFloor	imgui_internal.h	/^static inline ImVec2 ImFloor(const ImVec2& v)                                   { return ImVec2((float)(int)(v.x), (float)(int)(v.y)); }$/;"	f
ImFloor	imgui_internal.h	/^static inline float  ImFloor(float f)                                           { return (float)(int)(f); }$/;"	f
ImFloorSigned	imgui_internal.h	/^static inline float  ImFloorSigned(float f)                                     { return (float)((f >= 0 || (int)f == f) ? (int)f : (int)f - 1); } \/\/ Decent replacement for floorf()$/;"	f
ImFmod	imgui_internal.h	/^#define ImFmod(/;"	d
ImFont	imgui.h	/^struct ImFont$/;"	s
ImFont	imgui_draw.cpp	/^ImFont::ImFont()$/;"	f	class:ImFont
ImFontAtlas	imgui.h	/^struct ImFontAtlas$/;"	s
ImFontAtlas	imgui_draw.cpp	/^ImFontAtlas::ImFontAtlas()$/;"	f	class:ImFontAtlas
ImFontAtlasBuildFinish	imgui_draw.cpp	/^void ImFontAtlasBuildFinish(ImFontAtlas* atlas)$/;"	f
ImFontAtlasBuildInit	imgui_draw.cpp	/^void ImFontAtlasBuildInit(ImFontAtlas* atlas)$/;"	f
ImFontAtlasBuildMultiplyCalcLookupTable	imgui_draw.cpp	/^void    ImFontAtlasBuildMultiplyCalcLookupTable(unsigned char out_table[256], float in_brighten_factor)$/;"	f
ImFontAtlasBuildMultiplyRectAlpha8	imgui_draw.cpp	/^void    ImFontAtlasBuildMultiplyRectAlpha8(const unsigned char table[256], unsigned char* pixels, int x, int y, int w, int h, int stride)$/;"	f
ImFontAtlasBuildPackCustomRects	imgui_draw.cpp	/^void ImFontAtlasBuildPackCustomRects(ImFontAtlas* atlas, void* stbrp_context_opaque)$/;"	f
ImFontAtlasBuildRender32bppRectFromString	imgui_draw.cpp	/^void ImFontAtlasBuildRender32bppRectFromString(ImFontAtlas* atlas, int x, int y, int w, int h, const char* in_str, char in_marker_char, unsigned int in_marker_pixel_value)$/;"	f
ImFontAtlasBuildRender8bppRectFromString	imgui_draw.cpp	/^void ImFontAtlasBuildRender8bppRectFromString(ImFontAtlas* atlas, int x, int y, int w, int h, const char* in_str, char in_marker_char, unsigned char in_marker_pixel_value)$/;"	f
ImFontAtlasBuildRenderDefaultTexData	imgui_draw.cpp	/^static void ImFontAtlasBuildRenderDefaultTexData(ImFontAtlas* atlas)$/;"	f	file:
ImFontAtlasBuildRenderLinesTexData	imgui_draw.cpp	/^static void ImFontAtlasBuildRenderLinesTexData(ImFontAtlas* atlas)$/;"	f	file:
ImFontAtlasBuildSetupFont	imgui_draw.cpp	/^void ImFontAtlasBuildSetupFont(ImFontAtlas* atlas, ImFont* font, ImFontConfig* font_config, float ascent, float descent)$/;"	f
ImFontAtlasBuildWithStbTruetype	imgui_draw.cpp	/^static bool ImFontAtlasBuildWithStbTruetype(ImFontAtlas* atlas)$/;"	f	file:
ImFontAtlasCustomRect	imgui.h	/^    ImFontAtlasCustomRect()         { Width = Height = 0; X = Y = 0xFFFF; GlyphID = 0; GlyphAdvanceX = 0.0f; GlyphOffset = ImVec2(0, 0); Font = NULL; }$/;"	f	struct:ImFontAtlasCustomRect
ImFontAtlasCustomRect	imgui.h	/^struct ImFontAtlasCustomRect$/;"	s
ImFontAtlasFlags	imgui.h	/^typedef int ImFontAtlasFlags;       \/\/ -> enum ImFontAtlasFlags_     \/\/ Flags: for ImFontAtlas build$/;"	t
ImFontAtlasFlags_	imgui.h	/^enum ImFontAtlasFlags_$/;"	g
ImFontAtlasFlags_NoBakedLines	imgui.h	/^    ImFontAtlasFlags_NoBakedLines       = 1 << 2    \/\/ Don't build thick line textures into the atlas (save a little texture memory). The AntiAliasedLinesUseTex features uses them, otherwise they will be rendered using polygons (more expensive for CPU\/GPU).$/;"	e	enum:ImFontAtlasFlags_
ImFontAtlasFlags_NoMouseCursors	imgui.h	/^    ImFontAtlasFlags_NoMouseCursors     = 1 << 1,   \/\/ Don't build software mouse cursors into the atlas (save a little texture memory)$/;"	e	enum:ImFontAtlasFlags_
ImFontAtlasFlags_NoPowerOfTwoHeight	imgui.h	/^    ImFontAtlasFlags_NoPowerOfTwoHeight = 1 << 0,   \/\/ Don't round the height to next power of two$/;"	e	enum:ImFontAtlasFlags_
ImFontAtlasFlags_None	imgui.h	/^    ImFontAtlasFlags_None               = 0,$/;"	e	enum:ImFontAtlasFlags_
ImFontAtlasGetBuilderForStbTruetype	imgui_draw.cpp	/^const ImFontBuilderIO* ImFontAtlasGetBuilderForStbTruetype()$/;"	f
ImFontBuildDstData	imgui_draw.cpp	/^struct ImFontBuildDstData$/;"	s	file:
ImFontBuildSrcData	imgui_draw.cpp	/^struct ImFontBuildSrcData$/;"	s	file:
ImFontBuilderIO	imgui_internal.h	/^struct ImFontBuilderIO$/;"	s
ImFontConfig	imgui.h	/^struct ImFontConfig$/;"	s
ImFontConfig	imgui_draw.cpp	/^ImFontConfig::ImFontConfig()$/;"	f	class:ImFontConfig
ImFontGlyph	imgui.h	/^struct ImFontGlyph$/;"	s
ImFontGlyphRangesBuilder	imgui.h	/^    ImFontGlyphRangesBuilder()              { Clear(); }$/;"	f	struct:ImFontGlyphRangesBuilder
ImFontGlyphRangesBuilder	imgui.h	/^struct ImFontGlyphRangesBuilder$/;"	s
ImFormatString	imgui.cpp	/^int ImFormatString(char* buf, size_t buf_size, const char* fmt, ...)$/;"	f
ImFormatStringV	imgui.cpp	/^int ImFormatStringV(char* buf, size_t buf_size, const char* fmt, va_list args)$/;"	f
ImGetDirQuadrantFromDelta	imgui.cpp	/^ImGuiDir ImGetDirQuadrantFromDelta(float dx, float dy)$/;"	f
ImGui	imgui.cpp	/^namespace ImGui$/;"	n	file:
ImGui	imgui.h	/^namespace ImGui$/;"	n
ImGui	imgui_internal.h	/^namespace ImGui$/;"	n
ImGui	imgui_widgets.cpp	/^namespace ImGui$/;"	n	file:
ImGuiAxis	imgui_internal.h	/^enum ImGuiAxis$/;"	g
ImGuiAxis_None	imgui_internal.h	/^    ImGuiAxis_None = -1,$/;"	e	enum:ImGuiAxis
ImGuiAxis_X	imgui_internal.h	/^    ImGuiAxis_X = 0,$/;"	e	enum:ImGuiAxis
ImGuiAxis_Y	imgui_internal.h	/^    ImGuiAxis_Y = 1$/;"	e	enum:ImGuiAxis
ImGuiBackendFlags	imgui.h	/^typedef int ImGuiBackendFlags;      \/\/ -> enum ImGuiBackendFlags_    \/\/ Flags: for io.BackendFlags$/;"	t
ImGuiBackendFlags_	imgui.h	/^enum ImGuiBackendFlags_$/;"	g
ImGuiBackendFlags_HasGamepad	imgui.h	/^    ImGuiBackendFlags_HasGamepad            = 1 << 0,   \/\/ Backend Platform supports gamepad and currently has one connected.$/;"	e	enum:ImGuiBackendFlags_
ImGuiBackendFlags_HasMouseCursors	imgui.h	/^    ImGuiBackendFlags_HasMouseCursors       = 1 << 1,   \/\/ Backend Platform supports honoring GetMouseCursor() value to change the OS cursor shape.$/;"	e	enum:ImGuiBackendFlags_
ImGuiBackendFlags_HasSetMousePos	imgui.h	/^    ImGuiBackendFlags_HasSetMousePos        = 1 << 2,   \/\/ Backend Platform supports io.WantSetMousePos requests to reposition the OS mouse position (only used if ImGuiConfigFlags_NavEnableSetMousePos is set).$/;"	e	enum:ImGuiBackendFlags_
ImGuiBackendFlags_None	imgui.h	/^    ImGuiBackendFlags_None                  = 0,$/;"	e	enum:ImGuiBackendFlags_
ImGuiBackendFlags_RendererHasVtxOffset	imgui.h	/^    ImGuiBackendFlags_RendererHasVtxOffset  = 1 << 3    \/\/ Backend Renderer supports ImDrawCmd::VtxOffset. This enables output of large meshes (64K+ vertices) while still using 16-bit indices.$/;"	e	enum:ImGuiBackendFlags_
ImGuiButtonFlags	imgui.h	/^typedef int ImGuiButtonFlags;       \/\/ -> enum ImGuiButtonFlags_     \/\/ Flags: for InvisibleButton()$/;"	t
ImGuiButtonFlagsPrivate_	imgui_internal.h	/^enum ImGuiButtonFlagsPrivate_$/;"	g
ImGuiButtonFlags_	imgui.h	/^enum ImGuiButtonFlags_$/;"	g
ImGuiButtonFlags_AlignTextBaseLine	imgui_internal.h	/^    ImGuiButtonFlags_AlignTextBaseLine      = 1 << 15,  \/\/ vertically align button to match text baseline - ButtonEx() only \/\/ FIXME: Should be removed and handled by SmallButton(), not possible currently because of DC.CursorPosPrevLine$/;"	e	enum:ImGuiButtonFlagsPrivate_
ImGuiButtonFlags_AllowItemOverlap	imgui_internal.h	/^    ImGuiButtonFlags_AllowItemOverlap       = 1 << 12,  \/\/ require previous frame HoveredId to either match id or be null before being usable, use along with SetItemAllowOverlap()$/;"	e	enum:ImGuiButtonFlagsPrivate_
ImGuiButtonFlags_Disabled	imgui_internal.h	/^    ImGuiButtonFlags_Disabled               = 1 << 14,  \/\/ disable interactions$/;"	e	enum:ImGuiButtonFlagsPrivate_
ImGuiButtonFlags_DontClosePopups	imgui_internal.h	/^    ImGuiButtonFlags_DontClosePopups        = 1 << 13,  \/\/ disable automatically closing parent popup on press \/\/ [UNUSED]$/;"	e	enum:ImGuiButtonFlagsPrivate_
ImGuiButtonFlags_FlattenChildren	imgui_internal.h	/^    ImGuiButtonFlags_FlattenChildren        = 1 << 11,  \/\/ allow interactions even if a child window is overlapping$/;"	e	enum:ImGuiButtonFlagsPrivate_
ImGuiButtonFlags_MouseButtonDefault_	imgui.h	/^    ImGuiButtonFlags_MouseButtonDefault_    = ImGuiButtonFlags_MouseButtonLeft$/;"	e	enum:ImGuiButtonFlags_
ImGuiButtonFlags_MouseButtonLeft	imgui.h	/^    ImGuiButtonFlags_MouseButtonLeft        = 1 << 0,   \/\/ React on left mouse button (default)$/;"	e	enum:ImGuiButtonFlags_
ImGuiButtonFlags_MouseButtonMask_	imgui.h	/^    ImGuiButtonFlags_MouseButtonMask_       = ImGuiButtonFlags_MouseButtonLeft | ImGuiButtonFlags_MouseButtonRight | ImGuiButtonFlags_MouseButtonMiddle,$/;"	e	enum:ImGuiButtonFlags_
ImGuiButtonFlags_MouseButtonMiddle	imgui.h	/^    ImGuiButtonFlags_MouseButtonMiddle      = 1 << 2,   \/\/ React on center mouse button$/;"	e	enum:ImGuiButtonFlags_
ImGuiButtonFlags_MouseButtonRight	imgui.h	/^    ImGuiButtonFlags_MouseButtonRight       = 1 << 1,   \/\/ React on right mouse button$/;"	e	enum:ImGuiButtonFlags_
ImGuiButtonFlags_NoHoldingActiveId	imgui_internal.h	/^    ImGuiButtonFlags_NoHoldingActiveId      = 1 << 17,  \/\/ don't set ActiveId while holding the mouse (ImGuiButtonFlags_PressedOnClick only)$/;"	e	enum:ImGuiButtonFlagsPrivate_
ImGuiButtonFlags_NoHoveredOnFocus	imgui_internal.h	/^    ImGuiButtonFlags_NoHoveredOnFocus       = 1 << 19,  \/\/ don't report as hovered when nav focus is on this item$/;"	e	enum:ImGuiButtonFlagsPrivate_
ImGuiButtonFlags_NoKeyModifiers	imgui_internal.h	/^    ImGuiButtonFlags_NoKeyModifiers         = 1 << 16,  \/\/ disable mouse interaction if a key modifier is held$/;"	e	enum:ImGuiButtonFlagsPrivate_
ImGuiButtonFlags_NoNavFocus	imgui_internal.h	/^    ImGuiButtonFlags_NoNavFocus             = 1 << 18,  \/\/ don't override navigation focus when activated$/;"	e	enum:ImGuiButtonFlagsPrivate_
ImGuiButtonFlags_None	imgui.h	/^    ImGuiButtonFlags_None                   = 0,$/;"	e	enum:ImGuiButtonFlags_
ImGuiButtonFlags_PressedOnClick	imgui_internal.h	/^    ImGuiButtonFlags_PressedOnClick         = 1 << 4,   \/\/ return true on click (mouse down event)$/;"	e	enum:ImGuiButtonFlagsPrivate_
ImGuiButtonFlags_PressedOnClickRelease	imgui_internal.h	/^    ImGuiButtonFlags_PressedOnClickRelease  = 1 << 5,   \/\/ [Default] return true on click + release on same item <-- this is what the majority of Button are using$/;"	e	enum:ImGuiButtonFlagsPrivate_
ImGuiButtonFlags_PressedOnClickReleaseAnywhere	imgui_internal.h	/^    ImGuiButtonFlags_PressedOnClickReleaseAnywhere = 1 << 6, \/\/ return true on click + release even if the release event is not done while hovering the item$/;"	e	enum:ImGuiButtonFlagsPrivate_
ImGuiButtonFlags_PressedOnDefault_	imgui_internal.h	/^    ImGuiButtonFlags_PressedOnDefault_      = ImGuiButtonFlags_PressedOnClickRelease$/;"	e	enum:ImGuiButtonFlagsPrivate_
ImGuiButtonFlags_PressedOnDoubleClick	imgui_internal.h	/^    ImGuiButtonFlags_PressedOnDoubleClick   = 1 << 8,   \/\/ return true on double-click (default requires click+release)$/;"	e	enum:ImGuiButtonFlagsPrivate_
ImGuiButtonFlags_PressedOnDragDropHold	imgui_internal.h	/^    ImGuiButtonFlags_PressedOnDragDropHold  = 1 << 9,   \/\/ return true when held into while we are drag and dropping another item (used by e.g. tree nodes, collapsing headers)$/;"	e	enum:ImGuiButtonFlagsPrivate_
ImGuiButtonFlags_PressedOnMask_	imgui_internal.h	/^    ImGuiButtonFlags_PressedOnMask_         = ImGuiButtonFlags_PressedOnClick | ImGuiButtonFlags_PressedOnClickRelease | ImGuiButtonFlags_PressedOnClickReleaseAnywhere | ImGuiButtonFlags_PressedOnRelease | ImGuiButtonFlags_PressedOnDoubleClick | ImGuiButtonFlags_PressedOnDragDropHold,$/;"	e	enum:ImGuiButtonFlagsPrivate_
ImGuiButtonFlags_PressedOnRelease	imgui_internal.h	/^    ImGuiButtonFlags_PressedOnRelease       = 1 << 7,   \/\/ return true on release (default requires click+release)$/;"	e	enum:ImGuiButtonFlagsPrivate_
ImGuiButtonFlags_Repeat	imgui_internal.h	/^    ImGuiButtonFlags_Repeat                 = 1 << 10,  \/\/ hold to repeat$/;"	e	enum:ImGuiButtonFlagsPrivate_
ImGuiCol	imgui.h	/^typedef int ImGuiCol;               \/\/ -> enum ImGuiCol_             \/\/ Enum: A color identifier for styling$/;"	t
ImGuiCol_	imgui.h	/^enum ImGuiCol_$/;"	g
ImGuiCol_Border	imgui.h	/^    ImGuiCol_Border,$/;"	e	enum:ImGuiCol_
ImGuiCol_BorderShadow	imgui.h	/^    ImGuiCol_BorderShadow,$/;"	e	enum:ImGuiCol_
ImGuiCol_Button	imgui.h	/^    ImGuiCol_Button,$/;"	e	enum:ImGuiCol_
ImGuiCol_ButtonActive	imgui.h	/^    ImGuiCol_ButtonActive,$/;"	e	enum:ImGuiCol_
ImGuiCol_ButtonHovered	imgui.h	/^    ImGuiCol_ButtonHovered,$/;"	e	enum:ImGuiCol_
ImGuiCol_COUNT	imgui.h	/^    ImGuiCol_COUNT$/;"	e	enum:ImGuiCol_
ImGuiCol_CheckMark	imgui.h	/^    ImGuiCol_CheckMark,$/;"	e	enum:ImGuiCol_
ImGuiCol_ChildBg	imgui.h	/^    ImGuiCol_ChildBg,               \/\/ Background of child windows$/;"	e	enum:ImGuiCol_
ImGuiCol_DragDropTarget	imgui.h	/^    ImGuiCol_DragDropTarget,$/;"	e	enum:ImGuiCol_
ImGuiCol_FrameBg	imgui.h	/^    ImGuiCol_FrameBg,               \/\/ Background of checkbox, radio button, plot, slider, text input$/;"	e	enum:ImGuiCol_
ImGuiCol_FrameBgActive	imgui.h	/^    ImGuiCol_FrameBgActive,$/;"	e	enum:ImGuiCol_
ImGuiCol_FrameBgHovered	imgui.h	/^    ImGuiCol_FrameBgHovered,$/;"	e	enum:ImGuiCol_
ImGuiCol_Header	imgui.h	/^    ImGuiCol_Header,                \/\/ Header* colors are used for CollapsingHeader, TreeNode, Selectable, MenuItem$/;"	e	enum:ImGuiCol_
ImGuiCol_HeaderActive	imgui.h	/^    ImGuiCol_HeaderActive,$/;"	e	enum:ImGuiCol_
ImGuiCol_HeaderHovered	imgui.h	/^    ImGuiCol_HeaderHovered,$/;"	e	enum:ImGuiCol_
ImGuiCol_MenuBarBg	imgui.h	/^    ImGuiCol_MenuBarBg,$/;"	e	enum:ImGuiCol_
ImGuiCol_ModalWindowDimBg	imgui.h	/^    ImGuiCol_ModalWindowDimBg,      \/\/ Darken\/colorize entire screen behind a modal window, when one is active$/;"	e	enum:ImGuiCol_
ImGuiCol_NavHighlight	imgui.h	/^    ImGuiCol_NavHighlight,          \/\/ Gamepad\/keyboard: current highlighted item$/;"	e	enum:ImGuiCol_
ImGuiCol_NavWindowingDimBg	imgui.h	/^    ImGuiCol_NavWindowingDimBg,     \/\/ Darken\/colorize entire screen behind the CTRL+TAB window list, when active$/;"	e	enum:ImGuiCol_
ImGuiCol_NavWindowingHighlight	imgui.h	/^    ImGuiCol_NavWindowingHighlight, \/\/ Highlight window when using CTRL+TAB$/;"	e	enum:ImGuiCol_
ImGuiCol_PlotHistogram	imgui.h	/^    ImGuiCol_PlotHistogram,$/;"	e	enum:ImGuiCol_
ImGuiCol_PlotHistogramHovered	imgui.h	/^    ImGuiCol_PlotHistogramHovered,$/;"	e	enum:ImGuiCol_
ImGuiCol_PlotLines	imgui.h	/^    ImGuiCol_PlotLines,$/;"	e	enum:ImGuiCol_
ImGuiCol_PlotLinesHovered	imgui.h	/^    ImGuiCol_PlotLinesHovered,$/;"	e	enum:ImGuiCol_
ImGuiCol_PopupBg	imgui.h	/^    ImGuiCol_PopupBg,               \/\/ Background of popups, menus, tooltips windows$/;"	e	enum:ImGuiCol_
ImGuiCol_ResizeGrip	imgui.h	/^    ImGuiCol_ResizeGrip,$/;"	e	enum:ImGuiCol_
ImGuiCol_ResizeGripActive	imgui.h	/^    ImGuiCol_ResizeGripActive,$/;"	e	enum:ImGuiCol_
ImGuiCol_ResizeGripHovered	imgui.h	/^    ImGuiCol_ResizeGripHovered,$/;"	e	enum:ImGuiCol_
ImGuiCol_ScrollbarBg	imgui.h	/^    ImGuiCol_ScrollbarBg,$/;"	e	enum:ImGuiCol_
ImGuiCol_ScrollbarGrab	imgui.h	/^    ImGuiCol_ScrollbarGrab,$/;"	e	enum:ImGuiCol_
ImGuiCol_ScrollbarGrabActive	imgui.h	/^    ImGuiCol_ScrollbarGrabActive,$/;"	e	enum:ImGuiCol_
ImGuiCol_ScrollbarGrabHovered	imgui.h	/^    ImGuiCol_ScrollbarGrabHovered,$/;"	e	enum:ImGuiCol_
ImGuiCol_Separator	imgui.h	/^    ImGuiCol_Separator,$/;"	e	enum:ImGuiCol_
ImGuiCol_SeparatorActive	imgui.h	/^    ImGuiCol_SeparatorActive,$/;"	e	enum:ImGuiCol_
ImGuiCol_SeparatorHovered	imgui.h	/^    ImGuiCol_SeparatorHovered,$/;"	e	enum:ImGuiCol_
ImGuiCol_SliderGrab	imgui.h	/^    ImGuiCol_SliderGrab,$/;"	e	enum:ImGuiCol_
ImGuiCol_SliderGrabActive	imgui.h	/^    ImGuiCol_SliderGrabActive,$/;"	e	enum:ImGuiCol_
ImGuiCol_Tab	imgui.h	/^    ImGuiCol_Tab,$/;"	e	enum:ImGuiCol_
ImGuiCol_TabActive	imgui.h	/^    ImGuiCol_TabActive,$/;"	e	enum:ImGuiCol_
ImGuiCol_TabHovered	imgui.h	/^    ImGuiCol_TabHovered,$/;"	e	enum:ImGuiCol_
ImGuiCol_TabUnfocused	imgui.h	/^    ImGuiCol_TabUnfocused,$/;"	e	enum:ImGuiCol_
ImGuiCol_TabUnfocusedActive	imgui.h	/^    ImGuiCol_TabUnfocusedActive,$/;"	e	enum:ImGuiCol_
ImGuiCol_TableBorderLight	imgui.h	/^    ImGuiCol_TableBorderLight,      \/\/ Table inner borders (prefer using Alpha=1.0 here)$/;"	e	enum:ImGuiCol_
ImGuiCol_TableBorderStrong	imgui.h	/^    ImGuiCol_TableBorderStrong,     \/\/ Table outer and header borders (prefer using Alpha=1.0 here)$/;"	e	enum:ImGuiCol_
ImGuiCol_TableHeaderBg	imgui.h	/^    ImGuiCol_TableHeaderBg,         \/\/ Table header background$/;"	e	enum:ImGuiCol_
ImGuiCol_TableRowBg	imgui.h	/^    ImGuiCol_TableRowBg,            \/\/ Table row background (even rows)$/;"	e	enum:ImGuiCol_
ImGuiCol_TableRowBgAlt	imgui.h	/^    ImGuiCol_TableRowBgAlt,         \/\/ Table row background (odd rows)$/;"	e	enum:ImGuiCol_
ImGuiCol_Text	imgui.h	/^    ImGuiCol_Text,$/;"	e	enum:ImGuiCol_
ImGuiCol_TextDisabled	imgui.h	/^    ImGuiCol_TextDisabled,$/;"	e	enum:ImGuiCol_
ImGuiCol_TextSelectedBg	imgui.h	/^    ImGuiCol_TextSelectedBg,$/;"	e	enum:ImGuiCol_
ImGuiCol_TitleBg	imgui.h	/^    ImGuiCol_TitleBg,$/;"	e	enum:ImGuiCol_
ImGuiCol_TitleBgActive	imgui.h	/^    ImGuiCol_TitleBgActive,$/;"	e	enum:ImGuiCol_
ImGuiCol_TitleBgCollapsed	imgui.h	/^    ImGuiCol_TitleBgCollapsed,$/;"	e	enum:ImGuiCol_
ImGuiCol_WindowBg	imgui.h	/^    ImGuiCol_WindowBg,              \/\/ Background of normal windows$/;"	e	enum:ImGuiCol_
ImGuiColorEditFlags	imgui.h	/^typedef int ImGuiColorEditFlags;    \/\/ -> enum ImGuiColorEditFlags_  \/\/ Flags: for ColorEdit4(), ColorPicker4() etc.$/;"	t
ImGuiColorEditFlags_	imgui.h	/^enum ImGuiColorEditFlags_$/;"	g
ImGuiColorEditFlags_AlphaBar	imgui.h	/^    ImGuiColorEditFlags_AlphaBar        = 1 << 16,  \/\/              \/\/ ColorEdit, ColorPicker: show vertical alpha bar\/gradient in picker.$/;"	e	enum:ImGuiColorEditFlags_
ImGuiColorEditFlags_AlphaPreview	imgui.h	/^    ImGuiColorEditFlags_AlphaPreview    = 1 << 17,  \/\/              \/\/ ColorEdit, ColorPicker, ColorButton: display preview as a transparent color over a checkerboard, instead of opaque.$/;"	e	enum:ImGuiColorEditFlags_
ImGuiColorEditFlags_AlphaPreviewHalf	imgui.h	/^    ImGuiColorEditFlags_AlphaPreviewHalf= 1 << 18,  \/\/              \/\/ ColorEdit, ColorPicker, ColorButton: display half opaque \/ half checkerboard, instead of opaque.$/;"	e	enum:ImGuiColorEditFlags_
ImGuiColorEditFlags_DisplayHSV	imgui.h	/^    ImGuiColorEditFlags_DisplayHSV      = 1 << 21,  \/\/ [Display]    \/\/ "$/;"	e	enum:ImGuiColorEditFlags_
ImGuiColorEditFlags_DisplayHex	imgui.h	/^    ImGuiColorEditFlags_DisplayHex      = 1 << 22,  \/\/ [Display]    \/\/ "$/;"	e	enum:ImGuiColorEditFlags_
ImGuiColorEditFlags_DisplayRGB	imgui.h	/^    ImGuiColorEditFlags_DisplayRGB      = 1 << 20,  \/\/ [Display]    \/\/ ColorEdit: override _display_ type among RGB\/HSV\/Hex. ColorPicker: select any combination using one or more of RGB\/HSV\/Hex.$/;"	e	enum:ImGuiColorEditFlags_
ImGuiColorEditFlags_Float	imgui.h	/^    ImGuiColorEditFlags_Float           = 1 << 24,  \/\/ [DataType]   \/\/ ColorEdit, ColorPicker, ColorButton: _display_ values formatted as 0.0f..1.0f floats instead of 0..255 integers. No round-trip of value via integers.$/;"	e	enum:ImGuiColorEditFlags_
ImGuiColorEditFlags_HDR	imgui.h	/^    ImGuiColorEditFlags_HDR             = 1 << 19,  \/\/              \/\/ (WIP) ColorEdit: Currently only disable 0.0f..1.0f limits in RGBA edition (note: you probably want to use ImGuiColorEditFlags_Float flag as well).$/;"	e	enum:ImGuiColorEditFlags_
ImGuiColorEditFlags_HEX	imgui.h	/^    , ImGuiColorEditFlags_RGB = ImGuiColorEditFlags_DisplayRGB, ImGuiColorEditFlags_HSV = ImGuiColorEditFlags_DisplayHSV, ImGuiColorEditFlags_HEX = ImGuiColorEditFlags_DisplayHex  \/\/ [renamed in 1.69]$/;"	e	enum:ImGuiColorEditFlags_
ImGuiColorEditFlags_HSV	imgui.h	/^    , ImGuiColorEditFlags_RGB = ImGuiColorEditFlags_DisplayRGB, ImGuiColorEditFlags_HSV = ImGuiColorEditFlags_DisplayHSV, ImGuiColorEditFlags_HEX = ImGuiColorEditFlags_DisplayHex  \/\/ [renamed in 1.69]$/;"	e	enum:ImGuiColorEditFlags_
ImGuiColorEditFlags_InputHSV	imgui.h	/^    ImGuiColorEditFlags_InputHSV        = 1 << 28,  \/\/ [Input]      \/\/ ColorEdit, ColorPicker: input and output data in HSV format.$/;"	e	enum:ImGuiColorEditFlags_
ImGuiColorEditFlags_InputRGB	imgui.h	/^    ImGuiColorEditFlags_InputRGB        = 1 << 27,  \/\/ [Input]      \/\/ ColorEdit, ColorPicker: input and output data in RGB format.$/;"	e	enum:ImGuiColorEditFlags_
ImGuiColorEditFlags_NoAlpha	imgui.h	/^    ImGuiColorEditFlags_NoAlpha         = 1 << 1,   \/\/              \/\/ ColorEdit, ColorPicker, ColorButton: ignore Alpha component (will only read 3 components from the input pointer).$/;"	e	enum:ImGuiColorEditFlags_
ImGuiColorEditFlags_NoBorder	imgui.h	/^    ImGuiColorEditFlags_NoBorder        = 1 << 10,  \/\/              \/\/ ColorButton: disable border (which is enforced by default)$/;"	e	enum:ImGuiColorEditFlags_
ImGuiColorEditFlags_NoDragDrop	imgui.h	/^    ImGuiColorEditFlags_NoDragDrop      = 1 << 9,   \/\/              \/\/ ColorEdit: disable drag and drop target. ColorButton: disable drag and drop source.$/;"	e	enum:ImGuiColorEditFlags_
ImGuiColorEditFlags_NoInputs	imgui.h	/^    ImGuiColorEditFlags_NoInputs        = 1 << 5,   \/\/              \/\/ ColorEdit, ColorPicker: disable inputs sliders\/text widgets (e.g. to show only the small preview color square).$/;"	e	enum:ImGuiColorEditFlags_
ImGuiColorEditFlags_NoLabel	imgui.h	/^    ImGuiColorEditFlags_NoLabel         = 1 << 7,   \/\/              \/\/ ColorEdit, ColorPicker: disable display of inline text label (the label is still forwarded to the tooltip and picker).$/;"	e	enum:ImGuiColorEditFlags_
ImGuiColorEditFlags_NoOptions	imgui.h	/^    ImGuiColorEditFlags_NoOptions       = 1 << 3,   \/\/              \/\/ ColorEdit: disable toggling options menu when right-clicking on inputs\/small preview.$/;"	e	enum:ImGuiColorEditFlags_
ImGuiColorEditFlags_NoPicker	imgui.h	/^    ImGuiColorEditFlags_NoPicker        = 1 << 2,   \/\/              \/\/ ColorEdit: disable picker when clicking on color square.$/;"	e	enum:ImGuiColorEditFlags_
ImGuiColorEditFlags_NoSidePreview	imgui.h	/^    ImGuiColorEditFlags_NoSidePreview   = 1 << 8,   \/\/              \/\/ ColorPicker: disable bigger color preview on right side of the picker, use small color square preview instead.$/;"	e	enum:ImGuiColorEditFlags_
ImGuiColorEditFlags_NoSmallPreview	imgui.h	/^    ImGuiColorEditFlags_NoSmallPreview  = 1 << 4,   \/\/              \/\/ ColorEdit, ColorPicker: disable color square preview next to the inputs. (e.g. to show only the inputs)$/;"	e	enum:ImGuiColorEditFlags_
ImGuiColorEditFlags_NoTooltip	imgui.h	/^    ImGuiColorEditFlags_NoTooltip       = 1 << 6,   \/\/              \/\/ ColorEdit, ColorPicker, ColorButton: disable tooltip when hovering the preview.$/;"	e	enum:ImGuiColorEditFlags_
ImGuiColorEditFlags_None	imgui.h	/^    ImGuiColorEditFlags_None            = 0,$/;"	e	enum:ImGuiColorEditFlags_
ImGuiColorEditFlags_PickerHueBar	imgui.h	/^    ImGuiColorEditFlags_PickerHueBar    = 1 << 25,  \/\/ [Picker]     \/\/ ColorPicker: bar for Hue, rectangle for Sat\/Value.$/;"	e	enum:ImGuiColorEditFlags_
ImGuiColorEditFlags_PickerHueWheel	imgui.h	/^    ImGuiColorEditFlags_PickerHueWheel  = 1 << 26,  \/\/ [Picker]     \/\/ ColorPicker: wheel for Hue, triangle for Sat\/Value.$/;"	e	enum:ImGuiColorEditFlags_
ImGuiColorEditFlags_RGB	imgui.h	/^    , ImGuiColorEditFlags_RGB = ImGuiColorEditFlags_DisplayRGB, ImGuiColorEditFlags_HSV = ImGuiColorEditFlags_DisplayHSV, ImGuiColorEditFlags_HEX = ImGuiColorEditFlags_DisplayHex  \/\/ [renamed in 1.69]$/;"	e	enum:ImGuiColorEditFlags_
ImGuiColorEditFlags_Uint8	imgui.h	/^    ImGuiColorEditFlags_Uint8           = 1 << 23,  \/\/ [DataType]   \/\/ ColorEdit, ColorPicker, ColorButton: _display_ values formatted as 0..255.$/;"	e	enum:ImGuiColorEditFlags_
ImGuiColorEditFlags__DataTypeMask	imgui.h	/^    ImGuiColorEditFlags__DataTypeMask   = ImGuiColorEditFlags_Uint8 | ImGuiColorEditFlags_Float,$/;"	e	enum:ImGuiColorEditFlags_
ImGuiColorEditFlags__DisplayMask	imgui.h	/^    ImGuiColorEditFlags__DisplayMask    = ImGuiColorEditFlags_DisplayRGB | ImGuiColorEditFlags_DisplayHSV | ImGuiColorEditFlags_DisplayHex,$/;"	e	enum:ImGuiColorEditFlags_
ImGuiColorEditFlags__InputMask	imgui.h	/^    ImGuiColorEditFlags__InputMask      = ImGuiColorEditFlags_InputRGB | ImGuiColorEditFlags_InputHSV$/;"	e	enum:ImGuiColorEditFlags_
ImGuiColorEditFlags__OptionsDefault	imgui.h	/^    ImGuiColorEditFlags__OptionsDefault = ImGuiColorEditFlags_Uint8 | ImGuiColorEditFlags_DisplayRGB | ImGuiColorEditFlags_InputRGB | ImGuiColorEditFlags_PickerHueBar,$/;"	e	enum:ImGuiColorEditFlags_
ImGuiColorEditFlags__PickerMask	imgui.h	/^    ImGuiColorEditFlags__PickerMask     = ImGuiColorEditFlags_PickerHueWheel | ImGuiColorEditFlags_PickerHueBar,$/;"	e	enum:ImGuiColorEditFlags_
ImGuiColorMod	imgui_internal.h	/^struct ImGuiColorMod$/;"	s
ImGuiColumnsFlags_GrowParentContentsSize	imgui_internal.h	/^    ImGuiColumnsFlags_GrowParentContentsSize    = ImGuiOldColumnFlags_GrowParentContentsSize$/;"	e	enum:ImGuiOldColumnFlags_
ImGuiColumnsFlags_NoBorder	imgui_internal.h	/^    ImGuiColumnsFlags_NoBorder                  = ImGuiOldColumnFlags_NoBorder,$/;"	e	enum:ImGuiOldColumnFlags_
ImGuiColumnsFlags_NoForceWithinWindow	imgui_internal.h	/^    ImGuiColumnsFlags_NoForceWithinWindow       = ImGuiOldColumnFlags_NoForceWithinWindow,$/;"	e	enum:ImGuiOldColumnFlags_
ImGuiColumnsFlags_NoPreserveWidths	imgui_internal.h	/^    ImGuiColumnsFlags_NoPreserveWidths          = ImGuiOldColumnFlags_NoPreserveWidths,$/;"	e	enum:ImGuiOldColumnFlags_
ImGuiColumnsFlags_NoResize	imgui_internal.h	/^    ImGuiColumnsFlags_NoResize                  = ImGuiOldColumnFlags_NoResize,$/;"	e	enum:ImGuiOldColumnFlags_
ImGuiColumnsFlags_None	imgui_internal.h	/^    , ImGuiColumnsFlags_None                    = ImGuiOldColumnFlags_None,$/;"	e	enum:ImGuiOldColumnFlags_
ImGuiComboFlags	imgui.h	/^typedef int ImGuiComboFlags;        \/\/ -> enum ImGuiComboFlags_      \/\/ Flags: for BeginCombo()$/;"	t
ImGuiComboFlags_	imgui.h	/^enum ImGuiComboFlags_$/;"	g
ImGuiComboFlags_HeightLarge	imgui.h	/^    ImGuiComboFlags_HeightLarge             = 1 << 3,   \/\/ Max ~20 items visible$/;"	e	enum:ImGuiComboFlags_
ImGuiComboFlags_HeightLargest	imgui.h	/^    ImGuiComboFlags_HeightLargest           = 1 << 4,   \/\/ As many fitting items as possible$/;"	e	enum:ImGuiComboFlags_
ImGuiComboFlags_HeightMask_	imgui.h	/^    ImGuiComboFlags_HeightMask_             = ImGuiComboFlags_HeightSmall | ImGuiComboFlags_HeightRegular | ImGuiComboFlags_HeightLarge | ImGuiComboFlags_HeightLargest$/;"	e	enum:ImGuiComboFlags_
ImGuiComboFlags_HeightRegular	imgui.h	/^    ImGuiComboFlags_HeightRegular           = 1 << 2,   \/\/ Max ~8 items visible (default)$/;"	e	enum:ImGuiComboFlags_
ImGuiComboFlags_HeightSmall	imgui.h	/^    ImGuiComboFlags_HeightSmall             = 1 << 1,   \/\/ Max ~4 items visible. Tip: If you want your combo popup to be a specific size you can use SetNextWindowSizeConstraints() prior to calling BeginCombo()$/;"	e	enum:ImGuiComboFlags_
ImGuiComboFlags_NoArrowButton	imgui.h	/^    ImGuiComboFlags_NoArrowButton           = 1 << 5,   \/\/ Display on the preview box without the square arrow button$/;"	e	enum:ImGuiComboFlags_
ImGuiComboFlags_NoPreview	imgui.h	/^    ImGuiComboFlags_NoPreview               = 1 << 6,   \/\/ Display only a square arrow button$/;"	e	enum:ImGuiComboFlags_
ImGuiComboFlags_None	imgui.h	/^    ImGuiComboFlags_None                    = 0,$/;"	e	enum:ImGuiComboFlags_
ImGuiComboFlags_PopupAlignLeft	imgui.h	/^    ImGuiComboFlags_PopupAlignLeft          = 1 << 0,   \/\/ Align the popup toward the left by default$/;"	e	enum:ImGuiComboFlags_
ImGuiCond	imgui.h	/^typedef int ImGuiCond;              \/\/ -> enum ImGuiCond_            \/\/ Enum: A condition for many Set*() functions$/;"	t
ImGuiCond_	imgui.h	/^enum ImGuiCond_$/;"	g
ImGuiCond_Always	imgui.h	/^    ImGuiCond_Always        = 1 << 0,   \/\/ No condition (always set the variable)$/;"	e	enum:ImGuiCond_
ImGuiCond_Appearing	imgui.h	/^    ImGuiCond_Appearing     = 1 << 3    \/\/ Set the variable if the object\/window is appearing after being hidden\/inactive (or the first time)$/;"	e	enum:ImGuiCond_
ImGuiCond_FirstUseEver	imgui.h	/^    ImGuiCond_FirstUseEver  = 1 << 2,   \/\/ Set the variable if the object\/window has no persistently saved data (no entry in .ini file)$/;"	e	enum:ImGuiCond_
ImGuiCond_None	imgui.h	/^    ImGuiCond_None          = 0,        \/\/ No condition (always set the variable), same as _Always$/;"	e	enum:ImGuiCond_
ImGuiCond_Once	imgui.h	/^    ImGuiCond_Once          = 1 << 1,   \/\/ Set the variable once per runtime session (only the first call will succeed)$/;"	e	enum:ImGuiCond_
ImGuiConfigFlags	imgui.h	/^typedef int ImGuiConfigFlags;       \/\/ -> enum ImGuiConfigFlags_     \/\/ Flags: for io.ConfigFlags$/;"	t
ImGuiConfigFlags_	imgui.h	/^enum ImGuiConfigFlags_$/;"	g
ImGuiConfigFlags_IsSRGB	imgui.h	/^    ImGuiConfigFlags_IsSRGB                 = 1 << 20,  \/\/ Application is SRGB-aware.$/;"	e	enum:ImGuiConfigFlags_
ImGuiConfigFlags_IsTouchScreen	imgui.h	/^    ImGuiConfigFlags_IsTouchScreen          = 1 << 21   \/\/ Application is using a touch screen instead of a mouse.$/;"	e	enum:ImGuiConfigFlags_
ImGuiConfigFlags_NavEnableGamepad	imgui.h	/^    ImGuiConfigFlags_NavEnableGamepad       = 1 << 1,   \/\/ Master gamepad navigation enable flag. This is mostly to instruct your imgui backend to fill io.NavInputs[]. Backend also needs to set ImGuiBackendFlags_HasGamepad.$/;"	e	enum:ImGuiConfigFlags_
ImGuiConfigFlags_NavEnableKeyboard	imgui.h	/^    ImGuiConfigFlags_NavEnableKeyboard      = 1 << 0,   \/\/ Master keyboard navigation enable flag. NewFrame() will automatically fill io.NavInputs[] based on io.KeysDown[].$/;"	e	enum:ImGuiConfigFlags_
ImGuiConfigFlags_NavEnableSetMousePos	imgui.h	/^    ImGuiConfigFlags_NavEnableSetMousePos   = 1 << 2,   \/\/ Instruct navigation to move the mouse cursor. May be useful on TV\/console systems where moving a virtual mouse is awkward. Will update io.MousePos and set io.WantSetMousePos=true. If enabled you MUST honor io.WantSetMousePos requests in your backend, otherwise ImGui will react as if the mouse is jumping around back and forth.$/;"	e	enum:ImGuiConfigFlags_
ImGuiConfigFlags_NavNoCaptureKeyboard	imgui.h	/^    ImGuiConfigFlags_NavNoCaptureKeyboard   = 1 << 3,   \/\/ Instruct navigation to not set the io.WantCaptureKeyboard flag when io.NavActive is set.$/;"	e	enum:ImGuiConfigFlags_
ImGuiConfigFlags_NoMouse	imgui.h	/^    ImGuiConfigFlags_NoMouse                = 1 << 4,   \/\/ Instruct imgui to clear mouse position\/buttons in NewFrame(). This allows ignoring the mouse information set by the backend.$/;"	e	enum:ImGuiConfigFlags_
ImGuiConfigFlags_NoMouseCursorChange	imgui.h	/^    ImGuiConfigFlags_NoMouseCursorChange    = 1 << 5,   \/\/ Instruct backend to not alter mouse cursor shape and visibility. Use if the backend cursor changes are interfering with yours and you don't want to use SetMouseCursor() to change mouse cursor. You may want to honor requests from imgui by reading GetMouseCursor() yourself instead.$/;"	e	enum:ImGuiConfigFlags_
ImGuiConfigFlags_None	imgui.h	/^    ImGuiConfigFlags_None                   = 0,$/;"	e	enum:ImGuiConfigFlags_
ImGuiContext	imgui_internal.h	/^    ImGuiContext(ImFontAtlas* shared_font_atlas)$/;"	f	struct:ImGuiContext
ImGuiContext	imgui_internal.h	/^struct ImGuiContext$/;"	s
ImGuiContextHook	imgui_internal.h	/^    ImGuiContextHook()          { memset(this, 0, sizeof(*this)); }$/;"	f	struct:ImGuiContextHook
ImGuiContextHook	imgui_internal.h	/^struct ImGuiContextHook$/;"	s
ImGuiContextHookCallback	imgui_internal.h	/^typedef void (*ImGuiContextHookCallback)(ImGuiContext* ctx, ImGuiContextHook* hook);$/;"	t
ImGuiContextHookType	imgui_internal.h	/^enum ImGuiContextHookType { ImGuiContextHookType_NewFramePre, ImGuiContextHookType_NewFramePost, ImGuiContextHookType_EndFramePre, ImGuiContextHookType_EndFramePost, ImGuiContextHookType_RenderPre, ImGuiContextHookType_RenderPost, ImGuiContextHookType_Shutdown, ImGuiContextHookType_PendingRemoval_ };$/;"	g
ImGuiContextHookType_EndFramePost	imgui_internal.h	/^enum ImGuiContextHookType { ImGuiContextHookType_NewFramePre, ImGuiContextHookType_NewFramePost, ImGuiContextHookType_EndFramePre, ImGuiContextHookType_EndFramePost, ImGuiContextHookType_RenderPre, ImGuiContextHookType_RenderPost, ImGuiContextHookType_Shutdown, ImGuiContextHookType_PendingRemoval_ };$/;"	e	enum:ImGuiContextHookType
ImGuiContextHookType_EndFramePre	imgui_internal.h	/^enum ImGuiContextHookType { ImGuiContextHookType_NewFramePre, ImGuiContextHookType_NewFramePost, ImGuiContextHookType_EndFramePre, ImGuiContextHookType_EndFramePost, ImGuiContextHookType_RenderPre, ImGuiContextHookType_RenderPost, ImGuiContextHookType_Shutdown, ImGuiContextHookType_PendingRemoval_ };$/;"	e	enum:ImGuiContextHookType
ImGuiContextHookType_NewFramePost	imgui_internal.h	/^enum ImGuiContextHookType { ImGuiContextHookType_NewFramePre, ImGuiContextHookType_NewFramePost, ImGuiContextHookType_EndFramePre, ImGuiContextHookType_EndFramePost, ImGuiContextHookType_RenderPre, ImGuiContextHookType_RenderPost, ImGuiContextHookType_Shutdown, ImGuiContextHookType_PendingRemoval_ };$/;"	e	enum:ImGuiContextHookType
ImGuiContextHookType_NewFramePre	imgui_internal.h	/^enum ImGuiContextHookType { ImGuiContextHookType_NewFramePre, ImGuiContextHookType_NewFramePost, ImGuiContextHookType_EndFramePre, ImGuiContextHookType_EndFramePost, ImGuiContextHookType_RenderPre, ImGuiContextHookType_RenderPost, ImGuiContextHookType_Shutdown, ImGuiContextHookType_PendingRemoval_ };$/;"	e	enum:ImGuiContextHookType
ImGuiContextHookType_PendingRemoval_	imgui_internal.h	/^enum ImGuiContextHookType { ImGuiContextHookType_NewFramePre, ImGuiContextHookType_NewFramePost, ImGuiContextHookType_EndFramePre, ImGuiContextHookType_EndFramePost, ImGuiContextHookType_RenderPre, ImGuiContextHookType_RenderPost, ImGuiContextHookType_Shutdown, ImGuiContextHookType_PendingRemoval_ };$/;"	e	enum:ImGuiContextHookType
ImGuiContextHookType_RenderPost	imgui_internal.h	/^enum ImGuiContextHookType { ImGuiContextHookType_NewFramePre, ImGuiContextHookType_NewFramePost, ImGuiContextHookType_EndFramePre, ImGuiContextHookType_EndFramePost, ImGuiContextHookType_RenderPre, ImGuiContextHookType_RenderPost, ImGuiContextHookType_Shutdown, ImGuiContextHookType_PendingRemoval_ };$/;"	e	enum:ImGuiContextHookType
ImGuiContextHookType_RenderPre	imgui_internal.h	/^enum ImGuiContextHookType { ImGuiContextHookType_NewFramePre, ImGuiContextHookType_NewFramePost, ImGuiContextHookType_EndFramePre, ImGuiContextHookType_EndFramePost, ImGuiContextHookType_RenderPre, ImGuiContextHookType_RenderPost, ImGuiContextHookType_Shutdown, ImGuiContextHookType_PendingRemoval_ };$/;"	e	enum:ImGuiContextHookType
ImGuiContextHookType_Shutdown	imgui_internal.h	/^enum ImGuiContextHookType { ImGuiContextHookType_NewFramePre, ImGuiContextHookType_NewFramePost, ImGuiContextHookType_EndFramePre, ImGuiContextHookType_EndFramePost, ImGuiContextHookType_RenderPre, ImGuiContextHookType_RenderPost, ImGuiContextHookType_Shutdown, ImGuiContextHookType_PendingRemoval_ };$/;"	e	enum:ImGuiContextHookType
ImGuiDataType	imgui.h	/^typedef int ImGuiDataType;          \/\/ -> enum ImGuiDataType_        \/\/ Enum: A primary data type$/;"	t
ImGuiDataTypeInfo	imgui_internal.h	/^struct ImGuiDataTypeInfo$/;"	s
ImGuiDataTypePrivate_	imgui_internal.h	/^enum ImGuiDataTypePrivate_$/;"	g
ImGuiDataTypeTempStorage	imgui_internal.h	/^struct ImGuiDataTypeTempStorage$/;"	s
ImGuiDataType_	imgui.h	/^enum ImGuiDataType_$/;"	g
ImGuiDataType_COUNT	imgui.h	/^    ImGuiDataType_COUNT$/;"	e	enum:ImGuiDataType_
ImGuiDataType_COUNT	imgui_widgets.cpp	/^IM_STATIC_ASSERT(IM_ARRAYSIZE(GDataTypeInfo) == ImGuiDataType_COUNT);$/;"	v
ImGuiDataType_Double	imgui.h	/^    ImGuiDataType_Double,   \/\/ double$/;"	e	enum:ImGuiDataType_
ImGuiDataType_Float	imgui.h	/^    ImGuiDataType_Float,    \/\/ float$/;"	e	enum:ImGuiDataType_
ImGuiDataType_ID	imgui_internal.h	/^    ImGuiDataType_ID$/;"	e	enum:ImGuiDataTypePrivate_
ImGuiDataType_Pointer	imgui_internal.h	/^    ImGuiDataType_Pointer,$/;"	e	enum:ImGuiDataTypePrivate_
ImGuiDataType_S16	imgui.h	/^    ImGuiDataType_S16,      \/\/ short$/;"	e	enum:ImGuiDataType_
ImGuiDataType_S32	imgui.h	/^    ImGuiDataType_S32,      \/\/ int$/;"	e	enum:ImGuiDataType_
ImGuiDataType_S64	imgui.h	/^    ImGuiDataType_S64,      \/\/ long long \/ __int64$/;"	e	enum:ImGuiDataType_
ImGuiDataType_S8	imgui.h	/^    ImGuiDataType_S8,       \/\/ signed char \/ char (with sensible compilers)$/;"	e	enum:ImGuiDataType_
ImGuiDataType_String	imgui_internal.h	/^    ImGuiDataType_String = ImGuiDataType_COUNT + 1,$/;"	e	enum:ImGuiDataTypePrivate_
ImGuiDataType_U16	imgui.h	/^    ImGuiDataType_U16,      \/\/ unsigned short$/;"	e	enum:ImGuiDataType_
ImGuiDataType_U32	imgui.h	/^    ImGuiDataType_U32,      \/\/ unsigned int$/;"	e	enum:ImGuiDataType_
ImGuiDataType_U64	imgui.h	/^    ImGuiDataType_U64,      \/\/ unsigned long long \/ unsigned __int64$/;"	e	enum:ImGuiDataType_
ImGuiDataType_U8	imgui.h	/^    ImGuiDataType_U8,       \/\/ unsigned char$/;"	e	enum:ImGuiDataType_
ImGuiDir	imgui.h	/^typedef int ImGuiDir;               \/\/ -> enum ImGuiDir_             \/\/ Enum: A cardinal direction$/;"	t
ImGuiDir_	imgui.h	/^enum ImGuiDir_$/;"	g
ImGuiDir_COUNT	imgui.h	/^    ImGuiDir_COUNT$/;"	e	enum:ImGuiDir_
ImGuiDir_Down	imgui.h	/^    ImGuiDir_Down    = 3,$/;"	e	enum:ImGuiDir_
ImGuiDir_Left	imgui.h	/^    ImGuiDir_Left    = 0,$/;"	e	enum:ImGuiDir_
ImGuiDir_None	imgui.h	/^    ImGuiDir_None    = -1,$/;"	e	enum:ImGuiDir_
ImGuiDir_Right	imgui.h	/^    ImGuiDir_Right   = 1,$/;"	e	enum:ImGuiDir_
ImGuiDir_Up	imgui.h	/^    ImGuiDir_Up      = 2,$/;"	e	enum:ImGuiDir_
ImGuiDragDropFlags	imgui.h	/^typedef int ImGuiDragDropFlags;     \/\/ -> enum ImGuiDragDropFlags_   \/\/ Flags: for BeginDragDropSource(), AcceptDragDropPayload()$/;"	t
ImGuiDragDropFlags_	imgui.h	/^enum ImGuiDragDropFlags_$/;"	g
ImGuiDragDropFlags_AcceptBeforeDelivery	imgui.h	/^    ImGuiDragDropFlags_AcceptBeforeDelivery         = 1 << 10,  \/\/ AcceptDragDropPayload() will returns true even before the mouse button is released. You can then call IsDelivery() to test if the payload needs to be delivered.$/;"	e	enum:ImGuiDragDropFlags_
ImGuiDragDropFlags_AcceptNoDrawDefaultRect	imgui.h	/^    ImGuiDragDropFlags_AcceptNoDrawDefaultRect      = 1 << 11,  \/\/ Do not draw the default highlight rectangle when hovering over target.$/;"	e	enum:ImGuiDragDropFlags_
ImGuiDragDropFlags_AcceptNoPreviewTooltip	imgui.h	/^    ImGuiDragDropFlags_AcceptNoPreviewTooltip       = 1 << 12,  \/\/ Request hiding the BeginDragDropSource tooltip from the BeginDragDropTarget site.$/;"	e	enum:ImGuiDragDropFlags_
ImGuiDragDropFlags_AcceptPeekOnly	imgui.h	/^    ImGuiDragDropFlags_AcceptPeekOnly               = ImGuiDragDropFlags_AcceptBeforeDelivery | ImGuiDragDropFlags_AcceptNoDrawDefaultRect  \/\/ For peeking ahead and inspecting the payload before delivery.$/;"	e	enum:ImGuiDragDropFlags_
ImGuiDragDropFlags_None	imgui.h	/^    ImGuiDragDropFlags_None                         = 0,$/;"	e	enum:ImGuiDragDropFlags_
ImGuiDragDropFlags_SourceAllowNullID	imgui.h	/^    ImGuiDragDropFlags_SourceAllowNullID            = 1 << 3,   \/\/ Allow items such as Text(), Image() that have no unique identifier to be used as drag source, by manufacturing a temporary identifier based on their window-relative position. This is extremely unusual within the dear imgui ecosystem and so we made it explicit.$/;"	e	enum:ImGuiDragDropFlags_
ImGuiDragDropFlags_SourceAutoExpirePayload	imgui.h	/^    ImGuiDragDropFlags_SourceAutoExpirePayload      = 1 << 5,   \/\/ Automatically expire the payload if the source cease to be submitted (otherwise payloads are persisting while being dragged)$/;"	e	enum:ImGuiDragDropFlags_
ImGuiDragDropFlags_SourceExtern	imgui.h	/^    ImGuiDragDropFlags_SourceExtern                 = 1 << 4,   \/\/ External source (from outside of dear imgui), won't attempt to read current item\/window info. Will always return true. Only one Extern source can be active simultaneously.$/;"	e	enum:ImGuiDragDropFlags_
ImGuiDragDropFlags_SourceNoDisableHover	imgui.h	/^    ImGuiDragDropFlags_SourceNoDisableHover         = 1 << 1,   \/\/ By default, when dragging we clear data so that IsItemHovered() will return false, to avoid subsequent user code submitting tooltips. This flag disable this behavior so you can still call IsItemHovered() on the source item.$/;"	e	enum:ImGuiDragDropFlags_
ImGuiDragDropFlags_SourceNoHoldToOpenOthers	imgui.h	/^    ImGuiDragDropFlags_SourceNoHoldToOpenOthers     = 1 << 2,   \/\/ Disable the behavior that allows to open tree nodes and collapsing header by holding over them while dragging a source item.$/;"	e	enum:ImGuiDragDropFlags_
ImGuiDragDropFlags_SourceNoPreviewTooltip	imgui.h	/^    ImGuiDragDropFlags_SourceNoPreviewTooltip       = 1 << 0,   \/\/ By default, a successful call to BeginDragDropSource opens a tooltip so you can display a preview or description of the source contents. This flag disable this behavior.$/;"	e	enum:ImGuiDragDropFlags_
ImGuiErrorLogCallback	imgui_internal.h	/^typedef void (*ImGuiErrorLogCallback)(void* user_data, const char* fmt, ...);$/;"	t
ImGuiFocusedFlags	imgui.h	/^typedef int ImGuiFocusedFlags;      \/\/ -> enum ImGuiFocusedFlags_    \/\/ Flags: for IsWindowFocused()$/;"	t
ImGuiFocusedFlags_	imgui.h	/^enum ImGuiFocusedFlags_$/;"	g
ImGuiFocusedFlags_AnyWindow	imgui.h	/^    ImGuiFocusedFlags_AnyWindow                     = 1 << 2,   \/\/ IsWindowFocused(): Return true if any window is focused. Important: If you are trying to tell how to dispatch your low-level inputs, do NOT use this. Use 'io.WantCaptureMouse' instead! Please read the FAQ!$/;"	e	enum:ImGuiFocusedFlags_
ImGuiFocusedFlags_ChildWindows	imgui.h	/^    ImGuiFocusedFlags_ChildWindows                  = 1 << 0,   \/\/ IsWindowFocused(): Return true if any children of the window is focused$/;"	e	enum:ImGuiFocusedFlags_
ImGuiFocusedFlags_None	imgui.h	/^    ImGuiFocusedFlags_None                          = 0,$/;"	e	enum:ImGuiFocusedFlags_
ImGuiFocusedFlags_RootAndChildWindows	imgui.h	/^    ImGuiFocusedFlags_RootAndChildWindows           = ImGuiFocusedFlags_RootWindow | ImGuiFocusedFlags_ChildWindows$/;"	e	enum:ImGuiFocusedFlags_
ImGuiFocusedFlags_RootWindow	imgui.h	/^    ImGuiFocusedFlags_RootWindow                    = 1 << 1,   \/\/ IsWindowFocused(): Test from root window (top most parent of the current hierarchy)$/;"	e	enum:ImGuiFocusedFlags_
ImGuiGroupData	imgui_internal.h	/^struct IMGUI_API ImGuiGroupData$/;"	s
ImGuiHoveredFlags	imgui.h	/^typedef int ImGuiHoveredFlags;      \/\/ -> enum ImGuiHoveredFlags_    \/\/ Flags: for IsItemHovered(), IsWindowHovered() etc.$/;"	t
ImGuiHoveredFlags_	imgui.h	/^enum ImGuiHoveredFlags_$/;"	g
ImGuiHoveredFlags_AllowWhenBlockedByActiveItem	imgui.h	/^    ImGuiHoveredFlags_AllowWhenBlockedByActiveItem  = 1 << 5,   \/\/ Return true even if an active item is blocking access to this item\/window. Useful for Drag and Drop patterns.$/;"	e	enum:ImGuiHoveredFlags_
ImGuiHoveredFlags_AllowWhenBlockedByPopup	imgui.h	/^    ImGuiHoveredFlags_AllowWhenBlockedByPopup       = 1 << 3,   \/\/ Return true even if a popup window is normally blocking access to this item\/window$/;"	e	enum:ImGuiHoveredFlags_
ImGuiHoveredFlags_AllowWhenDisabled	imgui.h	/^    ImGuiHoveredFlags_AllowWhenDisabled             = 1 << 7,   \/\/ Return true even if the item is disabled$/;"	e	enum:ImGuiHoveredFlags_
ImGuiHoveredFlags_AllowWhenOverlapped	imgui.h	/^    ImGuiHoveredFlags_AllowWhenOverlapped           = 1 << 6,   \/\/ Return true even if the position is obstructed or overlapped by another window$/;"	e	enum:ImGuiHoveredFlags_
ImGuiHoveredFlags_AnyWindow	imgui.h	/^    ImGuiHoveredFlags_AnyWindow                     = 1 << 2,   \/\/ IsWindowHovered() only: Return true if any window is hovered$/;"	e	enum:ImGuiHoveredFlags_
ImGuiHoveredFlags_ChildWindows	imgui.h	/^    ImGuiHoveredFlags_ChildWindows                  = 1 << 0,   \/\/ IsWindowHovered() only: Return true if any children of the window is hovered$/;"	e	enum:ImGuiHoveredFlags_
ImGuiHoveredFlags_None	imgui.h	/^    ImGuiHoveredFlags_None                          = 0,        \/\/ Return true if directly over the item\/window, not obstructed by another window, not obstructed by an active popup or modal blocking inputs under them.$/;"	e	enum:ImGuiHoveredFlags_
ImGuiHoveredFlags_RectOnly	imgui.h	/^    ImGuiHoveredFlags_RectOnly                      = ImGuiHoveredFlags_AllowWhenBlockedByPopup | ImGuiHoveredFlags_AllowWhenBlockedByActiveItem | ImGuiHoveredFlags_AllowWhenOverlapped,$/;"	e	enum:ImGuiHoveredFlags_
ImGuiHoveredFlags_RootAndChildWindows	imgui.h	/^    ImGuiHoveredFlags_RootAndChildWindows           = ImGuiHoveredFlags_RootWindow | ImGuiHoveredFlags_ChildWindows$/;"	e	enum:ImGuiHoveredFlags_
ImGuiHoveredFlags_RootWindow	imgui.h	/^    ImGuiHoveredFlags_RootWindow                    = 1 << 1,   \/\/ IsWindowHovered() only: Test from root window (top most parent of the current hierarchy)$/;"	e	enum:ImGuiHoveredFlags_
ImGuiID	imgui.h	/^typedef unsigned int ImGuiID;       \/\/ A unique ID used by widgets, typically hashed from a stack of string.$/;"	t
ImGuiIO	imgui.cpp	/^ImGuiIO::ImGuiIO()$/;"	f	class:ImGuiIO
ImGuiIO	imgui.h	/^struct ImGuiIO$/;"	s
ImGuiInputReadMode	imgui_internal.h	/^enum ImGuiInputReadMode$/;"	g
ImGuiInputReadMode_Down	imgui_internal.h	/^    ImGuiInputReadMode_Down,$/;"	e	enum:ImGuiInputReadMode
ImGuiInputReadMode_Pressed	imgui_internal.h	/^    ImGuiInputReadMode_Pressed,$/;"	e	enum:ImGuiInputReadMode
ImGuiInputReadMode_Released	imgui_internal.h	/^    ImGuiInputReadMode_Released,$/;"	e	enum:ImGuiInputReadMode
ImGuiInputReadMode_Repeat	imgui_internal.h	/^    ImGuiInputReadMode_Repeat,$/;"	e	enum:ImGuiInputReadMode
ImGuiInputReadMode_RepeatFast	imgui_internal.h	/^    ImGuiInputReadMode_RepeatFast$/;"	e	enum:ImGuiInputReadMode
ImGuiInputReadMode_RepeatSlow	imgui_internal.h	/^    ImGuiInputReadMode_RepeatSlow,$/;"	e	enum:ImGuiInputReadMode
ImGuiInputSource	imgui_internal.h	/^enum ImGuiInputSource$/;"	g
ImGuiInputSource_COUNT	imgui_internal.h	/^    ImGuiInputSource_COUNT$/;"	e	enum:ImGuiInputSource
ImGuiInputSource_Clipboard	imgui_internal.h	/^    ImGuiInputSource_Clipboard,         \/\/ Currently only used by InputText()$/;"	e	enum:ImGuiInputSource
ImGuiInputSource_Gamepad	imgui_internal.h	/^    ImGuiInputSource_Gamepad,$/;"	e	enum:ImGuiInputSource
ImGuiInputSource_Keyboard	imgui_internal.h	/^    ImGuiInputSource_Keyboard,$/;"	e	enum:ImGuiInputSource
ImGuiInputSource_Mouse	imgui_internal.h	/^    ImGuiInputSource_Mouse,$/;"	e	enum:ImGuiInputSource
ImGuiInputSource_Nav	imgui_internal.h	/^    ImGuiInputSource_Nav,               \/\/ Stored in g.ActiveIdSource only$/;"	e	enum:ImGuiInputSource
ImGuiInputSource_None	imgui_internal.h	/^    ImGuiInputSource_None = 0,$/;"	e	enum:ImGuiInputSource
ImGuiInputTextCallback	imgui.h	/^typedef int (*ImGuiInputTextCallback)(ImGuiInputTextCallbackData* data);    \/\/ Callback function for ImGui::InputText()$/;"	t
ImGuiInputTextCallbackData	imgui.h	/^struct ImGuiInputTextCallbackData$/;"	s
ImGuiInputTextCallbackData	imgui_widgets.cpp	/^ImGuiInputTextCallbackData::ImGuiInputTextCallbackData()$/;"	f	class:ImGuiInputTextCallbackData
ImGuiInputTextFlags	imgui.h	/^typedef int ImGuiInputTextFlags;    \/\/ -> enum ImGuiInputTextFlags_  \/\/ Flags: for InputText(), InputTextMultiline()$/;"	t
ImGuiInputTextFlags_	imgui.h	/^enum ImGuiInputTextFlags_$/;"	g
ImGuiInputTextFlags_AllowTabInput	imgui.h	/^    ImGuiInputTextFlags_AllowTabInput       = 1 << 10,  \/\/ Pressing TAB input a '\\t' character into the text field$/;"	e	enum:ImGuiInputTextFlags_
ImGuiInputTextFlags_AlwaysInsertMode	imgui.h	/^    , ImGuiInputTextFlags_AlwaysInsertMode    = ImGuiInputTextFlags_AlwaysOverwrite   \/\/ [renamed in 1.82] name was not matching behavior$/;"	e	enum:ImGuiInputTextFlags_
ImGuiInputTextFlags_AlwaysOverwrite	imgui.h	/^    ImGuiInputTextFlags_AlwaysOverwrite     = 1 << 13,  \/\/ Overwrite mode$/;"	e	enum:ImGuiInputTextFlags_
ImGuiInputTextFlags_AutoSelectAll	imgui.h	/^    ImGuiInputTextFlags_AutoSelectAll       = 1 << 4,   \/\/ Select entire text when first taking mouse focus$/;"	e	enum:ImGuiInputTextFlags_
ImGuiInputTextFlags_CallbackAlways	imgui.h	/^    ImGuiInputTextFlags_CallbackAlways      = 1 << 8,   \/\/ Callback on each iteration. User code may query cursor position, modify text buffer.$/;"	e	enum:ImGuiInputTextFlags_
ImGuiInputTextFlags_CallbackCharFilter	imgui.h	/^    ImGuiInputTextFlags_CallbackCharFilter  = 1 << 9,   \/\/ Callback on character inputs to replace or discard them. Modify 'EventChar' to replace or discard, or return 1 in callback to discard.$/;"	e	enum:ImGuiInputTextFlags_
ImGuiInputTextFlags_CallbackCompletion	imgui.h	/^    ImGuiInputTextFlags_CallbackCompletion  = 1 << 6,   \/\/ Callback on pressing TAB (for completion handling)$/;"	e	enum:ImGuiInputTextFlags_
ImGuiInputTextFlags_CallbackEdit	imgui.h	/^    ImGuiInputTextFlags_CallbackEdit        = 1 << 19,  \/\/ Callback on any edit (note that InputText() already returns true on edit, the callback is useful mainly to manipulate the underlying buffer while focus is active)$/;"	e	enum:ImGuiInputTextFlags_
ImGuiInputTextFlags_CallbackHistory	imgui.h	/^    ImGuiInputTextFlags_CallbackHistory     = 1 << 7,   \/\/ Callback on pressing Up\/Down arrows (for history handling)$/;"	e	enum:ImGuiInputTextFlags_
ImGuiInputTextFlags_CallbackResize	imgui.h	/^    ImGuiInputTextFlags_CallbackResize      = 1 << 18,  \/\/ Callback on buffer capacity changes request (beyond 'buf_size' parameter value), allowing the string to grow. Notify when the string wants to be resized (for string types which hold a cache of their Size). You will be provided a new BufSize in the callback and NEED to honor it. (see misc\/cpp\/imgui_stdlib.h for an example of using this)$/;"	e	enum:ImGuiInputTextFlags_
ImGuiInputTextFlags_CharsDecimal	imgui.h	/^    ImGuiInputTextFlags_CharsDecimal        = 1 << 0,   \/\/ Allow 0123456789.+-*\/$/;"	e	enum:ImGuiInputTextFlags_
ImGuiInputTextFlags_CharsHexadecimal	imgui.h	/^    ImGuiInputTextFlags_CharsHexadecimal    = 1 << 1,   \/\/ Allow 0123456789ABCDEFabcdef$/;"	e	enum:ImGuiInputTextFlags_
ImGuiInputTextFlags_CharsNoBlank	imgui.h	/^    ImGuiInputTextFlags_CharsNoBlank        = 1 << 3,   \/\/ Filter out spaces, tabs$/;"	e	enum:ImGuiInputTextFlags_
ImGuiInputTextFlags_CharsScientific	imgui.h	/^    ImGuiInputTextFlags_CharsScientific     = 1 << 17,  \/\/ Allow 0123456789.+-*\/eE (Scientific notation input)$/;"	e	enum:ImGuiInputTextFlags_
ImGuiInputTextFlags_CharsUppercase	imgui.h	/^    ImGuiInputTextFlags_CharsUppercase      = 1 << 2,   \/\/ Turn a..z into A..Z$/;"	e	enum:ImGuiInputTextFlags_
ImGuiInputTextFlags_CtrlEnterForNewLine	imgui.h	/^    ImGuiInputTextFlags_CtrlEnterForNewLine = 1 << 11,  \/\/ In multi-line mode, unfocus with Enter, add new line with Ctrl+Enter (default is opposite: unfocus with Ctrl+Enter, add line with Enter).$/;"	e	enum:ImGuiInputTextFlags_
ImGuiInputTextFlags_EnterReturnsTrue	imgui.h	/^    ImGuiInputTextFlags_EnterReturnsTrue    = 1 << 5,   \/\/ Return 'true' when Enter is pressed (as opposed to every time the value was modified). Consider looking at the IsItemDeactivatedAfterEdit() function.$/;"	e	enum:ImGuiInputTextFlags_
ImGuiInputTextFlags_Multiline	imgui.h	/^    ImGuiInputTextFlags_Multiline           = 1 << 20,  \/\/ For internal use by InputTextMultiline()$/;"	e	enum:ImGuiInputTextFlags_
ImGuiInputTextFlags_NoHorizontalScroll	imgui.h	/^    ImGuiInputTextFlags_NoHorizontalScroll  = 1 << 12,  \/\/ Disable following the cursor horizontally$/;"	e	enum:ImGuiInputTextFlags_
ImGuiInputTextFlags_NoMarkEdited	imgui.h	/^    ImGuiInputTextFlags_NoMarkEdited        = 1 << 21   \/\/ For internal use by functions using InputText() before reformatting data$/;"	e	enum:ImGuiInputTextFlags_
ImGuiInputTextFlags_NoUndoRedo	imgui.h	/^    ImGuiInputTextFlags_NoUndoRedo          = 1 << 16,  \/\/ Disable undo\/redo. Note that input text owns the text data while active, if you want to provide your own undo\/redo stack you need e.g. to call ClearActiveID().$/;"	e	enum:ImGuiInputTextFlags_
ImGuiInputTextFlags_None	imgui.h	/^    ImGuiInputTextFlags_None                = 0,$/;"	e	enum:ImGuiInputTextFlags_
ImGuiInputTextFlags_Password	imgui.h	/^    ImGuiInputTextFlags_Password            = 1 << 15,  \/\/ Password mode, display all characters as '*'$/;"	e	enum:ImGuiInputTextFlags_
ImGuiInputTextFlags_ReadOnly	imgui.h	/^    ImGuiInputTextFlags_ReadOnly            = 1 << 14,  \/\/ Read-only mode$/;"	e	enum:ImGuiInputTextFlags_
ImGuiInputTextState	imgui_internal.h	/^    ImGuiInputTextState()                   { memset(this, 0, sizeof(*this)); }$/;"	f	struct:ImGuiInputTextState
ImGuiInputTextState	imgui_internal.h	/^struct IMGUI_API ImGuiInputTextState$/;"	s
ImGuiItemFlags	imgui_internal.h	/^typedef int ImGuiItemFlags;             \/\/ -> enum ImGuiItemFlags_          \/\/ Flags: for PushItemFlag()$/;"	t
ImGuiItemFlags_	imgui_internal.h	/^enum ImGuiItemFlags_$/;"	g
ImGuiItemFlags_ButtonRepeat	imgui_internal.h	/^    ImGuiItemFlags_ButtonRepeat             = 1 << 1,  \/\/ false    \/\/ Button() will return true multiple times based on io.KeyRepeatDelay and io.KeyRepeatRate settings.$/;"	e	enum:ImGuiItemFlags_
ImGuiItemFlags_Default_	imgui_internal.h	/^    ImGuiItemFlags_Default_                 = 0$/;"	e	enum:ImGuiItemFlags_
ImGuiItemFlags_Disabled	imgui_internal.h	/^    ImGuiItemFlags_Disabled                 = 1 << 2,  \/\/ false    \/\/ [BETA] Disable interactions but doesn't affect visuals yet. See github.com\/ocornut\/imgui\/issues\/211$/;"	e	enum:ImGuiItemFlags_
ImGuiItemFlags_MixedValue	imgui_internal.h	/^    ImGuiItemFlags_MixedValue               = 1 << 6,  \/\/ false    \/\/ [BETA] Represent a mixed\/indeterminate value, generally multi-selection where values differ. Currently only supported by Checkbox() (later should support all sorts of widgets)$/;"	e	enum:ImGuiItemFlags_
ImGuiItemFlags_NoNav	imgui_internal.h	/^    ImGuiItemFlags_NoNav                    = 1 << 3,  \/\/ false$/;"	e	enum:ImGuiItemFlags_
ImGuiItemFlags_NoNavDefaultFocus	imgui_internal.h	/^    ImGuiItemFlags_NoNavDefaultFocus        = 1 << 4,  \/\/ false$/;"	e	enum:ImGuiItemFlags_
ImGuiItemFlags_NoTabStop	imgui_internal.h	/^    ImGuiItemFlags_NoTabStop                = 1 << 0,  \/\/ false$/;"	e	enum:ImGuiItemFlags_
ImGuiItemFlags_None	imgui_internal.h	/^    ImGuiItemFlags_None                     = 0,$/;"	e	enum:ImGuiItemFlags_
ImGuiItemFlags_ReadOnly	imgui_internal.h	/^    ImGuiItemFlags_ReadOnly                 = 1 << 7,  \/\/ false    \/\/ [ALPHA] Allow hovering interactions but underlying value is not changed.$/;"	e	enum:ImGuiItemFlags_
ImGuiItemFlags_SelectableDontClosePopup	imgui_internal.h	/^    ImGuiItemFlags_SelectableDontClosePopup = 1 << 5,  \/\/ false    \/\/ MenuItem\/Selectable() automatically closes current Popup window$/;"	e	enum:ImGuiItemFlags_
ImGuiItemStatusFlags	imgui_internal.h	/^typedef int ImGuiItemStatusFlags;       \/\/ -> enum ImGuiItemStatusFlags_    \/\/ Flags: for DC.LastItemStatusFlags$/;"	t
ImGuiItemStatusFlags_	imgui_internal.h	/^enum ImGuiItemStatusFlags_$/;"	g
ImGuiItemStatusFlags_Checkable	imgui_internal.h	/^    ImGuiItemStatusFlags_Checkable          = 1 << 12,  \/\/$/;"	e	enum:ImGuiItemStatusFlags_
ImGuiItemStatusFlags_Checked	imgui_internal.h	/^    ImGuiItemStatusFlags_Checked            = 1 << 13   \/\/$/;"	e	enum:ImGuiItemStatusFlags_
ImGuiItemStatusFlags_Deactivated	imgui_internal.h	/^    ImGuiItemStatusFlags_Deactivated        = 1 << 6,   \/\/ Only valid if ImGuiItemStatusFlags_HasDeactivated is set.$/;"	e	enum:ImGuiItemStatusFlags_
ImGuiItemStatusFlags_Edited	imgui_internal.h	/^    ImGuiItemStatusFlags_Edited             = 1 << 2,   \/\/ Value exposed by item was edited in the current frame (should match the bool return value of most widgets)$/;"	e	enum:ImGuiItemStatusFlags_
ImGuiItemStatusFlags_HasDeactivated	imgui_internal.h	/^    ImGuiItemStatusFlags_HasDeactivated     = 1 << 5,   \/\/ Set if the widget\/group is able to provide data for the ImGuiItemStatusFlags_Deactivated flag.$/;"	e	enum:ImGuiItemStatusFlags_
ImGuiItemStatusFlags_HasDisplayRect	imgui_internal.h	/^    ImGuiItemStatusFlags_HasDisplayRect     = 1 << 1,   \/\/ LastItemDisplayRect is valid$/;"	e	enum:ImGuiItemStatusFlags_
ImGuiItemStatusFlags_HoveredRect	imgui_internal.h	/^    ImGuiItemStatusFlags_HoveredRect        = 1 << 0,$/;"	e	enum:ImGuiItemStatusFlags_
ImGuiItemStatusFlags_HoveredWindow	imgui_internal.h	/^    ImGuiItemStatusFlags_HoveredWindow      = 1 << 7    \/\/ Override the HoveredWindow test to allow cross-window hover testing.$/;"	e	enum:ImGuiItemStatusFlags_
ImGuiItemStatusFlags_None	imgui_internal.h	/^    ImGuiItemStatusFlags_None               = 0,$/;"	e	enum:ImGuiItemStatusFlags_
ImGuiItemStatusFlags_Openable	imgui_internal.h	/^    ImGuiItemStatusFlags_Openable           = 1 << 10,  \/\/$/;"	e	enum:ImGuiItemStatusFlags_
ImGuiItemStatusFlags_Opened	imgui_internal.h	/^    ImGuiItemStatusFlags_Opened             = 1 << 11,  \/\/$/;"	e	enum:ImGuiItemStatusFlags_
ImGuiItemStatusFlags_ToggledOpen	imgui_internal.h	/^    ImGuiItemStatusFlags_ToggledOpen        = 1 << 4,   \/\/ Set when TreeNode() reports toggling their open state.$/;"	e	enum:ImGuiItemStatusFlags_
ImGuiItemStatusFlags_ToggledSelection	imgui_internal.h	/^    ImGuiItemStatusFlags_ToggledSelection   = 1 << 3,   \/\/ Set when Selectable(), TreeNode() reports toggling a selection. We can't report "Selected" because reporting the change allows us to handle clipping with less issues.$/;"	e	enum:ImGuiItemStatusFlags_
ImGuiKey	imgui.h	/^typedef int ImGuiKey;               \/\/ -> enum ImGuiKey_             \/\/ Enum: A key identifier (ImGui-side enum)$/;"	t
ImGuiKeyModFlags	imgui.h	/^typedef int ImGuiKeyModFlags;       \/\/ -> enum ImGuiKeyModFlags_     \/\/ Flags: for io.KeyMods (Ctrl\/Shift\/Alt\/Super)$/;"	t
ImGuiKeyModFlags_	imgui.h	/^enum ImGuiKeyModFlags_$/;"	g
ImGuiKeyModFlags_Alt	imgui.h	/^    ImGuiKeyModFlags_Alt        = 1 << 2,$/;"	e	enum:ImGuiKeyModFlags_
ImGuiKeyModFlags_Ctrl	imgui.h	/^    ImGuiKeyModFlags_Ctrl       = 1 << 0,$/;"	e	enum:ImGuiKeyModFlags_
ImGuiKeyModFlags_None	imgui.h	/^    ImGuiKeyModFlags_None       = 0,$/;"	e	enum:ImGuiKeyModFlags_
ImGuiKeyModFlags_Shift	imgui.h	/^    ImGuiKeyModFlags_Shift      = 1 << 1,$/;"	e	enum:ImGuiKeyModFlags_
ImGuiKeyModFlags_Super	imgui.h	/^    ImGuiKeyModFlags_Super      = 1 << 3$/;"	e	enum:ImGuiKeyModFlags_
ImGuiKey_	imgui.h	/^enum ImGuiKey_$/;"	g
ImGuiKey_A	imgui.h	/^    ImGuiKey_A,                 \/\/ for text edit CTRL+A: select all$/;"	e	enum:ImGuiKey_
ImGuiKey_Backspace	imgui.h	/^    ImGuiKey_Backspace,$/;"	e	enum:ImGuiKey_
ImGuiKey_C	imgui.h	/^    ImGuiKey_C,                 \/\/ for text edit CTRL+C: copy$/;"	e	enum:ImGuiKey_
ImGuiKey_COUNT	imgui.h	/^    ImGuiKey_COUNT$/;"	e	enum:ImGuiKey_
ImGuiKey_Delete	imgui.h	/^    ImGuiKey_Delete,$/;"	e	enum:ImGuiKey_
ImGuiKey_DownArrow	imgui.h	/^    ImGuiKey_DownArrow,$/;"	e	enum:ImGuiKey_
ImGuiKey_End	imgui.h	/^    ImGuiKey_End,$/;"	e	enum:ImGuiKey_
ImGuiKey_Enter	imgui.h	/^    ImGuiKey_Enter,$/;"	e	enum:ImGuiKey_
ImGuiKey_Escape	imgui.h	/^    ImGuiKey_Escape,$/;"	e	enum:ImGuiKey_
ImGuiKey_Home	imgui.h	/^    ImGuiKey_Home,$/;"	e	enum:ImGuiKey_
ImGuiKey_Insert	imgui.h	/^    ImGuiKey_Insert,$/;"	e	enum:ImGuiKey_
ImGuiKey_KeyPadEnter	imgui.h	/^    ImGuiKey_KeyPadEnter,$/;"	e	enum:ImGuiKey_
ImGuiKey_LeftArrow	imgui.h	/^    ImGuiKey_LeftArrow,$/;"	e	enum:ImGuiKey_
ImGuiKey_PageDown	imgui.h	/^    ImGuiKey_PageDown,$/;"	e	enum:ImGuiKey_
ImGuiKey_PageUp	imgui.h	/^    ImGuiKey_PageUp,$/;"	e	enum:ImGuiKey_
ImGuiKey_RightArrow	imgui.h	/^    ImGuiKey_RightArrow,$/;"	e	enum:ImGuiKey_
ImGuiKey_Space	imgui.h	/^    ImGuiKey_Space,$/;"	e	enum:ImGuiKey_
ImGuiKey_Tab	imgui.h	/^    ImGuiKey_Tab,$/;"	e	enum:ImGuiKey_
ImGuiKey_UpArrow	imgui.h	/^    ImGuiKey_UpArrow,$/;"	e	enum:ImGuiKey_
ImGuiKey_V	imgui.h	/^    ImGuiKey_V,                 \/\/ for text edit CTRL+V: paste$/;"	e	enum:ImGuiKey_
ImGuiKey_X	imgui.h	/^    ImGuiKey_X,                 \/\/ for text edit CTRL+X: cut$/;"	e	enum:ImGuiKey_
ImGuiKey_Y	imgui.h	/^    ImGuiKey_Y,                 \/\/ for text edit CTRL+Y: redo$/;"	e	enum:ImGuiKey_
ImGuiKey_Z	imgui.h	/^    ImGuiKey_Z,                 \/\/ for text edit CTRL+Z: undo$/;"	e	enum:ImGuiKey_
ImGuiLastItemDataBackup	imgui_internal.h	/^    ImGuiLastItemDataBackup() { Backup(); }$/;"	f	struct:ImGuiLastItemDataBackup
ImGuiLastItemDataBackup	imgui_internal.h	/^struct ImGuiLastItemDataBackup$/;"	s
ImGuiLayoutType	imgui_internal.h	/^typedef int ImGuiLayoutType;            \/\/ -> enum ImGuiLayoutType_         \/\/ Enum: Horizontal or vertical$/;"	t
ImGuiLayoutType_	imgui_internal.h	/^enum ImGuiLayoutType_$/;"	g
ImGuiLayoutType_Horizontal	imgui_internal.h	/^    ImGuiLayoutType_Horizontal = 0,$/;"	e	enum:ImGuiLayoutType_
ImGuiLayoutType_Vertical	imgui_internal.h	/^    ImGuiLayoutType_Vertical = 1$/;"	e	enum:ImGuiLayoutType_
ImGuiListClipper	imgui.cpp	/^ImGuiListClipper::ImGuiListClipper()$/;"	f	class:ImGuiListClipper
ImGuiListClipper	imgui.h	/^    inline ImGuiListClipper(int items_count, float items_height = -1.0f) { memset(this, 0, sizeof(*this)); ItemsCount = -1; Begin(items_count, items_height); } \/\/ [removed in 1.79]$/;"	f	struct:ImGuiListClipper
ImGuiListClipper	imgui.h	/^struct ImGuiListClipper$/;"	s
ImGuiLogType	imgui_internal.h	/^enum ImGuiLogType$/;"	g
ImGuiLogType_Buffer	imgui_internal.h	/^    ImGuiLogType_Buffer,$/;"	e	enum:ImGuiLogType
ImGuiLogType_Clipboard	imgui_internal.h	/^    ImGuiLogType_Clipboard$/;"	e	enum:ImGuiLogType
ImGuiLogType_File	imgui_internal.h	/^    ImGuiLogType_File,$/;"	e	enum:ImGuiLogType
ImGuiLogType_None	imgui_internal.h	/^    ImGuiLogType_None = 0,$/;"	e	enum:ImGuiLogType
ImGuiLogType_TTY	imgui_internal.h	/^    ImGuiLogType_TTY,$/;"	e	enum:ImGuiLogType
ImGuiMemAllocFunc	imgui.h	/^typedef void* (*ImGuiMemAllocFunc)(size_t sz, void* user_data);             \/\/ Function signature for ImGui::SetAllocatorFunctions()$/;"	t
ImGuiMemFreeFunc	imgui.h	/^typedef void (*ImGuiMemFreeFunc)(void* ptr, void* user_data);               \/\/ Function signature for ImGui::SetAllocatorFunctions()$/;"	t
ImGuiMenuColumns	imgui_internal.h	/^    ImGuiMenuColumns() { memset(this, 0, sizeof(*this)); }$/;"	f	struct:ImGuiMenuColumns
ImGuiMenuColumns	imgui_internal.h	/^struct IMGUI_API ImGuiMenuColumns$/;"	s
ImGuiMetricsConfig	imgui_internal.h	/^    ImGuiMetricsConfig()$/;"	f	struct:ImGuiMetricsConfig
ImGuiMetricsConfig	imgui_internal.h	/^struct ImGuiMetricsConfig$/;"	s
ImGuiMouseButton	imgui.h	/^typedef int ImGuiMouseButton;       \/\/ -> enum ImGuiMouseButton_     \/\/ Enum: A mouse button identifier (0=left, 1=right, 2=middle)$/;"	t
ImGuiMouseButton_	imgui.h	/^enum ImGuiMouseButton_$/;"	g
ImGuiMouseButton_COUNT	imgui.h	/^    ImGuiMouseButton_COUNT = 5$/;"	e	enum:ImGuiMouseButton_
ImGuiMouseButton_Left	imgui.h	/^    ImGuiMouseButton_Left = 0,$/;"	e	enum:ImGuiMouseButton_
ImGuiMouseButton_Middle	imgui.h	/^    ImGuiMouseButton_Middle = 2,$/;"	e	enum:ImGuiMouseButton_
ImGuiMouseButton_Right	imgui.h	/^    ImGuiMouseButton_Right = 1,$/;"	e	enum:ImGuiMouseButton_
ImGuiMouseCursor	imgui.h	/^typedef int ImGuiMouseCursor;       \/\/ -> enum ImGuiMouseCursor_     \/\/ Enum: A mouse cursor identifier$/;"	t
ImGuiMouseCursor_	imgui.h	/^enum ImGuiMouseCursor_$/;"	g
ImGuiMouseCursor_Arrow	imgui.h	/^    ImGuiMouseCursor_Arrow = 0,$/;"	e	enum:ImGuiMouseCursor_
ImGuiMouseCursor_COUNT	imgui.h	/^    ImGuiMouseCursor_COUNT$/;"	e	enum:ImGuiMouseCursor_
ImGuiMouseCursor_Hand	imgui.h	/^    ImGuiMouseCursor_Hand,              \/\/ (Unused by Dear ImGui functions. Use for e.g. hyperlinks)$/;"	e	enum:ImGuiMouseCursor_
ImGuiMouseCursor_None	imgui.h	/^    ImGuiMouseCursor_None = -1,$/;"	e	enum:ImGuiMouseCursor_
ImGuiMouseCursor_NotAllowed	imgui.h	/^    ImGuiMouseCursor_NotAllowed,        \/\/ When hovering something with disallowed interaction. Usually a crossed circle.$/;"	e	enum:ImGuiMouseCursor_
ImGuiMouseCursor_ResizeAll	imgui.h	/^    ImGuiMouseCursor_ResizeAll,         \/\/ (Unused by Dear ImGui functions)$/;"	e	enum:ImGuiMouseCursor_
ImGuiMouseCursor_ResizeEW	imgui.h	/^    ImGuiMouseCursor_ResizeEW,          \/\/ When hovering over a vertical border or a column$/;"	e	enum:ImGuiMouseCursor_
ImGuiMouseCursor_ResizeNESW	imgui.h	/^    ImGuiMouseCursor_ResizeNESW,        \/\/ When hovering over the bottom-left corner of a window$/;"	e	enum:ImGuiMouseCursor_
ImGuiMouseCursor_ResizeNS	imgui.h	/^    ImGuiMouseCursor_ResizeNS,          \/\/ When hovering over an horizontal border$/;"	e	enum:ImGuiMouseCursor_
ImGuiMouseCursor_ResizeNWSE	imgui.h	/^    ImGuiMouseCursor_ResizeNWSE,        \/\/ When hovering over the bottom-right corner of a window$/;"	e	enum:ImGuiMouseCursor_
ImGuiMouseCursor_TextInput	imgui.h	/^    ImGuiMouseCursor_TextInput,         \/\/ When hovering over InputText, etc.$/;"	e	enum:ImGuiMouseCursor_
ImGuiNavDirSourceFlags	imgui_internal.h	/^typedef int ImGuiNavDirSourceFlags;     \/\/ -> enum ImGuiNavDirSourceFlags_  \/\/ Flags: for GetNavInputAmount2d()$/;"	t
ImGuiNavDirSourceFlags_	imgui_internal.h	/^enum ImGuiNavDirSourceFlags_$/;"	g
ImGuiNavDirSourceFlags_Keyboard	imgui_internal.h	/^    ImGuiNavDirSourceFlags_Keyboard     = 1 << 0,$/;"	e	enum:ImGuiNavDirSourceFlags_
ImGuiNavDirSourceFlags_None	imgui_internal.h	/^    ImGuiNavDirSourceFlags_None         = 0,$/;"	e	enum:ImGuiNavDirSourceFlags_
ImGuiNavDirSourceFlags_PadDPad	imgui_internal.h	/^    ImGuiNavDirSourceFlags_PadDPad      = 1 << 1,$/;"	e	enum:ImGuiNavDirSourceFlags_
ImGuiNavDirSourceFlags_PadLStick	imgui_internal.h	/^    ImGuiNavDirSourceFlags_PadLStick    = 1 << 2$/;"	e	enum:ImGuiNavDirSourceFlags_
ImGuiNavForward	imgui_internal.h	/^enum ImGuiNavForward$/;"	g
ImGuiNavForward_ForwardActive	imgui_internal.h	/^    ImGuiNavForward_ForwardActive$/;"	e	enum:ImGuiNavForward
ImGuiNavForward_ForwardQueued	imgui_internal.h	/^    ImGuiNavForward_ForwardQueued,$/;"	e	enum:ImGuiNavForward
ImGuiNavForward_None	imgui_internal.h	/^    ImGuiNavForward_None,$/;"	e	enum:ImGuiNavForward
ImGuiNavHighlightFlags	imgui_internal.h	/^typedef int ImGuiNavHighlightFlags;     \/\/ -> enum ImGuiNavHighlightFlags_  \/\/ Flags: for RenderNavHighlight()$/;"	t
ImGuiNavHighlightFlags_	imgui_internal.h	/^enum ImGuiNavHighlightFlags_$/;"	g
ImGuiNavHighlightFlags_AlwaysDraw	imgui_internal.h	/^    ImGuiNavHighlightFlags_AlwaysDraw   = 1 << 2,       \/\/ Draw rectangular highlight if (g.NavId == id) _even_ when using the mouse.$/;"	e	enum:ImGuiNavHighlightFlags_
ImGuiNavHighlightFlags_NoRounding	imgui_internal.h	/^    ImGuiNavHighlightFlags_NoRounding   = 1 << 3$/;"	e	enum:ImGuiNavHighlightFlags_
ImGuiNavHighlightFlags_None	imgui_internal.h	/^    ImGuiNavHighlightFlags_None         = 0,$/;"	e	enum:ImGuiNavHighlightFlags_
ImGuiNavHighlightFlags_TypeDefault	imgui_internal.h	/^    ImGuiNavHighlightFlags_TypeDefault  = 1 << 0,$/;"	e	enum:ImGuiNavHighlightFlags_
ImGuiNavHighlightFlags_TypeThin	imgui_internal.h	/^    ImGuiNavHighlightFlags_TypeThin     = 1 << 1,$/;"	e	enum:ImGuiNavHighlightFlags_
ImGuiNavInput	imgui.h	/^typedef int ImGuiNavInput;          \/\/ -> enum ImGuiNavInput_        \/\/ Enum: An input identifier for navigation$/;"	t
ImGuiNavInput_	imgui.h	/^enum ImGuiNavInput_$/;"	g
ImGuiNavInput_Activate	imgui.h	/^    ImGuiNavInput_Activate,      \/\/ activate \/ open \/ toggle \/ tweak value       \/\/ e.g. Cross  (PS4), A (Xbox), A (Switch), Space (Keyboard)$/;"	e	enum:ImGuiNavInput_
ImGuiNavInput_COUNT	imgui.h	/^    ImGuiNavInput_COUNT,$/;"	e	enum:ImGuiNavInput_
ImGuiNavInput_Cancel	imgui.h	/^    ImGuiNavInput_Cancel,        \/\/ cancel \/ close \/ exit                        \/\/ e.g. Circle (PS4), B (Xbox), B (Switch), Escape (Keyboard)$/;"	e	enum:ImGuiNavInput_
ImGuiNavInput_DpadDown	imgui.h	/^    ImGuiNavInput_DpadDown,      \/\/$/;"	e	enum:ImGuiNavInput_
ImGuiNavInput_DpadLeft	imgui.h	/^    ImGuiNavInput_DpadLeft,      \/\/ move \/ tweak \/ resize window (w\/ PadMenu)    \/\/ e.g. D-pad Left\/Right\/Up\/Down (Gamepads), Arrow keys (Keyboard)$/;"	e	enum:ImGuiNavInput_
ImGuiNavInput_DpadRight	imgui.h	/^    ImGuiNavInput_DpadRight,     \/\/$/;"	e	enum:ImGuiNavInput_
ImGuiNavInput_DpadUp	imgui.h	/^    ImGuiNavInput_DpadUp,        \/\/$/;"	e	enum:ImGuiNavInput_
ImGuiNavInput_FocusNext	imgui.h	/^    ImGuiNavInput_FocusNext,     \/\/ prev window (w\/ PadMenu)                     \/\/ e.g. R1 or R2 (PS4), RB or RT (Xbox), R or ZL (Switch)$/;"	e	enum:ImGuiNavInput_
ImGuiNavInput_FocusPrev	imgui.h	/^    ImGuiNavInput_FocusPrev,     \/\/ next window (w\/ PadMenu)                     \/\/ e.g. L1 or L2 (PS4), LB or LT (Xbox), L or ZL (Switch)$/;"	e	enum:ImGuiNavInput_
ImGuiNavInput_Input	imgui.h	/^    ImGuiNavInput_Input,         \/\/ text input \/ on-screen keyboard              \/\/ e.g. Triang.(PS4), Y (Xbox), X (Switch), Return (Keyboard)$/;"	e	enum:ImGuiNavInput_
ImGuiNavInput_InternalStart_	imgui.h	/^    ImGuiNavInput_InternalStart_ = ImGuiNavInput_KeyMenu_$/;"	e	enum:ImGuiNavInput_
ImGuiNavInput_KeyDown_	imgui.h	/^    ImGuiNavInput_KeyDown_,      \/\/ move down$/;"	e	enum:ImGuiNavInput_
ImGuiNavInput_KeyLeft_	imgui.h	/^    ImGuiNavInput_KeyLeft_,      \/\/ move left                                    \/\/ = Arrow keys$/;"	e	enum:ImGuiNavInput_
ImGuiNavInput_KeyMenu_	imgui.h	/^    ImGuiNavInput_KeyMenu_,      \/\/ toggle menu                                  \/\/ = io.KeyAlt$/;"	e	enum:ImGuiNavInput_
ImGuiNavInput_KeyRight_	imgui.h	/^    ImGuiNavInput_KeyRight_,     \/\/ move right$/;"	e	enum:ImGuiNavInput_
ImGuiNavInput_KeyUp_	imgui.h	/^    ImGuiNavInput_KeyUp_,        \/\/ move up$/;"	e	enum:ImGuiNavInput_
ImGuiNavInput_LStickDown	imgui.h	/^    ImGuiNavInput_LStickDown,    \/\/$/;"	e	enum:ImGuiNavInput_
ImGuiNavInput_LStickLeft	imgui.h	/^    ImGuiNavInput_LStickLeft,    \/\/ scroll \/ move window (w\/ PadMenu)            \/\/ e.g. Left Analog Stick Left\/Right\/Up\/Down$/;"	e	enum:ImGuiNavInput_
ImGuiNavInput_LStickRight	imgui.h	/^    ImGuiNavInput_LStickRight,   \/\/$/;"	e	enum:ImGuiNavInput_
ImGuiNavInput_LStickUp	imgui.h	/^    ImGuiNavInput_LStickUp,      \/\/$/;"	e	enum:ImGuiNavInput_
ImGuiNavInput_Menu	imgui.h	/^    ImGuiNavInput_Menu,          \/\/ tap: toggle menu \/ hold: focus, move, resize \/\/ e.g. Square (PS4), X (Xbox), Y (Switch), Alt (Keyboard)$/;"	e	enum:ImGuiNavInput_
ImGuiNavInput_TweakFast	imgui.h	/^    ImGuiNavInput_TweakFast,     \/\/ faster tweaks                                \/\/ e.g. R1 or R2 (PS4), RB or RT (Xbox), R or ZL (Switch)$/;"	e	enum:ImGuiNavInput_
ImGuiNavInput_TweakSlow	imgui.h	/^    ImGuiNavInput_TweakSlow,     \/\/ slower tweaks                                \/\/ e.g. L1 or L2 (PS4), LB or LT (Xbox), L or ZL (Switch)$/;"	e	enum:ImGuiNavInput_
ImGuiNavItemData	imgui_internal.h	/^    ImGuiNavItemData()  { Clear(); }$/;"	f	struct:ImGuiNavItemData
ImGuiNavItemData	imgui_internal.h	/^struct ImGuiNavItemData$/;"	s
ImGuiNavLayer	imgui_internal.h	/^enum ImGuiNavLayer$/;"	g
ImGuiNavLayer_COUNT	imgui_internal.h	/^    ImGuiNavLayer_COUNT$/;"	e	enum:ImGuiNavLayer
ImGuiNavLayer_Main	imgui_internal.h	/^    ImGuiNavLayer_Main  = 0,    \/\/ Main scrolling layer$/;"	e	enum:ImGuiNavLayer
ImGuiNavLayer_Menu	imgui_internal.h	/^    ImGuiNavLayer_Menu  = 1,    \/\/ Menu layer (access with Alt\/ImGuiNavInput_Menu)$/;"	e	enum:ImGuiNavLayer
ImGuiNavMoveFlags	imgui_internal.h	/^typedef int ImGuiNavMoveFlags;          \/\/ -> enum ImGuiNavMoveFlags_       \/\/ Flags: for navigation requests$/;"	t
ImGuiNavMoveFlags_	imgui_internal.h	/^enum ImGuiNavMoveFlags_$/;"	g
ImGuiNavMoveFlags_AllowCurrentNavId	imgui_internal.h	/^    ImGuiNavMoveFlags_AllowCurrentNavId     = 1 << 4,   \/\/ Allow scoring and considering the current NavId as a move target candidate. This is used when the move source is offset (e.g. pressing PageDown actually needs to send a Up move request, if we are pressing PageDown from the bottom-most item we need to stay in place)$/;"	e	enum:ImGuiNavMoveFlags_
ImGuiNavMoveFlags_AlsoScoreVisibleSet	imgui_internal.h	/^    ImGuiNavMoveFlags_AlsoScoreVisibleSet   = 1 << 5,   \/\/ Store alternate result in NavMoveResultLocalVisibleSet that only comprise elements that are already fully visible.$/;"	e	enum:ImGuiNavMoveFlags_
ImGuiNavMoveFlags_LoopX	imgui_internal.h	/^    ImGuiNavMoveFlags_LoopX                 = 1 << 0,   \/\/ On failed request, restart from opposite side$/;"	e	enum:ImGuiNavMoveFlags_
ImGuiNavMoveFlags_LoopY	imgui_internal.h	/^    ImGuiNavMoveFlags_LoopY                 = 1 << 1,$/;"	e	enum:ImGuiNavMoveFlags_
ImGuiNavMoveFlags_None	imgui_internal.h	/^    ImGuiNavMoveFlags_None                  = 0,$/;"	e	enum:ImGuiNavMoveFlags_
ImGuiNavMoveFlags_ScrollToEdge	imgui_internal.h	/^    ImGuiNavMoveFlags_ScrollToEdge          = 1 << 6$/;"	e	enum:ImGuiNavMoveFlags_
ImGuiNavMoveFlags_WrapX	imgui_internal.h	/^    ImGuiNavMoveFlags_WrapX                 = 1 << 2,   \/\/ On failed request, request from opposite side one line down (when NavDir==right) or one line up (when NavDir==left)$/;"	e	enum:ImGuiNavMoveFlags_
ImGuiNavMoveFlags_WrapY	imgui_internal.h	/^    ImGuiNavMoveFlags_WrapY                 = 1 << 3,   \/\/ This is not super useful for provided for completeness$/;"	e	enum:ImGuiNavMoveFlags_
ImGuiNextItemData	imgui_internal.h	/^    ImGuiNextItemData()         { memset(this, 0, sizeof(*this)); }$/;"	f	struct:ImGuiNextItemData
ImGuiNextItemData	imgui_internal.h	/^struct ImGuiNextItemData$/;"	s
ImGuiNextItemDataFlags	imgui_internal.h	/^typedef int ImGuiNextItemDataFlags;     \/\/ -> enum ImGuiNextItemDataFlags_  \/\/ Flags: for SetNextItemXXX() functions$/;"	t
ImGuiNextItemDataFlags_	imgui_internal.h	/^enum ImGuiNextItemDataFlags_$/;"	g
ImGuiNextItemDataFlags_HasOpen	imgui_internal.h	/^    ImGuiNextItemDataFlags_HasOpen  = 1 << 1$/;"	e	enum:ImGuiNextItemDataFlags_
ImGuiNextItemDataFlags_HasWidth	imgui_internal.h	/^    ImGuiNextItemDataFlags_HasWidth = 1 << 0,$/;"	e	enum:ImGuiNextItemDataFlags_
ImGuiNextItemDataFlags_None	imgui_internal.h	/^    ImGuiNextItemDataFlags_None     = 0,$/;"	e	enum:ImGuiNextItemDataFlags_
ImGuiNextWindowData	imgui_internal.h	/^    ImGuiNextWindowData()       { memset(this, 0, sizeof(*this)); }$/;"	f	struct:ImGuiNextWindowData
ImGuiNextWindowData	imgui_internal.h	/^struct ImGuiNextWindowData$/;"	s
ImGuiNextWindowDataFlags	imgui_internal.h	/^typedef int ImGuiNextWindowDataFlags;   \/\/ -> enum ImGuiNextWindowDataFlags_\/\/ Flags: for SetNextWindowXXX() functions$/;"	t
ImGuiNextWindowDataFlags_	imgui_internal.h	/^enum ImGuiNextWindowDataFlags_$/;"	g
ImGuiNextWindowDataFlags_HasBgAlpha	imgui_internal.h	/^    ImGuiNextWindowDataFlags_HasBgAlpha         = 1 << 6,$/;"	e	enum:ImGuiNextWindowDataFlags_
ImGuiNextWindowDataFlags_HasCollapsed	imgui_internal.h	/^    ImGuiNextWindowDataFlags_HasCollapsed       = 1 << 3,$/;"	e	enum:ImGuiNextWindowDataFlags_
ImGuiNextWindowDataFlags_HasContentSize	imgui_internal.h	/^    ImGuiNextWindowDataFlags_HasContentSize     = 1 << 2,$/;"	e	enum:ImGuiNextWindowDataFlags_
ImGuiNextWindowDataFlags_HasFocus	imgui_internal.h	/^    ImGuiNextWindowDataFlags_HasFocus           = 1 << 5,$/;"	e	enum:ImGuiNextWindowDataFlags_
ImGuiNextWindowDataFlags_HasPos	imgui_internal.h	/^    ImGuiNextWindowDataFlags_HasPos             = 1 << 0,$/;"	e	enum:ImGuiNextWindowDataFlags_
ImGuiNextWindowDataFlags_HasScroll	imgui_internal.h	/^    ImGuiNextWindowDataFlags_HasScroll          = 1 << 7$/;"	e	enum:ImGuiNextWindowDataFlags_
ImGuiNextWindowDataFlags_HasSize	imgui_internal.h	/^    ImGuiNextWindowDataFlags_HasSize            = 1 << 1,$/;"	e	enum:ImGuiNextWindowDataFlags_
ImGuiNextWindowDataFlags_HasSizeConstraint	imgui_internal.h	/^    ImGuiNextWindowDataFlags_HasSizeConstraint  = 1 << 4,$/;"	e	enum:ImGuiNextWindowDataFlags_
ImGuiNextWindowDataFlags_None	imgui_internal.h	/^    ImGuiNextWindowDataFlags_None               = 0,$/;"	e	enum:ImGuiNextWindowDataFlags_
ImGuiOldColumnData	imgui_internal.h	/^    ImGuiOldColumnData() { memset(this, 0, sizeof(*this)); }$/;"	f	struct:ImGuiOldColumnData
ImGuiOldColumnData	imgui_internal.h	/^struct ImGuiOldColumnData$/;"	s
ImGuiOldColumnFlags	imgui_internal.h	/^typedef int ImGuiOldColumnFlags;        \/\/ -> enum ImGuiOldColumnFlags_     \/\/ Flags: for BeginColumns()$/;"	t
ImGuiOldColumnFlags_	imgui_internal.h	/^enum ImGuiOldColumnFlags_$/;"	g
ImGuiOldColumnFlags_GrowParentContentsSize	imgui_internal.h	/^    ImGuiOldColumnFlags_GrowParentContentsSize  = 1 << 4    \/\/ (WIP) Restore pre-1.51 behavior of extending the parent window contents size but _without affecting the columns width at all_. Will eventually remove.$/;"	e	enum:ImGuiOldColumnFlags_
ImGuiOldColumnFlags_NoBorder	imgui_internal.h	/^    ImGuiOldColumnFlags_NoBorder                = 1 << 0,   \/\/ Disable column dividers$/;"	e	enum:ImGuiOldColumnFlags_
ImGuiOldColumnFlags_NoForceWithinWindow	imgui_internal.h	/^    ImGuiOldColumnFlags_NoForceWithinWindow     = 1 << 3,   \/\/ Disable forcing columns to fit within window$/;"	e	enum:ImGuiOldColumnFlags_
ImGuiOldColumnFlags_NoPreserveWidths	imgui_internal.h	/^    ImGuiOldColumnFlags_NoPreserveWidths        = 1 << 2,   \/\/ Disable column width preservation when adjusting columns$/;"	e	enum:ImGuiOldColumnFlags_
ImGuiOldColumnFlags_NoResize	imgui_internal.h	/^    ImGuiOldColumnFlags_NoResize                = 1 << 1,   \/\/ Disable resizing columns when clicking on the dividers$/;"	e	enum:ImGuiOldColumnFlags_
ImGuiOldColumnFlags_None	imgui_internal.h	/^    ImGuiOldColumnFlags_None                    = 0,$/;"	e	enum:ImGuiOldColumnFlags_
ImGuiOldColumns	imgui_internal.h	/^    ImGuiOldColumns()   { memset(this, 0, sizeof(*this)); }$/;"	f	struct:ImGuiOldColumns
ImGuiOldColumns	imgui_internal.h	/^struct ImGuiOldColumns$/;"	s
ImGuiOnceUponAFrame	imgui.h	/^    ImGuiOnceUponAFrame() { RefFrame = -1; }$/;"	f	struct:ImGuiOnceUponAFrame
ImGuiOnceUponAFrame	imgui.h	/^struct ImGuiOnceUponAFrame$/;"	s
ImGuiPayload	imgui.h	/^    ImGuiPayload()  { Clear(); }$/;"	f	struct:ImGuiPayload
ImGuiPayload	imgui.h	/^struct ImGuiPayload$/;"	s
ImGuiPlotArrayGetterData	imgui_widgets.cpp	/^    ImGuiPlotArrayGetterData(const float* values, int stride) { Values = values; Stride = stride; }$/;"	f	struct:ImGuiPlotArrayGetterData
ImGuiPlotArrayGetterData	imgui_widgets.cpp	/^struct ImGuiPlotArrayGetterData$/;"	s	file:
ImGuiPlotType	imgui_internal.h	/^enum ImGuiPlotType$/;"	g
ImGuiPlotType_Histogram	imgui_internal.h	/^    ImGuiPlotType_Histogram$/;"	e	enum:ImGuiPlotType
ImGuiPlotType_Lines	imgui_internal.h	/^    ImGuiPlotType_Lines,$/;"	e	enum:ImGuiPlotType
ImGuiPopupData	imgui_internal.h	/^    ImGuiPopupData()    { memset(this, 0, sizeof(*this)); OpenFrameCount = -1; }$/;"	f	struct:ImGuiPopupData
ImGuiPopupData	imgui_internal.h	/^struct ImGuiPopupData$/;"	s
ImGuiPopupFlags	imgui.h	/^typedef int ImGuiPopupFlags;        \/\/ -> enum ImGuiPopupFlags_      \/\/ Flags: for OpenPopup*(), BeginPopupContext*(), IsPopupOpen()$/;"	t
ImGuiPopupFlags_	imgui.h	/^enum ImGuiPopupFlags_$/;"	g
ImGuiPopupFlags_AnyPopup	imgui.h	/^    ImGuiPopupFlags_AnyPopup                = ImGuiPopupFlags_AnyPopupId | ImGuiPopupFlags_AnyPopupLevel$/;"	e	enum:ImGuiPopupFlags_
ImGuiPopupFlags_AnyPopupId	imgui.h	/^    ImGuiPopupFlags_AnyPopupId              = 1 << 7,   \/\/ For IsPopupOpen(): ignore the ImGuiID parameter and test for any popup.$/;"	e	enum:ImGuiPopupFlags_
ImGuiPopupFlags_AnyPopupLevel	imgui.h	/^    ImGuiPopupFlags_AnyPopupLevel           = 1 << 8,   \/\/ For IsPopupOpen(): search\/test at any level of the popup stack (default test in the current level)$/;"	e	enum:ImGuiPopupFlags_
ImGuiPopupFlags_MouseButtonDefault_	imgui.h	/^    ImGuiPopupFlags_MouseButtonDefault_     = 1,$/;"	e	enum:ImGuiPopupFlags_
ImGuiPopupFlags_MouseButtonLeft	imgui.h	/^    ImGuiPopupFlags_MouseButtonLeft         = 0,        \/\/ For BeginPopupContext*(): open on Left Mouse release. Guaranteed to always be == 0 (same as ImGuiMouseButton_Left)$/;"	e	enum:ImGuiPopupFlags_
ImGuiPopupFlags_MouseButtonMask_	imgui.h	/^    ImGuiPopupFlags_MouseButtonMask_        = 0x1F,$/;"	e	enum:ImGuiPopupFlags_
ImGuiPopupFlags_MouseButtonMiddle	imgui.h	/^    ImGuiPopupFlags_MouseButtonMiddle       = 2,        \/\/ For BeginPopupContext*(): open on Middle Mouse release. Guaranteed to always be == 2 (same as ImGuiMouseButton_Middle)$/;"	e	enum:ImGuiPopupFlags_
ImGuiPopupFlags_MouseButtonRight	imgui.h	/^    ImGuiPopupFlags_MouseButtonRight        = 1,        \/\/ For BeginPopupContext*(): open on Right Mouse release. Guaranteed to always be == 1 (same as ImGuiMouseButton_Right)$/;"	e	enum:ImGuiPopupFlags_
ImGuiPopupFlags_NoOpenOverExistingPopup	imgui.h	/^    ImGuiPopupFlags_NoOpenOverExistingPopup = 1 << 5,   \/\/ For OpenPopup*(), BeginPopupContext*(): don't open if there's already a popup at the same level of the popup stack$/;"	e	enum:ImGuiPopupFlags_
ImGuiPopupFlags_NoOpenOverItems	imgui.h	/^    ImGuiPopupFlags_NoOpenOverItems         = 1 << 6,   \/\/ For BeginPopupContextWindow(): don't return true when hovering items, only when hovering empty space$/;"	e	enum:ImGuiPopupFlags_
ImGuiPopupFlags_None	imgui.h	/^    ImGuiPopupFlags_None                    = 0,$/;"	e	enum:ImGuiPopupFlags_
ImGuiPopupPositionPolicy	imgui_internal.h	/^enum ImGuiPopupPositionPolicy$/;"	g
ImGuiPopupPositionPolicy_ComboBox	imgui_internal.h	/^    ImGuiPopupPositionPolicy_ComboBox,$/;"	e	enum:ImGuiPopupPositionPolicy
ImGuiPopupPositionPolicy_Default	imgui_internal.h	/^    ImGuiPopupPositionPolicy_Default,$/;"	e	enum:ImGuiPopupPositionPolicy
ImGuiPopupPositionPolicy_Tooltip	imgui_internal.h	/^    ImGuiPopupPositionPolicy_Tooltip$/;"	e	enum:ImGuiPopupPositionPolicy
ImGuiPtrOrIndex	imgui_internal.h	/^    ImGuiPtrOrIndex(int index)  { Ptr = NULL; Index = index; }$/;"	f	struct:ImGuiPtrOrIndex
ImGuiPtrOrIndex	imgui_internal.h	/^    ImGuiPtrOrIndex(void* ptr)  { Ptr = ptr; Index = -1; }$/;"	f	struct:ImGuiPtrOrIndex
ImGuiPtrOrIndex	imgui_internal.h	/^struct ImGuiPtrOrIndex$/;"	s
ImGuiResizeBorderDef	imgui.cpp	/^struct ImGuiResizeBorderDef$/;"	s	file:
ImGuiResizeGripDef	imgui.cpp	/^struct ImGuiResizeGripDef$/;"	s	file:
ImGuiSelectableFlags	imgui.h	/^typedef int ImGuiSelectableFlags;   \/\/ -> enum ImGuiSelectableFlags_ \/\/ Flags: for Selectable()$/;"	t
ImGuiSelectableFlagsPrivate_	imgui_internal.h	/^enum ImGuiSelectableFlagsPrivate_$/;"	g
ImGuiSelectableFlags_	imgui.h	/^enum ImGuiSelectableFlags_$/;"	g
ImGuiSelectableFlags_AllowDoubleClick	imgui.h	/^    ImGuiSelectableFlags_AllowDoubleClick   = 1 << 2,   \/\/ Generate press events on double clicks too$/;"	e	enum:ImGuiSelectableFlags_
ImGuiSelectableFlags_AllowItemOverlap	imgui.h	/^    ImGuiSelectableFlags_AllowItemOverlap   = 1 << 4    \/\/ (WIP) Hit testing to allow subsequent widgets to overlap this one$/;"	e	enum:ImGuiSelectableFlags_
ImGuiSelectableFlags_Disabled	imgui.h	/^    ImGuiSelectableFlags_Disabled           = 1 << 3,   \/\/ Cannot be selected, display grayed out text$/;"	e	enum:ImGuiSelectableFlags_
ImGuiSelectableFlags_DontClosePopups	imgui.h	/^    ImGuiSelectableFlags_DontClosePopups    = 1 << 0,   \/\/ Clicking this don't close parent popup window$/;"	e	enum:ImGuiSelectableFlags_
ImGuiSelectableFlags_DrawHoveredWhenHeld	imgui_internal.h	/^    ImGuiSelectableFlags_DrawHoveredWhenHeld    = 1 << 24,  \/\/ Always show active when held, even is not hovered. This concept could probably be renamed\/formalized somehow.$/;"	e	enum:ImGuiSelectableFlagsPrivate_
ImGuiSelectableFlags_NoHoldingActiveID	imgui_internal.h	/^    ImGuiSelectableFlags_NoHoldingActiveID      = 1 << 20,$/;"	e	enum:ImGuiSelectableFlagsPrivate_
ImGuiSelectableFlags_NoPadWithHalfSpacing	imgui_internal.h	/^    ImGuiSelectableFlags_NoPadWithHalfSpacing   = 1 << 26   \/\/ Disable padding each side with ItemSpacing * 0.5f$/;"	e	enum:ImGuiSelectableFlagsPrivate_
ImGuiSelectableFlags_None	imgui.h	/^    ImGuiSelectableFlags_None               = 0,$/;"	e	enum:ImGuiSelectableFlags_
ImGuiSelectableFlags_SelectOnClick	imgui_internal.h	/^    ImGuiSelectableFlags_SelectOnClick          = 1 << 21,  \/\/ Override button behavior to react on Click (default is Click+Release)$/;"	e	enum:ImGuiSelectableFlagsPrivate_
ImGuiSelectableFlags_SelectOnRelease	imgui_internal.h	/^    ImGuiSelectableFlags_SelectOnRelease        = 1 << 22,  \/\/ Override button behavior to react on Release (default is Click+Release)$/;"	e	enum:ImGuiSelectableFlagsPrivate_
ImGuiSelectableFlags_SetNavIdOnHover	imgui_internal.h	/^    ImGuiSelectableFlags_SetNavIdOnHover        = 1 << 25,  \/\/ Set Nav\/Focus ID on mouse hover (used by MenuItem)$/;"	e	enum:ImGuiSelectableFlagsPrivate_
ImGuiSelectableFlags_SpanAllColumns	imgui.h	/^    ImGuiSelectableFlags_SpanAllColumns     = 1 << 1,   \/\/ Selectable frame can span all columns (text will still fit in current column)$/;"	e	enum:ImGuiSelectableFlags_
ImGuiSelectableFlags_SpanAvailWidth	imgui_internal.h	/^    ImGuiSelectableFlags_SpanAvailWidth         = 1 << 23,  \/\/ Span all avail width even if we declared less for layout purpose. FIXME: We may be able to remove this (added in 6251d379, 2bcafc86 for menus)$/;"	e	enum:ImGuiSelectableFlagsPrivate_
ImGuiSeparatorFlags	imgui_internal.h	/^typedef int ImGuiSeparatorFlags;        \/\/ -> enum ImGuiSeparatorFlags_     \/\/ Flags: for SeparatorEx()$/;"	t
ImGuiSeparatorFlags_	imgui_internal.h	/^enum ImGuiSeparatorFlags_$/;"	g
ImGuiSeparatorFlags_Horizontal	imgui_internal.h	/^    ImGuiSeparatorFlags_Horizontal          = 1 << 0,   \/\/ Axis default to current layout type, so generally Horizontal unless e.g. in a menu bar$/;"	e	enum:ImGuiSeparatorFlags_
ImGuiSeparatorFlags_None	imgui_internal.h	/^    ImGuiSeparatorFlags_None                = 0,$/;"	e	enum:ImGuiSeparatorFlags_
ImGuiSeparatorFlags_SpanAllColumns	imgui_internal.h	/^    ImGuiSeparatorFlags_SpanAllColumns      = 1 << 2$/;"	e	enum:ImGuiSeparatorFlags_
ImGuiSeparatorFlags_Vertical	imgui_internal.h	/^    ImGuiSeparatorFlags_Vertical            = 1 << 1,$/;"	e	enum:ImGuiSeparatorFlags_
ImGuiSettingsHandler	imgui_internal.h	/^    ImGuiSettingsHandler() { memset(this, 0, sizeof(*this)); }$/;"	f	struct:ImGuiSettingsHandler
ImGuiSettingsHandler	imgui_internal.h	/^struct ImGuiSettingsHandler$/;"	s
ImGuiShrinkWidthItem	imgui_internal.h	/^struct ImGuiShrinkWidthItem$/;"	s
ImGuiSizeCallback	imgui.h	/^typedef void (*ImGuiSizeCallback)(ImGuiSizeCallbackData* data);             \/\/ Callback function for ImGui::SetNextWindowSizeConstraints()$/;"	t
ImGuiSizeCallbackData	imgui.h	/^struct ImGuiSizeCallbackData$/;"	s
ImGuiSliderFlags	imgui.h	/^typedef int ImGuiSliderFlags;       \/\/ -> enum ImGuiSliderFlags_     \/\/ Flags: for DragFloat(), DragInt(), SliderFloat(), SliderInt() etc.$/;"	t
ImGuiSliderFlagsPrivate_	imgui_internal.h	/^enum ImGuiSliderFlagsPrivate_$/;"	g
ImGuiSliderFlags_	imgui.h	/^enum ImGuiSliderFlags_$/;"	g
ImGuiSliderFlags_AlwaysClamp	imgui.h	/^    ImGuiSliderFlags_AlwaysClamp            = 1 << 4,       \/\/ Clamp value to min\/max bounds when input manually with CTRL+Click. By default CTRL+Click allows going out of bounds.$/;"	e	enum:ImGuiSliderFlags_
ImGuiSliderFlags_ClampOnInput	imgui.h	/^    , ImGuiSliderFlags_ClampOnInput = ImGuiSliderFlags_AlwaysClamp \/\/ [renamed in 1.79]$/;"	e	enum:ImGuiSliderFlags_
ImGuiSliderFlags_InvalidMask_	imgui.h	/^    ImGuiSliderFlags_InvalidMask_           = 0x7000000F    \/\/ [Internal] We treat using those bits as being potentially a 'float power' argument from the previous API that has got miscast to this enum, and will trigger an assert if needed.$/;"	e	enum:ImGuiSliderFlags_
ImGuiSliderFlags_Logarithmic	imgui.h	/^    ImGuiSliderFlags_Logarithmic            = 1 << 5,       \/\/ Make the widget logarithmic (linear otherwise). Consider using ImGuiSliderFlags_NoRoundToFormat with this if using a format-string with small amount of digits.$/;"	e	enum:ImGuiSliderFlags_
ImGuiSliderFlags_NoInput	imgui.h	/^    ImGuiSliderFlags_NoInput                = 1 << 7,       \/\/ Disable CTRL+Click or Enter key allowing to input text directly into the widget$/;"	e	enum:ImGuiSliderFlags_
ImGuiSliderFlags_NoRoundToFormat	imgui.h	/^    ImGuiSliderFlags_NoRoundToFormat        = 1 << 6,       \/\/ Disable rounding underlying value to match precision of the display format string (e.g. %.3f values are rounded to those 3 digits)$/;"	e	enum:ImGuiSliderFlags_
ImGuiSliderFlags_None	imgui.h	/^    ImGuiSliderFlags_None                   = 0,$/;"	e	enum:ImGuiSliderFlags_
ImGuiSliderFlags_ReadOnly	imgui_internal.h	/^    ImGuiSliderFlags_ReadOnly               = 1 << 21$/;"	e	enum:ImGuiSliderFlagsPrivate_
ImGuiSliderFlags_Vertical	imgui_internal.h	/^    ImGuiSliderFlags_Vertical               = 1 << 20,  \/\/ Should this slider be orientated vertically?$/;"	e	enum:ImGuiSliderFlagsPrivate_
ImGuiSortDirection	imgui.h	/^typedef int ImGuiSortDirection;     \/\/ -> enum ImGuiSortDirection_   \/\/ Enum: A sorting direction (ascending or descending)$/;"	t
ImGuiSortDirection_	imgui.h	/^enum ImGuiSortDirection_$/;"	g
ImGuiSortDirection_Ascending	imgui.h	/^    ImGuiSortDirection_Ascending    = 1,    \/\/ Ascending = 0->9, A->Z etc.$/;"	e	enum:ImGuiSortDirection_
ImGuiSortDirection_Descending	imgui.h	/^    ImGuiSortDirection_Descending   = 2     \/\/ Descending = 9->0, Z->A etc.$/;"	e	enum:ImGuiSortDirection_
ImGuiSortDirection_None	imgui.h	/^    ImGuiSortDirection_None         = 0,$/;"	e	enum:ImGuiSortDirection_
ImGuiStackSizes	imgui_internal.h	/^    ImGuiStackSizes() { memset(this, 0, sizeof(*this)); }$/;"	f	struct:ImGuiStackSizes
ImGuiStackSizes	imgui_internal.h	/^struct IMGUI_API ImGuiStackSizes$/;"	s
ImGuiStorage	imgui.h	/^struct ImGuiStorage$/;"	s
ImGuiStoragePair	imgui.h	/^        ImGuiStoragePair(ImGuiID _key, float _val_f)    { key = _key; val_f = _val_f; }$/;"	f	struct:ImGuiStorage::ImGuiStoragePair
ImGuiStoragePair	imgui.h	/^        ImGuiStoragePair(ImGuiID _key, int _val_i)      { key = _key; val_i = _val_i; }$/;"	f	struct:ImGuiStorage::ImGuiStoragePair
ImGuiStoragePair	imgui.h	/^        ImGuiStoragePair(ImGuiID _key, void* _val_p)    { key = _key; val_p = _val_p; }$/;"	f	struct:ImGuiStorage::ImGuiStoragePair
ImGuiStoragePair	imgui.h	/^    struct ImGuiStoragePair$/;"	s	struct:ImGuiStorage
ImGuiStyle	imgui.cpp	/^ImGuiStyle::ImGuiStyle()$/;"	f	class:ImGuiStyle
ImGuiStyle	imgui.h	/^struct ImGuiStyle$/;"	s
ImGuiStyleMod	imgui_internal.h	/^    ImGuiStyleMod(ImGuiStyleVar idx, ImVec2 v)  { VarIdx = idx; BackupFloat[0] = v.x; BackupFloat[1] = v.y; }$/;"	f	struct:ImGuiStyleMod
ImGuiStyleMod	imgui_internal.h	/^    ImGuiStyleMod(ImGuiStyleVar idx, float v)   { VarIdx = idx; BackupFloat[0] = v; }$/;"	f	struct:ImGuiStyleMod
ImGuiStyleMod	imgui_internal.h	/^    ImGuiStyleMod(ImGuiStyleVar idx, int v)     { VarIdx = idx; BackupInt[0] = v; }$/;"	f	struct:ImGuiStyleMod
ImGuiStyleMod	imgui_internal.h	/^struct ImGuiStyleMod$/;"	s
ImGuiStyleVar	imgui.h	/^typedef int ImGuiStyleVar;          \/\/ -> enum ImGuiStyleVar_        \/\/ Enum: A variable identifier for styling$/;"	t
ImGuiStyleVarInfo	imgui.cpp	/^struct ImGuiStyleVarInfo$/;"	s	file:
ImGuiStyleVar_	imgui.h	/^enum ImGuiStyleVar_$/;"	g
ImGuiStyleVar_Alpha	imgui.h	/^    ImGuiStyleVar_Alpha,               \/\/ float     Alpha$/;"	e	enum:ImGuiStyleVar_
ImGuiStyleVar_ButtonTextAlign	imgui.h	/^    ImGuiStyleVar_ButtonTextAlign,     \/\/ ImVec2    ButtonTextAlign$/;"	e	enum:ImGuiStyleVar_
ImGuiStyleVar_COUNT	imgui.h	/^    ImGuiStyleVar_COUNT$/;"	e	enum:ImGuiStyleVar_
ImGuiStyleVar_CellPadding	imgui.h	/^    ImGuiStyleVar_CellPadding,         \/\/ ImVec2    CellPadding$/;"	e	enum:ImGuiStyleVar_
ImGuiStyleVar_ChildBorderSize	imgui.h	/^    ImGuiStyleVar_ChildBorderSize,     \/\/ float     ChildBorderSize$/;"	e	enum:ImGuiStyleVar_
ImGuiStyleVar_ChildRounding	imgui.h	/^    ImGuiStyleVar_ChildRounding,       \/\/ float     ChildRounding$/;"	e	enum:ImGuiStyleVar_
ImGuiStyleVar_FrameBorderSize	imgui.h	/^    ImGuiStyleVar_FrameBorderSize,     \/\/ float     FrameBorderSize$/;"	e	enum:ImGuiStyleVar_
ImGuiStyleVar_FramePadding	imgui.h	/^    ImGuiStyleVar_FramePadding,        \/\/ ImVec2    FramePadding$/;"	e	enum:ImGuiStyleVar_
ImGuiStyleVar_FrameRounding	imgui.h	/^    ImGuiStyleVar_FrameRounding,       \/\/ float     FrameRounding$/;"	e	enum:ImGuiStyleVar_
ImGuiStyleVar_GrabMinSize	imgui.h	/^    ImGuiStyleVar_GrabMinSize,         \/\/ float     GrabMinSize$/;"	e	enum:ImGuiStyleVar_
ImGuiStyleVar_GrabRounding	imgui.h	/^    ImGuiStyleVar_GrabRounding,        \/\/ float     GrabRounding$/;"	e	enum:ImGuiStyleVar_
ImGuiStyleVar_IndentSpacing	imgui.h	/^    ImGuiStyleVar_IndentSpacing,       \/\/ float     IndentSpacing$/;"	e	enum:ImGuiStyleVar_
ImGuiStyleVar_ItemInnerSpacing	imgui.h	/^    ImGuiStyleVar_ItemInnerSpacing,    \/\/ ImVec2    ItemInnerSpacing$/;"	e	enum:ImGuiStyleVar_
ImGuiStyleVar_ItemSpacing	imgui.h	/^    ImGuiStyleVar_ItemSpacing,         \/\/ ImVec2    ItemSpacing$/;"	e	enum:ImGuiStyleVar_
ImGuiStyleVar_PopupBorderSize	imgui.h	/^    ImGuiStyleVar_PopupBorderSize,     \/\/ float     PopupBorderSize$/;"	e	enum:ImGuiStyleVar_
ImGuiStyleVar_PopupRounding	imgui.h	/^    ImGuiStyleVar_PopupRounding,       \/\/ float     PopupRounding$/;"	e	enum:ImGuiStyleVar_
ImGuiStyleVar_ScrollbarRounding	imgui.h	/^    ImGuiStyleVar_ScrollbarRounding,   \/\/ float     ScrollbarRounding$/;"	e	enum:ImGuiStyleVar_
ImGuiStyleVar_ScrollbarSize	imgui.h	/^    ImGuiStyleVar_ScrollbarSize,       \/\/ float     ScrollbarSize$/;"	e	enum:ImGuiStyleVar_
ImGuiStyleVar_SelectableTextAlign	imgui.h	/^    ImGuiStyleVar_SelectableTextAlign, \/\/ ImVec2    SelectableTextAlign$/;"	e	enum:ImGuiStyleVar_
ImGuiStyleVar_TabRounding	imgui.h	/^    ImGuiStyleVar_TabRounding,         \/\/ float     TabRounding$/;"	e	enum:ImGuiStyleVar_
ImGuiStyleVar_WindowBorderSize	imgui.h	/^    ImGuiStyleVar_WindowBorderSize,    \/\/ float     WindowBorderSize$/;"	e	enum:ImGuiStyleVar_
ImGuiStyleVar_WindowMinSize	imgui.h	/^    ImGuiStyleVar_WindowMinSize,       \/\/ ImVec2    WindowMinSize$/;"	e	enum:ImGuiStyleVar_
ImGuiStyleVar_WindowPadding	imgui.h	/^    ImGuiStyleVar_WindowPadding,       \/\/ ImVec2    WindowPadding$/;"	e	enum:ImGuiStyleVar_
ImGuiStyleVar_WindowRounding	imgui.h	/^    ImGuiStyleVar_WindowRounding,      \/\/ float     WindowRounding$/;"	e	enum:ImGuiStyleVar_
ImGuiStyleVar_WindowTitleAlign	imgui.h	/^    ImGuiStyleVar_WindowTitleAlign,    \/\/ ImVec2    WindowTitleAlign$/;"	e	enum:ImGuiStyleVar_
ImGuiTabBar	imgui_internal.h	/^struct ImGuiTabBar$/;"	s
ImGuiTabBar	imgui_widgets.cpp	/^ImGuiTabBar::ImGuiTabBar()$/;"	f	class:ImGuiTabBar
ImGuiTabBarFlags	imgui.h	/^typedef int ImGuiTabBarFlags;       \/\/ -> enum ImGuiTabBarFlags_     \/\/ Flags: for BeginTabBar()$/;"	t
ImGuiTabBarFlagsPrivate_	imgui_internal.h	/^enum ImGuiTabBarFlagsPrivate_$/;"	g
ImGuiTabBarFlags_	imgui.h	/^enum ImGuiTabBarFlags_$/;"	g
ImGuiTabBarFlags_AutoSelectNewTabs	imgui.h	/^    ImGuiTabBarFlags_AutoSelectNewTabs              = 1 << 1,   \/\/ Automatically select new tabs when they appear$/;"	e	enum:ImGuiTabBarFlags_
ImGuiTabBarFlags_DockNode	imgui_internal.h	/^    ImGuiTabBarFlags_DockNode                   = 1 << 20,  \/\/ Part of a dock node [we don't use this in the master branch but it facilitate branch syncing to keep this around]$/;"	e	enum:ImGuiTabBarFlagsPrivate_
ImGuiTabBarFlags_FittingPolicyDefault_	imgui.h	/^    ImGuiTabBarFlags_FittingPolicyDefault_          = ImGuiTabBarFlags_FittingPolicyResizeDown$/;"	e	enum:ImGuiTabBarFlags_
ImGuiTabBarFlags_FittingPolicyMask_	imgui.h	/^    ImGuiTabBarFlags_FittingPolicyMask_             = ImGuiTabBarFlags_FittingPolicyResizeDown | ImGuiTabBarFlags_FittingPolicyScroll,$/;"	e	enum:ImGuiTabBarFlags_
ImGuiTabBarFlags_FittingPolicyResizeDown	imgui.h	/^    ImGuiTabBarFlags_FittingPolicyResizeDown        = 1 << 6,   \/\/ Resize tabs when they don't fit$/;"	e	enum:ImGuiTabBarFlags_
ImGuiTabBarFlags_FittingPolicyScroll	imgui.h	/^    ImGuiTabBarFlags_FittingPolicyScroll            = 1 << 7,   \/\/ Add scroll buttons when tabs don't fit$/;"	e	enum:ImGuiTabBarFlags_
ImGuiTabBarFlags_IsFocused	imgui_internal.h	/^    ImGuiTabBarFlags_IsFocused                  = 1 << 21,$/;"	e	enum:ImGuiTabBarFlagsPrivate_
ImGuiTabBarFlags_NoCloseWithMiddleMouseButton	imgui.h	/^    ImGuiTabBarFlags_NoCloseWithMiddleMouseButton   = 1 << 3,   \/\/ Disable behavior of closing tabs (that are submitted with p_open != NULL) with middle mouse button. You can still repro this behavior on user's side with if (IsItemHovered() && IsMouseClicked(2)) *p_open = false.$/;"	e	enum:ImGuiTabBarFlags_
ImGuiTabBarFlags_NoTabListScrollingButtons	imgui.h	/^    ImGuiTabBarFlags_NoTabListScrollingButtons      = 1 << 4,   \/\/ Disable scrolling buttons (apply when fitting policy is ImGuiTabBarFlags_FittingPolicyScroll)$/;"	e	enum:ImGuiTabBarFlags_
ImGuiTabBarFlags_NoTooltip	imgui.h	/^    ImGuiTabBarFlags_NoTooltip                      = 1 << 5,   \/\/ Disable tooltips when hovering a tab$/;"	e	enum:ImGuiTabBarFlags_
ImGuiTabBarFlags_None	imgui.h	/^    ImGuiTabBarFlags_None                           = 0,$/;"	e	enum:ImGuiTabBarFlags_
ImGuiTabBarFlags_Reorderable	imgui.h	/^    ImGuiTabBarFlags_Reorderable                    = 1 << 0,   \/\/ Allow manually dragging tabs to re-order them + New tabs are appended at the end of list$/;"	e	enum:ImGuiTabBarFlags_
ImGuiTabBarFlags_SaveSettings	imgui_internal.h	/^    ImGuiTabBarFlags_SaveSettings               = 1 << 22   \/\/ FIXME: Settings are handled by the docking system, this only request the tab bar to mark settings dirty when reordering tabs$/;"	e	enum:ImGuiTabBarFlagsPrivate_
ImGuiTabBarFlags_TabListPopupButton	imgui.h	/^    ImGuiTabBarFlags_TabListPopupButton             = 1 << 2,   \/\/ Disable buttons to open the tab list popup$/;"	e	enum:ImGuiTabBarFlags_
ImGuiTabBarSection	imgui_widgets.cpp	/^    ImGuiTabBarSection() { memset(this, 0, sizeof(*this)); }$/;"	f	struct:ImGuiTabBarSection
ImGuiTabBarSection	imgui_widgets.cpp	/^struct ImGuiTabBarSection$/;"	s	file:
ImGuiTabItem	imgui_internal.h	/^    ImGuiTabItem()      { memset(this, 0, sizeof(*this)); LastFrameVisible = LastFrameSelected = -1; NameOffset = BeginOrder = IndexDuringLayout = -1; }$/;"	f	struct:ImGuiTabItem
ImGuiTabItem	imgui_internal.h	/^struct ImGuiTabItem$/;"	s
ImGuiTabItemFlags	imgui.h	/^typedef int ImGuiTabItemFlags;      \/\/ -> enum ImGuiTabItemFlags_    \/\/ Flags: for BeginTabItem()$/;"	t
ImGuiTabItemFlagsPrivate_	imgui_internal.h	/^enum ImGuiTabItemFlagsPrivate_$/;"	g
ImGuiTabItemFlags_	imgui.h	/^enum ImGuiTabItemFlags_$/;"	g
ImGuiTabItemFlags_Button	imgui_internal.h	/^    ImGuiTabItemFlags_Button                    = 1 << 21   \/\/ Used by TabItemButton, change the tab item behavior to mimic a button$/;"	e	enum:ImGuiTabItemFlagsPrivate_
ImGuiTabItemFlags_Leading	imgui.h	/^    ImGuiTabItemFlags_Leading                       = 1 << 6,   \/\/ Enforce the tab position to the left of the tab bar (after the tab list popup button)$/;"	e	enum:ImGuiTabItemFlags_
ImGuiTabItemFlags_NoCloseButton	imgui_internal.h	/^    ImGuiTabItemFlags_NoCloseButton             = 1 << 20,  \/\/ Track whether p_open was set or not (we'll need this info on the next frame to recompute ContentWidth during layout)$/;"	e	enum:ImGuiTabItemFlagsPrivate_
ImGuiTabItemFlags_NoCloseWithMiddleMouseButton	imgui.h	/^    ImGuiTabItemFlags_NoCloseWithMiddleMouseButton  = 1 << 2,   \/\/ Disable behavior of closing tabs (that are submitted with p_open != NULL) with middle mouse button. You can still repro this behavior on user's side with if (IsItemHovered() && IsMouseClicked(2)) *p_open = false.$/;"	e	enum:ImGuiTabItemFlags_
ImGuiTabItemFlags_NoPushId	imgui.h	/^    ImGuiTabItemFlags_NoPushId                      = 1 << 3,   \/\/ Don't call PushID(tab->ID)\/PopID() on BeginTabItem()\/EndTabItem()$/;"	e	enum:ImGuiTabItemFlags_
ImGuiTabItemFlags_NoReorder	imgui.h	/^    ImGuiTabItemFlags_NoReorder                     = 1 << 5,   \/\/ Disable reordering this tab or having another tab cross over this tab$/;"	e	enum:ImGuiTabItemFlags_
ImGuiTabItemFlags_NoTooltip	imgui.h	/^    ImGuiTabItemFlags_NoTooltip                     = 1 << 4,   \/\/ Disable tooltip for the given tab$/;"	e	enum:ImGuiTabItemFlags_
ImGuiTabItemFlags_None	imgui.h	/^    ImGuiTabItemFlags_None                          = 0,$/;"	e	enum:ImGuiTabItemFlags_
ImGuiTabItemFlags_SectionMask_	imgui_internal.h	/^    ImGuiTabItemFlags_SectionMask_              = ImGuiTabItemFlags_Leading | ImGuiTabItemFlags_Trailing,$/;"	e	enum:ImGuiTabItemFlagsPrivate_
ImGuiTabItemFlags_SetSelected	imgui.h	/^    ImGuiTabItemFlags_SetSelected                   = 1 << 1,   \/\/ Trigger flag to programmatically make the tab selected when calling BeginTabItem()$/;"	e	enum:ImGuiTabItemFlags_
ImGuiTabItemFlags_Trailing	imgui.h	/^    ImGuiTabItemFlags_Trailing                      = 1 << 7    \/\/ Enforce the tab position to the right of the tab bar (before the scrolling buttons)$/;"	e	enum:ImGuiTabItemFlags_
ImGuiTabItemFlags_UnsavedDocument	imgui.h	/^    ImGuiTabItemFlags_UnsavedDocument               = 1 << 0,   \/\/ Append '*' to title without affecting the ID, as a convenience to avoid using the ### operator. Also: tab is selected on closure and closure is deferred by one frame to allow code to undo it without flicker.$/;"	e	enum:ImGuiTabItemFlags_
ImGuiTable	imgui_internal.h	/^    IMGUI_API ImGuiTable()      { memset(this, 0, sizeof(*this)); LastFrameActive = -1; }$/;"	f	struct:ImGuiTable
ImGuiTable	imgui_internal.h	/^struct ImGuiTable$/;"	s
ImGuiTableBgTarget	imgui.h	/^typedef int ImGuiTableBgTarget;     \/\/ -> enum ImGuiTableBgTarget_   \/\/ Enum: A color target for TableSetBgColor()$/;"	t
ImGuiTableBgTarget_	imgui.h	/^enum ImGuiTableBgTarget_$/;"	g
ImGuiTableBgTarget_CellBg	imgui.h	/^    ImGuiTableBgTarget_CellBg                       = 3         \/\/ Set cell background color (top-most color)$/;"	e	enum:ImGuiTableBgTarget_
ImGuiTableBgTarget_None	imgui.h	/^    ImGuiTableBgTarget_None                         = 0,$/;"	e	enum:ImGuiTableBgTarget_
ImGuiTableBgTarget_RowBg0	imgui.h	/^    ImGuiTableBgTarget_RowBg0                       = 1,        \/\/ Set row background color 0 (generally used for background, automatically set when ImGuiTableFlags_RowBg is used)$/;"	e	enum:ImGuiTableBgTarget_
ImGuiTableBgTarget_RowBg1	imgui.h	/^    ImGuiTableBgTarget_RowBg1                       = 2,        \/\/ Set row background color 1 (generally used for selection marking)$/;"	e	enum:ImGuiTableBgTarget_
ImGuiTableCellData	imgui_internal.h	/^struct ImGuiTableCellData$/;"	s
ImGuiTableColumn	imgui_internal.h	/^    ImGuiTableColumn()$/;"	f	struct:ImGuiTableColumn
ImGuiTableColumn	imgui_internal.h	/^struct ImGuiTableColumn$/;"	s
ImGuiTableColumnFlags	imgui.h	/^typedef int ImGuiTableColumnFlags;  \/\/ -> enum ImGuiTableColumnFlags_\/\/ Flags: For TableSetupColumn()$/;"	t
ImGuiTableColumnFlags_	imgui.h	/^enum ImGuiTableColumnFlags_$/;"	g
ImGuiTableColumnFlags_DefaultHide	imgui.h	/^    ImGuiTableColumnFlags_DefaultHide           = 1 << 0,   \/\/ Default as a hidden\/disabled column.$/;"	e	enum:ImGuiTableColumnFlags_
ImGuiTableColumnFlags_DefaultSort	imgui.h	/^    ImGuiTableColumnFlags_DefaultSort           = 1 << 1,   \/\/ Default as a sorting column.$/;"	e	enum:ImGuiTableColumnFlags_
ImGuiTableColumnFlags_IndentDisable	imgui.h	/^    ImGuiTableColumnFlags_IndentDisable         = 1 << 15,  \/\/ Ignore current Indent value when entering cell (default for columns > 0). Indentation changes _within_ the cell will still be honored.$/;"	e	enum:ImGuiTableColumnFlags_
ImGuiTableColumnFlags_IndentEnable	imgui.h	/^    ImGuiTableColumnFlags_IndentEnable          = 1 << 14,  \/\/ Use current Indent value when entering cell (default for column 0).$/;"	e	enum:ImGuiTableColumnFlags_
ImGuiTableColumnFlags_IndentMask_	imgui.h	/^    ImGuiTableColumnFlags_IndentMask_           = ImGuiTableColumnFlags_IndentEnable | ImGuiTableColumnFlags_IndentDisable,$/;"	e	enum:ImGuiTableColumnFlags_
ImGuiTableColumnFlags_IsEnabled	imgui.h	/^    ImGuiTableColumnFlags_IsEnabled             = 1 << 20,  \/\/ Status: is enabled == not hidden by user\/api (referred to as "Hide" in _DefaultHide and _NoHide) flags.$/;"	e	enum:ImGuiTableColumnFlags_
ImGuiTableColumnFlags_IsHovered	imgui.h	/^    ImGuiTableColumnFlags_IsHovered             = 1 << 23,  \/\/ Status: is hovered by mouse$/;"	e	enum:ImGuiTableColumnFlags_
ImGuiTableColumnFlags_IsSorted	imgui.h	/^    ImGuiTableColumnFlags_IsSorted              = 1 << 22,  \/\/ Status: is currently part of the sort specs$/;"	e	enum:ImGuiTableColumnFlags_
ImGuiTableColumnFlags_IsVisible	imgui.h	/^    ImGuiTableColumnFlags_IsVisible             = 1 << 21,  \/\/ Status: is visible == is enabled AND not clipped by scrolling.$/;"	e	enum:ImGuiTableColumnFlags_
ImGuiTableColumnFlags_NoClip	imgui.h	/^    ImGuiTableColumnFlags_NoClip                = 1 << 7,   \/\/ Disable clipping for this column (all NoClip columns will render in a same draw command).$/;"	e	enum:ImGuiTableColumnFlags_
ImGuiTableColumnFlags_NoDirectResize_	imgui.h	/^    ImGuiTableColumnFlags_NoDirectResize_       = 1 << 30   \/\/ [Internal] Disable user resizing this column directly (it may however we resized indirectly from its left edge)$/;"	e	enum:ImGuiTableColumnFlags_
ImGuiTableColumnFlags_NoHeaderWidth	imgui.h	/^    ImGuiTableColumnFlags_NoHeaderWidth         = 1 << 11,  \/\/ Disable header text width contribution to automatic column width.$/;"	e	enum:ImGuiTableColumnFlags_
ImGuiTableColumnFlags_NoHide	imgui.h	/^    ImGuiTableColumnFlags_NoHide                = 1 << 6,   \/\/ Disable ability to hide\/disable this column.$/;"	e	enum:ImGuiTableColumnFlags_
ImGuiTableColumnFlags_NoReorder	imgui.h	/^    ImGuiTableColumnFlags_NoReorder             = 1 << 5,   \/\/ Disable manual reordering this column, this will also prevent other columns from crossing over this column.$/;"	e	enum:ImGuiTableColumnFlags_
ImGuiTableColumnFlags_NoResize	imgui.h	/^    ImGuiTableColumnFlags_NoResize              = 1 << 4,   \/\/ Disable manual resizing.$/;"	e	enum:ImGuiTableColumnFlags_
ImGuiTableColumnFlags_NoSort	imgui.h	/^    ImGuiTableColumnFlags_NoSort                = 1 << 8,   \/\/ Disable ability to sort on this field (even if ImGuiTableFlags_Sortable is set on the table).$/;"	e	enum:ImGuiTableColumnFlags_
ImGuiTableColumnFlags_NoSortAscending	imgui.h	/^    ImGuiTableColumnFlags_NoSortAscending       = 1 << 9,   \/\/ Disable ability to sort in the ascending direction.$/;"	e	enum:ImGuiTableColumnFlags_
ImGuiTableColumnFlags_NoSortDescending	imgui.h	/^    ImGuiTableColumnFlags_NoSortDescending      = 1 << 10,  \/\/ Disable ability to sort in the descending direction.$/;"	e	enum:ImGuiTableColumnFlags_
ImGuiTableColumnFlags_None	imgui.h	/^    ImGuiTableColumnFlags_None                  = 0,$/;"	e	enum:ImGuiTableColumnFlags_
ImGuiTableColumnFlags_PreferSortAscending	imgui.h	/^    ImGuiTableColumnFlags_PreferSortAscending   = 1 << 12,  \/\/ Make the initial sort direction Ascending when first sorting on this column (default).$/;"	e	enum:ImGuiTableColumnFlags_
ImGuiTableColumnFlags_PreferSortDescending	imgui.h	/^    ImGuiTableColumnFlags_PreferSortDescending  = 1 << 13,  \/\/ Make the initial sort direction Descending when first sorting on this column.$/;"	e	enum:ImGuiTableColumnFlags_
ImGuiTableColumnFlags_StatusMask_	imgui.h	/^    ImGuiTableColumnFlags_StatusMask_           = ImGuiTableColumnFlags_IsEnabled | ImGuiTableColumnFlags_IsVisible | ImGuiTableColumnFlags_IsSorted | ImGuiTableColumnFlags_IsHovered,$/;"	e	enum:ImGuiTableColumnFlags_
ImGuiTableColumnFlags_WidthFixed	imgui.h	/^    ImGuiTableColumnFlags_WidthFixed            = 1 << 3,   \/\/ Column will not stretch. Preferable with horizontal scrolling enabled (default if table sizing policy is _SizingFixedFit and table is resizable).$/;"	e	enum:ImGuiTableColumnFlags_
ImGuiTableColumnFlags_WidthMask_	imgui.h	/^    ImGuiTableColumnFlags_WidthMask_            = ImGuiTableColumnFlags_WidthStretch | ImGuiTableColumnFlags_WidthFixed,$/;"	e	enum:ImGuiTableColumnFlags_
ImGuiTableColumnFlags_WidthStretch	imgui.h	/^    ImGuiTableColumnFlags_WidthStretch          = 1 << 2,   \/\/ Column will stretch. Preferable with horizontal scrolling disabled (default if table sizing policy is _SizingStretchSame or _SizingStretchProp).$/;"	e	enum:ImGuiTableColumnFlags_
ImGuiTableColumnIdx	imgui_internal.h	/^typedef ImS8 ImGuiTableColumnIdx;$/;"	t
ImGuiTableColumnSettings	imgui_internal.h	/^    ImGuiTableColumnSettings()$/;"	f	struct:ImGuiTableColumnSettings
ImGuiTableColumnSettings	imgui_internal.h	/^struct ImGuiTableColumnSettings$/;"	s
ImGuiTableColumnSortSpecs	imgui.h	/^    ImGuiTableColumnSortSpecs() { memset(this, 0, sizeof(*this)); }$/;"	f	struct:ImGuiTableColumnSortSpecs
ImGuiTableColumnSortSpecs	imgui.h	/^struct ImGuiTableColumnSortSpecs$/;"	s
ImGuiTableDrawChannelIdx	imgui_internal.h	/^typedef ImU8 ImGuiTableDrawChannelIdx;$/;"	t
ImGuiTableFlags	imgui.h	/^typedef int ImGuiTableFlags;        \/\/ -> enum ImGuiTableFlags_      \/\/ Flags: For BeginTable()$/;"	t
ImGuiTableFlags_	imgui.h	/^enum ImGuiTableFlags_$/;"	g
ImGuiTableFlags_Borders	imgui.h	/^    ImGuiTableFlags_Borders                    = ImGuiTableFlags_BordersInner | ImGuiTableFlags_BordersOuter,   \/\/ Draw all borders.$/;"	e	enum:ImGuiTableFlags_
ImGuiTableFlags_BordersH	imgui.h	/^    ImGuiTableFlags_BordersH                   = ImGuiTableFlags_BordersInnerH | ImGuiTableFlags_BordersOuterH, \/\/ Draw horizontal borders.$/;"	e	enum:ImGuiTableFlags_
ImGuiTableFlags_BordersInner	imgui.h	/^    ImGuiTableFlags_BordersInner               = ImGuiTableFlags_BordersInnerV | ImGuiTableFlags_BordersInnerH, \/\/ Draw inner borders.$/;"	e	enum:ImGuiTableFlags_
ImGuiTableFlags_BordersInnerH	imgui.h	/^    ImGuiTableFlags_BordersInnerH              = 1 << 7,   \/\/ Draw horizontal borders between rows.$/;"	e	enum:ImGuiTableFlags_
ImGuiTableFlags_BordersInnerV	imgui.h	/^    ImGuiTableFlags_BordersInnerV              = 1 << 9,   \/\/ Draw vertical borders between columns.$/;"	e	enum:ImGuiTableFlags_
ImGuiTableFlags_BordersOuter	imgui.h	/^    ImGuiTableFlags_BordersOuter               = ImGuiTableFlags_BordersOuterV | ImGuiTableFlags_BordersOuterH, \/\/ Draw outer borders.$/;"	e	enum:ImGuiTableFlags_
ImGuiTableFlags_BordersOuterH	imgui.h	/^    ImGuiTableFlags_BordersOuterH              = 1 << 8,   \/\/ Draw horizontal borders at the top and bottom.$/;"	e	enum:ImGuiTableFlags_
ImGuiTableFlags_BordersOuterV	imgui.h	/^    ImGuiTableFlags_BordersOuterV              = 1 << 10,  \/\/ Draw vertical borders on the left and right sides.$/;"	e	enum:ImGuiTableFlags_
ImGuiTableFlags_BordersV	imgui.h	/^    ImGuiTableFlags_BordersV                   = ImGuiTableFlags_BordersInnerV | ImGuiTableFlags_BordersOuterV, \/\/ Draw vertical borders.$/;"	e	enum:ImGuiTableFlags_
ImGuiTableFlags_ContextMenuInBody	imgui.h	/^    ImGuiTableFlags_ContextMenuInBody          = 1 << 5,   \/\/ Right-click on columns body\/contents will display table context menu. By default it is available in TableHeadersRow().$/;"	e	enum:ImGuiTableFlags_
ImGuiTableFlags_Hideable	imgui.h	/^    ImGuiTableFlags_Hideable                   = 1 << 2,   \/\/ Enable hiding\/disabling columns in context menu.$/;"	e	enum:ImGuiTableFlags_
ImGuiTableFlags_NoBordersInBody	imgui.h	/^    ImGuiTableFlags_NoBordersInBody            = 1 << 11,  \/\/ [ALPHA] Disable vertical borders in columns Body (borders will always appears in Headers). -> May move to style$/;"	e	enum:ImGuiTableFlags_
ImGuiTableFlags_NoBordersInBodyUntilResize	imgui.h	/^    ImGuiTableFlags_NoBordersInBodyUntilResize = 1 << 12,  \/\/ [ALPHA] Disable vertical borders in columns Body until hovered for resize (borders will always appears in Headers). -> May move to style$/;"	e	enum:ImGuiTableFlags_
ImGuiTableFlags_NoClip	imgui.h	/^    ImGuiTableFlags_NoClip                     = 1 << 20,  \/\/ Disable clipping rectangle for every individual columns (reduce draw command count, items will be able to overflow into other columns). Generally incompatible with TableSetupScrollFreeze().$/;"	e	enum:ImGuiTableFlags_
ImGuiTableFlags_NoHostExtendX	imgui.h	/^    ImGuiTableFlags_NoHostExtendX              = 1 << 16,  \/\/ Make outer width auto-fit to columns, overriding outer_size.x value. Only available when ScrollX\/ScrollY are disabled and Stretch columns are not used.$/;"	e	enum:ImGuiTableFlags_
ImGuiTableFlags_NoHostExtendY	imgui.h	/^    ImGuiTableFlags_NoHostExtendY              = 1 << 17,  \/\/ Make outer height stop exactly at outer_size.y (prevent auto-extending table past the limit). Only available when ScrollX\/ScrollY are disabled. Data below the limit will be clipped and not visible.$/;"	e	enum:ImGuiTableFlags_
ImGuiTableFlags_NoKeepColumnsVisible	imgui.h	/^    ImGuiTableFlags_NoKeepColumnsVisible       = 1 << 18,  \/\/ Disable keeping column always minimally visible when ScrollX is off and table gets too small. Not recommended if columns are resizable.$/;"	e	enum:ImGuiTableFlags_
ImGuiTableFlags_NoPadInnerX	imgui.h	/^    ImGuiTableFlags_NoPadInnerX                = 1 << 23,  \/\/ Disable inner padding between columns (double inner padding if BordersOuterV is on, single inner padding if BordersOuterV is off).$/;"	e	enum:ImGuiTableFlags_
ImGuiTableFlags_NoPadOuterX	imgui.h	/^    ImGuiTableFlags_NoPadOuterX                = 1 << 22,  \/\/ Default if BordersOuterV is off. Disable outer-most padding.$/;"	e	enum:ImGuiTableFlags_
ImGuiTableFlags_NoSavedSettings	imgui.h	/^    ImGuiTableFlags_NoSavedSettings            = 1 << 4,   \/\/ Disable persisting columns order, width and sort settings in the .ini file.$/;"	e	enum:ImGuiTableFlags_
ImGuiTableFlags_None	imgui.h	/^    ImGuiTableFlags_None                       = 0,$/;"	e	enum:ImGuiTableFlags_
ImGuiTableFlags_PadOuterX	imgui.h	/^    ImGuiTableFlags_PadOuterX                  = 1 << 21,  \/\/ Default if BordersOuterV is on. Enable outer-most padding. Generally desirable if you have headers.$/;"	e	enum:ImGuiTableFlags_
ImGuiTableFlags_PreciseWidths	imgui.h	/^    ImGuiTableFlags_PreciseWidths              = 1 << 19,  \/\/ Disable distributing remainder width to stretched columns (width allocation on a 100-wide table with 3 columns: Without this flag: 33,33,34. With this flag: 33,33,33). With larger number of columns, resizing will appear to be less smooth.$/;"	e	enum:ImGuiTableFlags_
ImGuiTableFlags_Reorderable	imgui.h	/^    ImGuiTableFlags_Reorderable                = 1 << 1,   \/\/ Enable reordering columns in header row (need calling TableSetupColumn() + TableHeadersRow() to display headers)$/;"	e	enum:ImGuiTableFlags_
ImGuiTableFlags_Resizable	imgui.h	/^    ImGuiTableFlags_Resizable                  = 1 << 0,   \/\/ Enable resizing columns.$/;"	e	enum:ImGuiTableFlags_
ImGuiTableFlags_RowBg	imgui.h	/^    ImGuiTableFlags_RowBg                      = 1 << 6,   \/\/ Set each RowBg color with ImGuiCol_TableRowBg or ImGuiCol_TableRowBgAlt (equivalent of calling TableSetBgColor with ImGuiTableBgFlags_RowBg0 on each row manually)$/;"	e	enum:ImGuiTableFlags_
ImGuiTableFlags_ScrollX	imgui.h	/^    ImGuiTableFlags_ScrollX                    = 1 << 24,  \/\/ Enable horizontal scrolling. Require 'outer_size' parameter of BeginTable() to specify the container size. Changes default sizing policy. Because this create a child window, ScrollY is currently generally recommended when using ScrollX.$/;"	e	enum:ImGuiTableFlags_
ImGuiTableFlags_ScrollY	imgui.h	/^    ImGuiTableFlags_ScrollY                    = 1 << 25,  \/\/ Enable vertical scrolling. Require 'outer_size' parameter of BeginTable() to specify the container size.$/;"	e	enum:ImGuiTableFlags_
ImGuiTableFlags_SizingFixedFit	imgui.h	/^    ImGuiTableFlags_SizingFixedFit             = 1 << 13,  \/\/ Columns default to _WidthFixed or _WidthAuto (if resizable or not resizable), matching contents width.$/;"	e	enum:ImGuiTableFlags_
ImGuiTableFlags_SizingFixedSame	imgui.h	/^    ImGuiTableFlags_SizingFixedSame            = 2 << 13,  \/\/ Columns default to _WidthFixed or _WidthAuto (if resizable or not resizable), matching the maximum contents width of all columns. Implicitly enable ImGuiTableFlags_NoKeepColumnsVisible.$/;"	e	enum:ImGuiTableFlags_
ImGuiTableFlags_SizingMask_	imgui.h	/^    ImGuiTableFlags_SizingMask_                = ImGuiTableFlags_SizingFixedFit | ImGuiTableFlags_SizingFixedSame | ImGuiTableFlags_SizingStretchProp | ImGuiTableFlags_SizingStretchSame$/;"	e	enum:ImGuiTableFlags_
ImGuiTableFlags_SizingStretchProp	imgui.h	/^    ImGuiTableFlags_SizingStretchProp          = 3 << 13,  \/\/ Columns default to _WidthStretch with default weights proportional to each columns contents widths.$/;"	e	enum:ImGuiTableFlags_
ImGuiTableFlags_SizingStretchSame	imgui.h	/^    ImGuiTableFlags_SizingStretchSame          = 4 << 13,  \/\/ Columns default to _WidthStretch with default weights all equal, unless overridden by TableSetupColumn().$/;"	e	enum:ImGuiTableFlags_
ImGuiTableFlags_SortMulti	imgui.h	/^    ImGuiTableFlags_SortMulti                  = 1 << 26,  \/\/ Hold shift when clicking headers to sort on multiple column. TableGetSortSpecs() may return specs where (SpecsCount > 1).$/;"	e	enum:ImGuiTableFlags_
ImGuiTableFlags_SortTristate	imgui.h	/^    ImGuiTableFlags_SortTristate               = 1 << 27,  \/\/ Allow no sorting, disable default sorting. TableGetSortSpecs() may return specs where (SpecsCount == 0).$/;"	e	enum:ImGuiTableFlags_
ImGuiTableFlags_Sortable	imgui.h	/^    ImGuiTableFlags_Sortable                   = 1 << 3,   \/\/ Enable sorting. Call TableGetSortSpecs() to obtain sort specs. Also see ImGuiTableFlags_SortMulti and ImGuiTableFlags_SortTristate.$/;"	e	enum:ImGuiTableFlags_
ImGuiTableRowFlags	imgui.h	/^typedef int ImGuiTableRowFlags;     \/\/ -> enum ImGuiTableRowFlags_   \/\/ Flags: For TableNextRow()$/;"	t
ImGuiTableRowFlags_	imgui.h	/^enum ImGuiTableRowFlags_$/;"	g
ImGuiTableRowFlags_Headers	imgui.h	/^    ImGuiTableRowFlags_Headers                      = 1 << 0    \/\/ Identify header row (set default background color + width of its contents accounted different for auto column width)$/;"	e	enum:ImGuiTableRowFlags_
ImGuiTableRowFlags_None	imgui.h	/^    ImGuiTableRowFlags_None                         = 0,$/;"	e	enum:ImGuiTableRowFlags_
ImGuiTableSettings	imgui_internal.h	/^    ImGuiTableSettings()        { memset(this, 0, sizeof(*this)); }$/;"	f	struct:ImGuiTableSettings
ImGuiTableSettings	imgui_internal.h	/^struct ImGuiTableSettings$/;"	s
ImGuiTableSortSpecs	imgui.h	/^    ImGuiTableSortSpecs()       { memset(this, 0, sizeof(*this)); }$/;"	f	struct:ImGuiTableSortSpecs
ImGuiTableSortSpecs	imgui.h	/^struct ImGuiTableSortSpecs$/;"	s
ImGuiTextBuffer	imgui.h	/^    ImGuiTextBuffer()   { }$/;"	f	struct:ImGuiTextBuffer
ImGuiTextBuffer	imgui.h	/^struct ImGuiTextBuffer$/;"	s
ImGuiTextFilter	imgui.cpp	/^ImGuiTextFilter::ImGuiTextFilter(const char* default_filter)$/;"	f	class:ImGuiTextFilter
ImGuiTextFilter	imgui.h	/^struct ImGuiTextFilter$/;"	s
ImGuiTextFlags	imgui_internal.h	/^typedef int ImGuiTextFlags;             \/\/ -> enum ImGuiTextFlags_          \/\/ Flags: for TextEx()$/;"	t
ImGuiTextFlags_	imgui_internal.h	/^enum ImGuiTextFlags_$/;"	g
ImGuiTextFlags_NoWidthForLargeClippedText	imgui_internal.h	/^    ImGuiTextFlags_NoWidthForLargeClippedText = 1 << 0$/;"	e	enum:ImGuiTextFlags_
ImGuiTextFlags_None	imgui_internal.h	/^    ImGuiTextFlags_None = 0,$/;"	e	enum:ImGuiTextFlags_
ImGuiTextRange	imgui.h	/^        ImGuiTextRange()                                { b = e = NULL; }$/;"	f	struct:ImGuiTextFilter::ImGuiTextRange
ImGuiTextRange	imgui.h	/^        ImGuiTextRange(const char* _b, const char* _e)  { b = _b; e = _e; }$/;"	f	struct:ImGuiTextFilter::ImGuiTextRange
ImGuiTextRange	imgui.h	/^    struct ImGuiTextRange$/;"	s	struct:ImGuiTextFilter
ImGuiTooltipFlags	imgui_internal.h	/^typedef int ImGuiTooltipFlags;          \/\/ -> enum ImGuiTooltipFlags_       \/\/ Flags: for BeginTooltipEx()$/;"	t
ImGuiTooltipFlags_	imgui_internal.h	/^enum ImGuiTooltipFlags_$/;"	g
ImGuiTooltipFlags_None	imgui_internal.h	/^    ImGuiTooltipFlags_None = 0,$/;"	e	enum:ImGuiTooltipFlags_
ImGuiTooltipFlags_OverridePreviousTooltip	imgui_internal.h	/^    ImGuiTooltipFlags_OverridePreviousTooltip = 1 << 0      \/\/ Override will clear\/ignore previously submitted tooltip (defaults to append)$/;"	e	enum:ImGuiTooltipFlags_
ImGuiTreeNodeFlags	imgui.h	/^typedef int ImGuiTreeNodeFlags;     \/\/ -> enum ImGuiTreeNodeFlags_   \/\/ Flags: for TreeNode(), TreeNodeEx(), CollapsingHeader()$/;"	t
ImGuiTreeNodeFlagsPrivate_	imgui_internal.h	/^enum ImGuiTreeNodeFlagsPrivate_$/;"	g
ImGuiTreeNodeFlags_	imgui.h	/^enum ImGuiTreeNodeFlags_$/;"	g
ImGuiTreeNodeFlags_AllowItemOverlap	imgui.h	/^    ImGuiTreeNodeFlags_AllowItemOverlap     = 1 << 2,   \/\/ Hit testing to allow subsequent widgets to overlap this one$/;"	e	enum:ImGuiTreeNodeFlags_
ImGuiTreeNodeFlags_Bullet	imgui.h	/^    ImGuiTreeNodeFlags_Bullet               = 1 << 9,   \/\/ Display a bullet instead of arrow$/;"	e	enum:ImGuiTreeNodeFlags_
ImGuiTreeNodeFlags_ClipLabelForTrailingButton	imgui_internal.h	/^    ImGuiTreeNodeFlags_ClipLabelForTrailingButton = 1 << 20$/;"	e	enum:ImGuiTreeNodeFlagsPrivate_
ImGuiTreeNodeFlags_CollapsingHeader	imgui.h	/^    ImGuiTreeNodeFlags_CollapsingHeader     = ImGuiTreeNodeFlags_Framed | ImGuiTreeNodeFlags_NoTreePushOnOpen | ImGuiTreeNodeFlags_NoAutoOpenOnLog$/;"	e	enum:ImGuiTreeNodeFlags_
ImGuiTreeNodeFlags_DefaultOpen	imgui.h	/^    ImGuiTreeNodeFlags_DefaultOpen          = 1 << 5,   \/\/ Default node to be open$/;"	e	enum:ImGuiTreeNodeFlags_
ImGuiTreeNodeFlags_FramePadding	imgui.h	/^    ImGuiTreeNodeFlags_FramePadding         = 1 << 10,  \/\/ Use FramePadding (even for an unframed text node) to vertically align text baseline to regular widget height. Equivalent to calling AlignTextToFramePadding().$/;"	e	enum:ImGuiTreeNodeFlags_
ImGuiTreeNodeFlags_Framed	imgui.h	/^    ImGuiTreeNodeFlags_Framed               = 1 << 1,   \/\/ Draw frame with background (e.g. for CollapsingHeader)$/;"	e	enum:ImGuiTreeNodeFlags_
ImGuiTreeNodeFlags_Leaf	imgui.h	/^    ImGuiTreeNodeFlags_Leaf                 = 1 << 8,   \/\/ No collapsing, no arrow (use as a convenience for leaf nodes).$/;"	e	enum:ImGuiTreeNodeFlags_
ImGuiTreeNodeFlags_NavLeftJumpsBackHere	imgui.h	/^    ImGuiTreeNodeFlags_NavLeftJumpsBackHere = 1 << 13,  \/\/ (WIP) Nav: left direction may move to this TreeNode() from any of its child (items submitted between TreeNode and TreePop)$/;"	e	enum:ImGuiTreeNodeFlags_
ImGuiTreeNodeFlags_NoAutoOpenOnLog	imgui.h	/^    ImGuiTreeNodeFlags_NoAutoOpenOnLog      = 1 << 4,   \/\/ Don't automatically and temporarily open node when Logging is active (by default logging will automatically open tree nodes)$/;"	e	enum:ImGuiTreeNodeFlags_
ImGuiTreeNodeFlags_NoTreePushOnOpen	imgui.h	/^    ImGuiTreeNodeFlags_NoTreePushOnOpen     = 1 << 3,   \/\/ Don't do a TreePush() when open (e.g. for CollapsingHeader) = no extra indent nor pushing on ID stack$/;"	e	enum:ImGuiTreeNodeFlags_
ImGuiTreeNodeFlags_None	imgui.h	/^    ImGuiTreeNodeFlags_None                 = 0,$/;"	e	enum:ImGuiTreeNodeFlags_
ImGuiTreeNodeFlags_OpenOnArrow	imgui.h	/^    ImGuiTreeNodeFlags_OpenOnArrow          = 1 << 7,   \/\/ Only open when clicking on the arrow part. If ImGuiTreeNodeFlags_OpenOnDoubleClick is also set, single-click arrow or double-click all box to open.$/;"	e	enum:ImGuiTreeNodeFlags_
ImGuiTreeNodeFlags_OpenOnDoubleClick	imgui.h	/^    ImGuiTreeNodeFlags_OpenOnDoubleClick    = 1 << 6,   \/\/ Need double-click to open node$/;"	e	enum:ImGuiTreeNodeFlags_
ImGuiTreeNodeFlags_Selected	imgui.h	/^    ImGuiTreeNodeFlags_Selected             = 1 << 0,   \/\/ Draw as selected$/;"	e	enum:ImGuiTreeNodeFlags_
ImGuiTreeNodeFlags_SpanAvailWidth	imgui.h	/^    ImGuiTreeNodeFlags_SpanAvailWidth       = 1 << 11,  \/\/ Extend hit box to the right-most edge, even if not framed. This is not the default in order to allow adding other items on the same line. In the future we may refactor the hit system to be front-to-back, allowing natural overlaps and then this can become the default.$/;"	e	enum:ImGuiTreeNodeFlags_
ImGuiTreeNodeFlags_SpanFullWidth	imgui.h	/^    ImGuiTreeNodeFlags_SpanFullWidth        = 1 << 12,  \/\/ Extend hit box to the left-most and right-most edges (bypass the indented area).$/;"	e	enum:ImGuiTreeNodeFlags_
ImGuiViewport	imgui.h	/^    ImGuiViewport()     { memset(this, 0, sizeof(*this)); }$/;"	f	struct:ImGuiViewport
ImGuiViewport	imgui.h	/^struct ImGuiViewport$/;"	s
ImGuiViewportFlags	imgui.h	/^typedef int ImGuiViewportFlags;     \/\/ -> enum ImGuiViewportFlags_   \/\/ Flags: for ImGuiViewport$/;"	t
ImGuiViewportFlags_	imgui.h	/^enum ImGuiViewportFlags_$/;"	g
ImGuiViewportFlags_IsPlatformMonitor	imgui.h	/^    ImGuiViewportFlags_IsPlatformMonitor        = 1 << 1,   \/\/ Represent a Platform Monitor (unused yet)$/;"	e	enum:ImGuiViewportFlags_
ImGuiViewportFlags_IsPlatformWindow	imgui.h	/^    ImGuiViewportFlags_IsPlatformWindow         = 1 << 0,   \/\/ Represent a Platform Window$/;"	e	enum:ImGuiViewportFlags_
ImGuiViewportFlags_None	imgui.h	/^    ImGuiViewportFlags_None                     = 0,$/;"	e	enum:ImGuiViewportFlags_
ImGuiViewportFlags_OwnedByApp	imgui.h	/^    ImGuiViewportFlags_OwnedByApp               = 1 << 2    \/\/ Platform Window: is created\/managed by the application (rather than a dear imgui backend)$/;"	e	enum:ImGuiViewportFlags_
ImGuiViewportP	imgui_internal.h	/^    ImGuiViewportP()    { DrawListsLastFrame[0] = DrawListsLastFrame[1] = -1; DrawLists[0] = DrawLists[1] = NULL; }$/;"	f	struct:ImGuiViewportP
ImGuiViewportP	imgui_internal.h	/^struct ImGuiViewportP : public ImGuiViewport$/;"	s
ImGuiWindow	imgui.cpp	/^ImGuiWindow::ImGuiWindow(ImGuiContext* context, const char* name) : DrawListInst(NULL)$/;"	f	class:ImGuiWindow
ImGuiWindow	imgui_internal.h	/^struct IMGUI_API ImGuiWindow$/;"	s
ImGuiWindowFlags	imgui.h	/^typedef int ImGuiWindowFlags;       \/\/ -> enum ImGuiWindowFlags_     \/\/ Flags: for Begin(), BeginChild()$/;"	t
ImGuiWindowFlags_	imgui.h	/^enum ImGuiWindowFlags_$/;"	g
ImGuiWindowFlags_AlwaysAutoResize	imgui.h	/^    ImGuiWindowFlags_AlwaysAutoResize       = 1 << 6,   \/\/ Resize every window to its content every frame$/;"	e	enum:ImGuiWindowFlags_
ImGuiWindowFlags_AlwaysHorizontalScrollbar	imgui.h	/^    ImGuiWindowFlags_AlwaysHorizontalScrollbar=1<< 15,  \/\/ Always show horizontal scrollbar (even if ContentSize.x < Size.x)$/;"	e	enum:ImGuiWindowFlags_
ImGuiWindowFlags_AlwaysUseWindowPadding	imgui.h	/^    ImGuiWindowFlags_AlwaysUseWindowPadding = 1 << 16,  \/\/ Ensure child windows without border uses style.WindowPadding (ignored by default for non-bordered child windows, because more convenient)$/;"	e	enum:ImGuiWindowFlags_
ImGuiWindowFlags_AlwaysVerticalScrollbar	imgui.h	/^    ImGuiWindowFlags_AlwaysVerticalScrollbar= 1 << 14,  \/\/ Always show vertical scrollbar (even if ContentSize.y < Size.y)$/;"	e	enum:ImGuiWindowFlags_
ImGuiWindowFlags_ChildMenu	imgui.h	/^    ImGuiWindowFlags_ChildMenu              = 1 << 28   \/\/ Don't use! For internal use by BeginMenu()$/;"	e	enum:ImGuiWindowFlags_
ImGuiWindowFlags_ChildWindow	imgui.h	/^    ImGuiWindowFlags_ChildWindow            = 1 << 24,  \/\/ Don't use! For internal use by BeginChild()$/;"	e	enum:ImGuiWindowFlags_
ImGuiWindowFlags_HorizontalScrollbar	imgui.h	/^    ImGuiWindowFlags_HorizontalScrollbar    = 1 << 11,  \/\/ Allow horizontal scrollbar to appear (off by default). You may use SetNextWindowContentSize(ImVec2(width,0.0f)); prior to calling Begin() to specify width. Read code in imgui_demo in the "Horizontal Scrolling" section.$/;"	e	enum:ImGuiWindowFlags_
ImGuiWindowFlags_MenuBar	imgui.h	/^    ImGuiWindowFlags_MenuBar                = 1 << 10,  \/\/ Has a menu-bar$/;"	e	enum:ImGuiWindowFlags_
ImGuiWindowFlags_Modal	imgui.h	/^    ImGuiWindowFlags_Modal                  = 1 << 27,  \/\/ Don't use! For internal use by BeginPopupModal()$/;"	e	enum:ImGuiWindowFlags_
ImGuiWindowFlags_NavFlattened	imgui.h	/^    ImGuiWindowFlags_NavFlattened           = 1 << 23,  \/\/ [BETA] Allow gamepad\/keyboard navigation to cross over parent border to this child (only use on child that have no scrolling!)$/;"	e	enum:ImGuiWindowFlags_
ImGuiWindowFlags_NoBackground	imgui.h	/^    ImGuiWindowFlags_NoBackground           = 1 << 7,   \/\/ Disable drawing background color (WindowBg, etc.) and outside border. Similar as using SetNextWindowBgAlpha(0.0f).$/;"	e	enum:ImGuiWindowFlags_
ImGuiWindowFlags_NoBringToFrontOnFocus	imgui.h	/^    ImGuiWindowFlags_NoBringToFrontOnFocus  = 1 << 13,  \/\/ Disable bringing window to front when taking focus (e.g. clicking on it or programmatically giving it focus)$/;"	e	enum:ImGuiWindowFlags_
ImGuiWindowFlags_NoCollapse	imgui.h	/^    ImGuiWindowFlags_NoCollapse             = 1 << 5,   \/\/ Disable user collapsing window by double-clicking on it$/;"	e	enum:ImGuiWindowFlags_
ImGuiWindowFlags_NoDecoration	imgui.h	/^    ImGuiWindowFlags_NoDecoration           = ImGuiWindowFlags_NoTitleBar | ImGuiWindowFlags_NoResize | ImGuiWindowFlags_NoScrollbar | ImGuiWindowFlags_NoCollapse,$/;"	e	enum:ImGuiWindowFlags_
ImGuiWindowFlags_NoFocusOnAppearing	imgui.h	/^    ImGuiWindowFlags_NoFocusOnAppearing     = 1 << 12,  \/\/ Disable taking focus when transitioning from hidden to visible state$/;"	e	enum:ImGuiWindowFlags_
ImGuiWindowFlags_NoInputs	imgui.h	/^    ImGuiWindowFlags_NoInputs               = ImGuiWindowFlags_NoMouseInputs | ImGuiWindowFlags_NoNavInputs | ImGuiWindowFlags_NoNavFocus,$/;"	e	enum:ImGuiWindowFlags_
ImGuiWindowFlags_NoMouseInputs	imgui.h	/^    ImGuiWindowFlags_NoMouseInputs          = 1 << 9,   \/\/ Disable catching mouse, hovering test with pass through.$/;"	e	enum:ImGuiWindowFlags_
ImGuiWindowFlags_NoMove	imgui.h	/^    ImGuiWindowFlags_NoMove                 = 1 << 2,   \/\/ Disable user moving the window$/;"	e	enum:ImGuiWindowFlags_
ImGuiWindowFlags_NoNav	imgui.h	/^    ImGuiWindowFlags_NoNav                  = ImGuiWindowFlags_NoNavInputs | ImGuiWindowFlags_NoNavFocus,$/;"	e	enum:ImGuiWindowFlags_
ImGuiWindowFlags_NoNavFocus	imgui.h	/^    ImGuiWindowFlags_NoNavFocus             = 1 << 19,  \/\/ No focusing toward this window with gamepad\/keyboard navigation (e.g. skipped by CTRL+TAB)$/;"	e	enum:ImGuiWindowFlags_
ImGuiWindowFlags_NoNavInputs	imgui.h	/^    ImGuiWindowFlags_NoNavInputs            = 1 << 18,  \/\/ No gamepad\/keyboard navigation within the window$/;"	e	enum:ImGuiWindowFlags_
ImGuiWindowFlags_NoResize	imgui.h	/^    ImGuiWindowFlags_NoResize               = 1 << 1,   \/\/ Disable user resizing with the lower-right grip$/;"	e	enum:ImGuiWindowFlags_
ImGuiWindowFlags_NoSavedSettings	imgui.h	/^    ImGuiWindowFlags_NoSavedSettings        = 1 << 8,   \/\/ Never load\/save settings in .ini file$/;"	e	enum:ImGuiWindowFlags_
ImGuiWindowFlags_NoScrollWithMouse	imgui.h	/^    ImGuiWindowFlags_NoScrollWithMouse      = 1 << 4,   \/\/ Disable user vertically scrolling with mouse wheel. On child window, mouse wheel will be forwarded to the parent unless NoScrollbar is also set.$/;"	e	enum:ImGuiWindowFlags_
ImGuiWindowFlags_NoScrollbar	imgui.h	/^    ImGuiWindowFlags_NoScrollbar            = 1 << 3,   \/\/ Disable scrollbars (window can still scroll with mouse or programmatically)$/;"	e	enum:ImGuiWindowFlags_
ImGuiWindowFlags_NoTitleBar	imgui.h	/^    ImGuiWindowFlags_NoTitleBar             = 1 << 0,   \/\/ Disable title-bar$/;"	e	enum:ImGuiWindowFlags_
ImGuiWindowFlags_None	imgui.h	/^    ImGuiWindowFlags_None                   = 0,$/;"	e	enum:ImGuiWindowFlags_
ImGuiWindowFlags_Popup	imgui.h	/^    ImGuiWindowFlags_Popup                  = 1 << 26,  \/\/ Don't use! For internal use by BeginPopup()$/;"	e	enum:ImGuiWindowFlags_
ImGuiWindowFlags_Tooltip	imgui.h	/^    ImGuiWindowFlags_Tooltip                = 1 << 25,  \/\/ Don't use! For internal use by BeginTooltip()$/;"	e	enum:ImGuiWindowFlags_
ImGuiWindowFlags_UnsavedDocument	imgui.h	/^    ImGuiWindowFlags_UnsavedDocument        = 1 << 20,  \/\/ Append '*' to title without affecting the ID, as a convenience to avoid using the ### operator. When used in a tab\/docking context, tab is selected on closure and closure is deferred by one frame to allow code to cancel the closure (with a confirmation popup, etc.) without flicker.$/;"	e	enum:ImGuiWindowFlags_
ImGuiWindowSettings	imgui_internal.h	/^    ImGuiWindowSettings()       { memset(this, 0, sizeof(*this)); }$/;"	f	struct:ImGuiWindowSettings
ImGuiWindowSettings	imgui_internal.h	/^struct ImGuiWindowSettings$/;"	s
ImGuiWindowTempData	imgui_internal.h	/^struct IMGUI_API ImGuiWindowTempData$/;"	s
ImHash	imgui_internal.h	/^static inline ImGuiID   ImHash(const void* data, int size, ImU32 seed = 0) { return size ? ImHashData(data, (size_t)size, seed) : ImHashStr((const char*)data, 0, seed); } \/\/ [moved to ImHashStr\/ImHashData in 1.68]$/;"	f
ImHashData	imgui.cpp	/^ImGuiID ImHashData(const void* data_p, size_t data_size, ImU32 seed)$/;"	f
ImHashStr	imgui.cpp	/^ImGuiID ImHashStr(const char* data_p, size_t data_size, ImU32 seed)$/;"	f
ImInvLength	imgui_internal.h	/^static inline float  ImInvLength(const ImVec2& lhs, float fail_value)           { float d = (lhs.x * lhs.x) + (lhs.y * lhs.y); if (d > 0.0f) return 1.0f \/ ImSqrt(d); return fail_value; }$/;"	f
ImIsPowerOfTwo	imgui_internal.h	/^static inline bool      ImIsPowerOfTwo(ImU64 v)         { return v != 0 && (v & (v - 1)) == 0; }$/;"	f
ImIsPowerOfTwo	imgui_internal.h	/^static inline bool      ImIsPowerOfTwo(int v)           { return v != 0 && (v & (v - 1)) == 0; }$/;"	f
ImLengthSqr	imgui_internal.h	/^static inline float  ImLengthSqr(const ImVec2& lhs)                             { return (lhs.x * lhs.x) + (lhs.y * lhs.y); }$/;"	f
ImLengthSqr	imgui_internal.h	/^static inline float  ImLengthSqr(const ImVec4& lhs)                             { return (lhs.x * lhs.x) + (lhs.y * lhs.y) + (lhs.z * lhs.z) + (lhs.w * lhs.w); }$/;"	f
ImLerp	imgui_internal.h	/^static inline ImVec2 ImLerp(const ImVec2& a, const ImVec2& b, const ImVec2& t)  { return ImVec2(a.x + (b.x - a.x) * t.x, a.y + (b.y - a.y) * t.y); }$/;"	f
ImLerp	imgui_internal.h	/^static inline ImVec2 ImLerp(const ImVec2& a, const ImVec2& b, float t)          { return ImVec2(a.x + (b.x - a.x) * t, a.y + (b.y - a.y) * t); }$/;"	f
ImLerp	imgui_internal.h	/^static inline ImVec4 ImLerp(const ImVec4& a, const ImVec4& b, float t)          { return ImVec4(a.x + (b.x - a.x) * t, a.y + (b.y - a.y) * t, a.z + (b.z - a.z) * t, a.w + (b.w - a.w) * t); }$/;"	f
ImLerp	imgui_internal.h	/^template<typename T> static inline T ImLerp(T a, T b, float t)                  { return (T)(a + (b - a) * t); }$/;"	f
ImLineClosestPoint	imgui.cpp	/^ImVec2 ImLineClosestPoint(const ImVec2& a, const ImVec2& b, const ImVec2& p)$/;"	f
ImLinearSweep	imgui_internal.h	/^static inline float  ImLinearSweep(float current, float target, float speed)    { if (current < target) return ImMin(current + speed, target); if (current > target) return ImMax(current - speed, target); return current; }$/;"	f
ImLog	imgui_internal.h	/^static inline double ImLog(double x)            { return log(x); }$/;"	f
ImLog	imgui_internal.h	/^static inline float  ImLog(float x)             { return logf(x); }             \/\/ DragBehaviorT\/SliderBehaviorT uses ImLog with either float\/double and need the precision$/;"	f
ImMax	imgui_internal.h	/^static inline ImVec2 ImMax(const ImVec2& lhs, const ImVec2& rhs)                { return ImVec2(lhs.x >= rhs.x ? lhs.x : rhs.x, lhs.y >= rhs.y ? lhs.y : rhs.y); }$/;"	f
ImMax	imgui_internal.h	/^template<typename T> static inline T ImMax(T lhs, T rhs)                        { return lhs >= rhs ? lhs : rhs; }$/;"	f
ImMin	imgui_internal.h	/^static inline ImVec2 ImMin(const ImVec2& lhs, const ImVec2& rhs)                { return ImVec2(lhs.x < rhs.x ? lhs.x : rhs.x, lhs.y < rhs.y ? lhs.y : rhs.y); }$/;"	f
ImMin	imgui_internal.h	/^template<typename T> static inline T ImMin(T lhs, T rhs)                        { return lhs < rhs ? lhs : rhs; }$/;"	f
ImModPositive	imgui_internal.h	/^static inline int    ImModPositive(int a, int b)                                { return (a + b) % b; }$/;"	f
ImMul	imgui_internal.h	/^static inline ImVec2 ImMul(const ImVec2& lhs, const ImVec2& rhs)                { return ImVec2(lhs.x * rhs.x, lhs.y * rhs.y); }$/;"	f
ImNewWrapper	imgui.h	/^struct ImNewWrapper {};$/;"	s
ImParseFormatFindEnd	imgui_widgets.cpp	/^const char* ImParseFormatFindEnd(const char* fmt)$/;"	f
ImParseFormatFindStart	imgui_widgets.cpp	/^const char* ImParseFormatFindStart(const char* fmt)$/;"	f
ImParseFormatPrecision	imgui_widgets.cpp	/^int ImParseFormatPrecision(const char* fmt, int default_precision)$/;"	f
ImParseFormatTrimDecorations	imgui_widgets.cpp	/^const char* ImParseFormatTrimDecorations(const char* fmt, char* buf, size_t buf_size)$/;"	f
ImPool	imgui_internal.h	/^    ImPool()    { FreeIdx = 0; }$/;"	f	struct:ImPool
ImPool	imgui_internal.h	/^struct IMGUI_API ImPool$/;"	s
ImPoolIdx	imgui_internal.h	/^typedef int ImPoolIdx;$/;"	t
ImPow	imgui_internal.h	/^static inline double ImPow(double x, double y)  { return pow(x, y); }$/;"	f
ImPow	imgui_internal.h	/^static inline float  ImPow(float x, float y)    { return powf(x, y); }          \/\/ DragBehaviorT\/SliderBehaviorT uses ImPow with either float\/double and need the precision$/;"	f
ImQsort	imgui_internal.h	/^#define ImQsort /;"	d
ImRect	imgui_internal.h	/^    ImRect()                                        : Min(0.0f, 0.0f), Max(0.0f, 0.0f)  {}$/;"	f	struct:ImRect
ImRect	imgui_internal.h	/^    ImRect(const ImVec2& min, const ImVec2& max)    : Min(min), Max(max)                {}$/;"	f	struct:ImRect
ImRect	imgui_internal.h	/^    ImRect(const ImVec4& v)                         : Min(v.x, v.y), Max(v.z, v.w)      {}$/;"	f	struct:ImRect
ImRect	imgui_internal.h	/^    ImRect(float x1, float y1, float x2, float y2)  : Min(x1, y1), Max(x2, y2)          {}$/;"	f	struct:ImRect
ImRect	imgui_internal.h	/^struct IMGUI_API ImRect$/;"	s
ImRotate	imgui_internal.h	/^static inline ImVec2 ImRotate(const ImVec2& v, float cos_a, float sin_a)        { return ImVec2(v.x * cos_a - v.y * sin_a, v.x * sin_a + v.y * cos_a); }$/;"	f
ImS16	imgui.h	/^typedef signed short        ImS16;  \/\/ 16-bit signed integer$/;"	t
ImS32	imgui.h	/^typedef signed int          ImS32;  \/\/ 32-bit signed integer == int$/;"	t
ImS64	imgui.h	/^typedef int64_t             ImS64;  \/\/ 64-bit signed integer (pre C++11)$/;"	t
ImS64	imgui.h	/^typedef signed   __int64    ImS64;  \/\/ 64-bit signed integer (pre and post C++11 with Visual Studio)$/;"	t
ImS64	imgui.h	/^typedef signed   long long  ImS64;  \/\/ 64-bit signed integer (post C++11)$/;"	t
ImS8	imgui.h	/^typedef signed char         ImS8;   \/\/ 8-bit signed integer$/;"	t
ImSaturate	imgui_internal.h	/^static inline float  ImSaturate(float f)                                        { return (f < 0.0f) ? 0.0f : (f > 1.0f) ? 1.0f : f; }$/;"	f
ImSign	imgui_internal.h	/^static inline double ImSign(double x)           { return (x < 0.0) ? -1.0 : ((x > 0.0) ? 1.0 : 0.0); }$/;"	f
ImSign	imgui_internal.h	/^static inline float  ImSign(float x)            { return (x < 0.0f) ? -1.0f : ((x > 0.0f) ? 1.0f : 0.0f); } \/\/ Sign operator - returns -1, 0 or 1 based on sign of argument$/;"	f
ImSin	imgui_internal.h	/^#define ImSin(/;"	d
ImSpan	imgui_internal.h	/^    inline ImSpan()                                 { Data = DataEnd = NULL; }$/;"	f	struct:ImSpan
ImSpan	imgui_internal.h	/^    inline ImSpan(T* data, T* data_end)             { Data = data; DataEnd = data_end; }$/;"	f	struct:ImSpan
ImSpan	imgui_internal.h	/^    inline ImSpan(T* data, int size)                { Data = data; DataEnd = data + size; }$/;"	f	struct:ImSpan
ImSpan	imgui_internal.h	/^struct ImSpan$/;"	s
ImSpanAllocator	imgui_internal.h	/^    ImSpanAllocator()                               { memset(this, 0, sizeof(*this)); }$/;"	f	struct:ImSpanAllocator
ImSpanAllocator	imgui_internal.h	/^struct ImSpanAllocator$/;"	s
ImSqrt	imgui_internal.h	/^#define ImSqrt(/;"	d
ImStb	imgui_internal.h	/^namespace ImStb$/;"	n
ImStb	imgui_widgets.cpp	/^namespace ImStb$/;"	n	file:
ImStrSkipBlank	imgui.cpp	/^const char* ImStrSkipBlank(const char* str)$/;"	f
ImStrTrimBlanks	imgui.cpp	/^void ImStrTrimBlanks(char* buf)$/;"	f
ImStrbolW	imgui.cpp	/^const ImWchar* ImStrbolW(const ImWchar* buf_mid_line, const ImWchar* buf_begin) \/\/ find beginning-of-line$/;"	f
ImStrchrRange	imgui.cpp	/^const char* ImStrchrRange(const char* str, const char* str_end, char c)$/;"	f
ImStrdup	imgui.cpp	/^char* ImStrdup(const char* str)$/;"	f
ImStrdupcpy	imgui.cpp	/^char* ImStrdupcpy(char* dst, size_t* p_dst_size, const char* src)$/;"	f
ImStreolRange	imgui.cpp	/^const char* ImStreolRange(const char* str, const char* str_end)$/;"	f
ImStricmp	imgui.cpp	/^int ImStricmp(const char* str1, const char* str2)$/;"	f
ImStristr	imgui.cpp	/^const char* ImStristr(const char* haystack, const char* haystack_end, const char* needle, const char* needle_end)$/;"	f
ImStrlenW	imgui.cpp	/^int ImStrlenW(const ImWchar* str)$/;"	f
ImStrncpy	imgui.cpp	/^void ImStrncpy(char* dst, const char* src, size_t count)$/;"	f
ImStrnicmp	imgui.cpp	/^int ImStrnicmp(const char* str1, const char* str2, size_t count)$/;"	f
ImSubClampOverflow	imgui_internal.h	/^template<typename T> static inline T ImSubClampOverflow(T a, T b, T mn, T mx)   { if (b > 0 && (a < mn + b)) return mn; if (b < 0 && (a > mx + b)) return mx; return a - b; }$/;"	f
ImSwap	imgui_internal.h	/^template<typename T> static inline void ImSwap(T& a, T& b)                      { T tmp = a; a = b; b = tmp; }$/;"	f
ImTextCharFromUtf8	imgui.cpp	/^int ImTextCharFromUtf8(unsigned int* out_char, const char* in_text, const char* in_text_end)$/;"	f
ImTextCharToUtf8	imgui.cpp	/^static inline int ImTextCharToUtf8(char* buf, int buf_size, unsigned int c)$/;"	f	file:
ImTextCountCharsFromUtf8	imgui.cpp	/^int ImTextCountCharsFromUtf8(const char* in_text, const char* in_text_end)$/;"	f
ImTextCountUtf8BytesFromChar	imgui.cpp	/^int ImTextCountUtf8BytesFromChar(const char* in_text, const char* in_text_end)$/;"	f
ImTextCountUtf8BytesFromChar	imgui.cpp	/^static inline int ImTextCountUtf8BytesFromChar(unsigned int c)$/;"	f	file:
ImTextCountUtf8BytesFromStr	imgui.cpp	/^int ImTextCountUtf8BytesFromStr(const ImWchar* in_text, const ImWchar* in_text_end)$/;"	f
ImTextStrFromUtf8	imgui.cpp	/^int ImTextStrFromUtf8(ImWchar* buf, int buf_size, const char* in_text, const char* in_text_end, const char** in_text_remaining)$/;"	f
ImTextStrToUtf8	imgui.cpp	/^int ImTextStrToUtf8(char* buf, int buf_size, const ImWchar* in_text, const ImWchar* in_text_end)$/;"	f
ImTextureID	imgui.h	/^typedef void* ImTextureID;          \/\/ User data for rendering backend to identify a texture. This is whatever to you want it to be! read the FAQ about ImTextureID for details.$/;"	t
ImTriangleArea	imgui_internal.h	/^inline float         ImTriangleArea(const ImVec2& a, const ImVec2& b, const ImVec2& c) { return ImFabs((a.x * (b.y - c.y)) + (b.x * (c.y - a.y)) + (c.x * (a.y - b.y))) * 0.5f; }$/;"	f
ImTriangleBarycentricCoords	imgui.cpp	/^void ImTriangleBarycentricCoords(const ImVec2& a, const ImVec2& b, const ImVec2& c, const ImVec2& p, float& out_u, float& out_v, float& out_w)$/;"	f
ImTriangleClosestPoint	imgui.cpp	/^ImVec2 ImTriangleClosestPoint(const ImVec2& a, const ImVec2& b, const ImVec2& c, const ImVec2& p)$/;"	f
ImTriangleContainsPoint	imgui.cpp	/^bool ImTriangleContainsPoint(const ImVec2& a, const ImVec2& b, const ImVec2& c, const ImVec2& p)$/;"	f
ImU16	imgui.h	/^typedef unsigned short      ImU16;  \/\/ 16-bit unsigned integer$/;"	t
ImU32	imgui.h	/^typedef unsigned int        ImU32;  \/\/ 32-bit unsigned integer (often used to store packed colors)$/;"	t
ImU64	imgui.h	/^typedef uint64_t            ImU64;  \/\/ 64-bit unsigned integer (pre C++11)$/;"	t
ImU64	imgui.h	/^typedef unsigned __int64    ImU64;  \/\/ 64-bit unsigned integer (pre and post C++11 with Visual Studio)$/;"	t
ImU64	imgui.h	/^typedef unsigned long long  ImU64;  \/\/ 64-bit unsigned integer (post C++11)$/;"	t
ImU8	imgui.h	/^typedef unsigned char       ImU8;   \/\/ 8-bit unsigned integer$/;"	t
ImUpperPowerOfTwo	imgui_internal.h	/^static inline int       ImUpperPowerOfTwo(int v)        { v--; v |= v >> 1; v |= v >> 2; v |= v >> 4; v |= v >> 8; v |= v >> 16; v++; return v; }$/;"	f
ImVec1	imgui_internal.h	/^    ImVec1()         { x = 0.0f; }$/;"	f	struct:ImVec1
ImVec1	imgui_internal.h	/^    ImVec1(float _x) { x = _x; }$/;"	f	struct:ImVec1
ImVec1	imgui_internal.h	/^struct ImVec1$/;"	s
ImVec2	imgui.h	/^    ImVec2()                                { x = y = 0.0f; }$/;"	f	struct:ImVec2
ImVec2	imgui.h	/^    ImVec2(float _x, float _y)              { x = _x; y = _y; }$/;"	f	struct:ImVec2
ImVec2	imgui.h	/^struct ImVec2$/;"	s
ImVec2ih	imgui_internal.h	/^    ImVec2ih()                           { x = y = 0; }$/;"	f	struct:ImVec2ih
ImVec2ih	imgui_internal.h	/^    ImVec2ih(short _x, short _y)         { x = _x; y = _y; }$/;"	f	struct:ImVec2ih
ImVec2ih	imgui_internal.h	/^    explicit ImVec2ih(const ImVec2& rhs) { x = (short)rhs.x; y = (short)rhs.y; }$/;"	f	struct:ImVec2ih
ImVec2ih	imgui_internal.h	/^struct ImVec2ih$/;"	s
ImVec4	imgui.h	/^    ImVec4()                                        { x = y = z = w = 0.0f; }$/;"	f	struct:ImVec4
ImVec4	imgui.h	/^    ImVec4(float _x, float _y, float _z, float _w)  { x = _x; y = _y; z = _z; w = _w; }$/;"	f	struct:ImVec4
ImVec4	imgui.h	/^struct ImVec4$/;"	s
ImVector	imgui.h	/^    inline ImVector()                                       { Size = Capacity = 0; Data = NULL; }$/;"	f	struct:ImVector
ImVector	imgui.h	/^    inline ImVector(const ImVector<T>& src)                 { Size = Capacity = 0; Data = NULL; operator=(src); }$/;"	f	struct:ImVector
ImVector	imgui.h	/^struct ImVector$/;"	s
ImWchar	imgui.h	/^typedef ImWchar16 ImWchar;$/;"	t
ImWchar	imgui.h	/^typedef ImWchar32 ImWchar;$/;"	t
ImWchar16	imgui.h	/^typedef unsigned short ImWchar16;   \/\/ A single decoded U16 character\/code point. We encode them as multi bytes UTF-8 when used in strings.$/;"	t
ImWchar32	imgui.h	/^typedef unsigned int ImWchar32;     \/\/ A single decoded U32 character\/code point. We encode them as multi bytes UTF-8 when used in strings.$/;"	t
Image	imgui_widgets.cpp	/^void ImGui::Image(ImTextureID user_texture_id, const ImVec2& size, const ImVec2& uv0, const ImVec2& uv1, const ImVec4& tint_col, const ImVec4& border_col)$/;"	f	class:ImGui
ImageButton	imgui_widgets.cpp	/^bool ImGui::ImageButton(ImTextureID user_texture_id, const ImVec2& size, const ImVec2& uv0, const ImVec2& uv1, int frame_padding, const ImVec4& bg_col, const ImVec4& tint_col)$/;"	f	class:ImGui
ImageButtonEx	imgui_widgets.cpp	/^bool ImGui::ImageButtonEx(ImGuiID id, ImTextureID texture_id, const ImVec2& size, const ImVec2& uv0, const ImVec2& uv1, const ImVec2& padding, const ImVec4& bg_col, const ImVec4& tint_col)$/;"	f	class:ImGui
ImeSetInputScreenPosFn	imgui.h	/^    void        (*ImeSetInputScreenPosFn)(int x, int y);$/;"	m	struct:ImGuiIO
ImeSetInputScreenPosFn_DefaultImpl	imgui.cpp	/^static void ImeSetInputScreenPosFn_DefaultImpl(int x, int y)$/;"	f	file:
ImeSetInputScreenPosFn_DefaultImpl	imgui.cpp	/^static void ImeSetInputScreenPosFn_DefaultImpl(int, int) {}$/;"	f	file:
ImeWindowHandle	imgui.h	/^    void*       ImeWindowHandle;                \/\/ = NULL           \/\/ (Windows) Set this to your HWND to get automatic IME cursor positioning.$/;"	m	struct:ImGuiIO
Indent	imgui.cpp	/^void ImGui::Indent(float indent_w)$/;"	f	class:ImGui
Indent	imgui_internal.h	/^    ImVec1                  Indent;                 \/\/ Indentation \/ start position from left of window (increased by TreePush\/TreePop, etc.)$/;"	m	struct:ImGuiWindowTempData
IndentSpacing	imgui.h	/^    float       IndentSpacing;              \/\/ Horizontal indentation when e.g. entering a tree node. Generally == (FontSize + FramePadding.x*2).$/;"	m	struct:ImGuiStyle
Index	imgui_internal.h	/^    ImGuiTableColumnIdx     Index;$/;"	m	struct:ImGuiTableColumnSettings
Index	imgui_internal.h	/^    int         Index;          \/\/ Usually index in a main pool.$/;"	m	struct:ImGuiPtrOrIndex
Index	imgui_internal.h	/^    int         Index;$/;"	m	struct:ImGuiShrinkWidthItem
IndexAdvanceX	imgui.h	/^    ImVector<float>             IndexAdvanceX;      \/\/ 12-16 \/\/ out \/\/            \/\/ Sparse. Glyphs->AdvanceX in a directly indexable way (cache-friendly for CalcTextSize functions which only this this info, and are often bottleneck in large UI).$/;"	m	struct:ImFont
IndexDuringLayout	imgui_internal.h	/^    ImS16               IndexDuringLayout;      \/\/ Index only used during TabBarLayout()$/;"	m	struct:ImGuiTabItem
IndexLookup	imgui.h	/^    ImVector<ImWchar>           IndexLookup;        \/\/ 12-16 \/\/ out \/\/            \/\/ Sparse. Index glyphs by Unicode code-point.$/;"	m	struct:ImFont
IndexWithinEnabledSet	imgui_internal.h	/^    ImGuiTableColumnIdx     IndexWithinEnabledSet;          \/\/ Index within enabled\/visible set (<= IndexToDisplayOrder)$/;"	m	struct:ImGuiTableColumn
IniFilename	imgui.h	/^    const char* IniFilename;                    \/\/ = "imgui.ini"    \/\/ Path to .ini file. Set NULL to disable automatic .ini loading\/saving, if e.g. you want to manually load\/save from memory.$/;"	m	struct:ImGuiIO
IniSavingRate	imgui.h	/^    float       IniSavingRate;                  \/\/ = 5.0f           \/\/ Minimum time between saving positions\/sizes to .ini file, in seconds.$/;"	m	struct:ImGuiIO
InitStretchWeightOrWidth	imgui_internal.h	/^    float                   InitStretchWeightOrWidth;       \/\/ Value passed to TableSetupColumn(). For Width it is a content width (_without padding_).$/;"	m	struct:ImGuiTableColumn
InitialFlags	imgui_internal.h	/^    ImDrawListFlags InitialFlags;               \/\/ Initial flags at the beginning of the frame (it is possible to alter flags on a per-drawlist basis afterwards)$/;"	m	struct:ImDrawListSharedData
InitialTextA	imgui_internal.h	/^    ImVector<char>          InitialTextA;           \/\/ backup of end-user buffer at the time of focus (in UTF-8, unaltered)$/;"	m	struct:ImGuiInputTextState
Initialize	imgui.cpp	/^void ImGui::Initialize(ImGuiContext* context)$/;"	f	class:ImGui
Initialized	imgui_internal.h	/^    bool                    Initialized;$/;"	m	struct:ImGuiContext
InnerClipRect	imgui_internal.h	/^    ImRect                      InnerClipRect;$/;"	m	struct:ImGuiTable
InnerClipRect	imgui_internal.h	/^    ImRect                  InnerClipRect;                      \/\/ == InnerRect shrunk by WindowPadding*0.5f on each side, clipped within viewport or parent clip rect.$/;"	m	struct:ImGuiWindow
InnerDir	imgui.cpp	/^    ImVec2  InnerDir;$/;"	m	struct:ImGuiResizeGripDef	file:
InnerDir	imgui.cpp	/^    ImVec2 InnerDir;$/;"	m	struct:ImGuiResizeBorderDef	file:
InnerRect	imgui_internal.h	/^    ImRect                      InnerRect;                  \/\/ InnerRect but without decoration. As with OuterRect, for non-scrolling tables, InnerRect.Max.y is$/;"	m	struct:ImGuiTable
InnerRect	imgui_internal.h	/^    ImRect                  InnerRect;                          \/\/ Inner rectangle (omit title bar, menu bar, scroll bar)$/;"	m	struct:ImGuiWindow
InnerWidth	imgui_internal.h	/^    float                       InnerWidth;                 \/\/ User value passed to BeginTable(), see comments at the top of BeginTable() for details.$/;"	m	struct:ImGuiTable
InnerWindow	imgui_internal.h	/^    ImGuiWindow*                InnerWindow;                \/\/ Window holding the table data (== OuterWindow or a child window)$/;"	m	struct:ImGuiTable
InputBuf	imgui.h	/^    char                    InputBuf[256];$/;"	m	struct:ImGuiTextFilter
InputBuf	imgui_demo.cpp	/^    char                  InputBuf[256];$/;"	m	struct:ExampleAppConsole	file:
InputDouble	imgui_widgets.cpp	/^bool ImGui::InputDouble(const char* label, double* v, double step, double step_fast, const char* format, ImGuiInputTextFlags flags)$/;"	f	class:ImGui
InputFloat	imgui_widgets.cpp	/^bool ImGui::InputFloat(const char* label, float* v, float step, float step_fast, const char* format, ImGuiInputTextFlags flags)$/;"	f	class:ImGui
InputFloat2	imgui_widgets.cpp	/^bool ImGui::InputFloat2(const char* label, float v[2], const char* format, ImGuiInputTextFlags flags)$/;"	f	class:ImGui
InputFloat3	imgui_widgets.cpp	/^bool ImGui::InputFloat3(const char* label, float v[3], const char* format, ImGuiInputTextFlags flags)$/;"	f	class:ImGui
InputFloat4	imgui_widgets.cpp	/^bool ImGui::InputFloat4(const char* label, float v[4], const char* format, ImGuiInputTextFlags flags)$/;"	f	class:ImGui
InputInt	imgui_widgets.cpp	/^bool ImGui::InputInt(const char* label, int* v, int step, int step_fast, ImGuiInputTextFlags flags)$/;"	f	class:ImGui
InputInt2	imgui_widgets.cpp	/^bool ImGui::InputInt2(const char* label, int v[2], ImGuiInputTextFlags flags)$/;"	f	class:ImGui
InputInt3	imgui_widgets.cpp	/^bool ImGui::InputInt3(const char* label, int v[3], ImGuiInputTextFlags flags)$/;"	f	class:ImGui
InputInt4	imgui_widgets.cpp	/^bool ImGui::InputInt4(const char* label, int v[4], ImGuiInputTextFlags flags)$/;"	f	class:ImGui
InputQueueCharacters	imgui.h	/^    ImVector<ImWchar> InputQueueCharacters;     \/\/ Queue of _characters_ input (obtained by platform backend). Fill using AddInputCharacter() helper.$/;"	m	struct:ImGuiIO
InputQueueSurrogate	imgui.h	/^    ImWchar16   InputQueueSurrogate;            \/\/ For AddInputCharacterUTF16$/;"	m	struct:ImGuiIO
InputScalar	imgui_widgets.cpp	/^bool ImGui::InputScalar(const char* label, ImGuiDataType data_type, void* p_data, const void* p_step, const void* p_step_fast, const char* format, ImGuiInputTextFlags flags)$/;"	f	class:ImGui
InputScalarN	imgui_widgets.cpp	/^bool ImGui::InputScalarN(const char* label, ImGuiDataType data_type, void* p_data, int components, const void* p_step, const void* p_step_fast, const char* format, ImGuiInputTextFlags flags)$/;"	f	class:ImGui
InputText	imgui_widgets.cpp	/^bool ImGui::InputText(const char* label, char* buf, size_t buf_size, ImGuiInputTextFlags flags, ImGuiInputTextCallback callback, void* user_data)$/;"	f	class:ImGui
InputTextCalcTextLenAndLineCount	imgui_widgets.cpp	/^static int InputTextCalcTextLenAndLineCount(const char* text_begin, const char** out_text_end)$/;"	f	file:
InputTextCalcTextSizeW	imgui_widgets.cpp	/^static ImVec2 InputTextCalcTextSizeW(const ImWchar* text_begin, const ImWchar* text_end, const ImWchar** remaining, ImVec2* out_offset, bool stop_on_new_line)$/;"	f	file:
InputTextEx	imgui_widgets.cpp	/^bool ImGui::InputTextEx(const char* label, const char* hint, char* buf, int buf_size, const ImVec2& size_arg, ImGuiInputTextFlags flags, ImGuiInputTextCallback callback, void* callback_user_data)$/;"	f	class:ImGui
InputTextFilterCharacter	imgui_widgets.cpp	/^static bool InputTextFilterCharacter(unsigned int* p_char, ImGuiInputTextFlags flags, ImGuiInputTextCallback callback, void* user_data, ImGuiInputSource input_source)$/;"	f	file:
InputTextMultiline	imgui_widgets.cpp	/^bool ImGui::InputTextMultiline(const char* label, char* buf, size_t buf_size, const ImVec2& size, ImGuiInputTextFlags flags, ImGuiInputTextCallback callback, void* user_data)$/;"	f	class:ImGui
InputTextPasswordFont	imgui_internal.h	/^    ImFont                  InputTextPasswordFont;$/;"	m	struct:ImGuiContext
InputTextState	imgui_internal.h	/^    ImGuiInputTextState     InputTextState;$/;"	m	struct:ImGuiContext
InputTextWithHint	imgui_widgets.cpp	/^bool ImGui::InputTextWithHint(const char* label, const char* hint, char* buf, size_t buf_size, ImGuiInputTextFlags flags, ImGuiInputTextCallback callback, void* user_data)$/;"	f	class:ImGui
InsertChars	imgui_widgets.cpp	/^void ImGuiInputTextCallbackData::InsertChars(int pos, const char* new_text, const char* new_text_end)$/;"	f	class:ImGuiInputTextCallbackData
InstanceCurrent	imgui_internal.h	/^    ImS16                       InstanceCurrent;            \/\/ Count of BeginTable() calls with same ID in the same frame (generally 0). This is a little bit similar to BeginCount for a window, but multiple table with same ID look are multiple tables, they are just synched.$/;"	m	struct:ImGuiTable
InstanceInteracted	imgui_internal.h	/^    ImS16                       InstanceInteracted;         \/\/ Mark which instance (generally 0) of the same ID is being interacted with$/;"	m	struct:ImGuiTable
InvisibleButton	imgui_widgets.cpp	/^bool ImGui::InvisibleButton(const char* str_id, const ImVec2& size_arg, ImGuiButtonFlags flags)$/;"	f	class:ImGui
IsActive	imgui.h	/^    bool                IsActive() const { return !Filters.empty(); }$/;"	f	struct:ImGuiTextFilter
IsActiveIdUsingKey	imgui_internal.h	/^    inline bool             IsActiveIdUsingKey(ImGuiKey key)                            { ImGuiContext& g = *GImGui; IM_ASSERT(key < 64); return (g.ActiveIdUsingKeyInputMask & ((ImU64)1 << key)) != 0; }$/;"	f	namespace:ImGui
IsActiveIdUsingNavDir	imgui_internal.h	/^    inline bool             IsActiveIdUsingNavDir(ImGuiDir dir)                         { ImGuiContext& g = *GImGui; return (g.ActiveIdUsingNavDirMask & (1 << dir)) != 0; }$/;"	f	namespace:ImGui
IsActiveIdUsingNavInput	imgui_internal.h	/^    inline bool             IsActiveIdUsingNavInput(ImGuiNavInput input)                { ImGuiContext& g = *GImGui; return (g.ActiveIdUsingNavInputMask & (1 << input)) != 0; }$/;"	f	namespace:ImGui
IsAnyItemActive	imgui.cpp	/^bool ImGui::IsAnyItemActive()$/;"	f	class:ImGui
IsAnyItemFocused	imgui.cpp	/^bool ImGui::IsAnyItemFocused()$/;"	f	class:ImGui
IsAnyItemHovered	imgui.cpp	/^bool ImGui::IsAnyItemHovered()$/;"	f	class:ImGui
IsAnyMouseDown	imgui.cpp	/^bool ImGui::IsAnyMouseDown()$/;"	f	class:ImGui
IsBeingResized	imgui_internal.h	/^    bool                IsBeingResized;$/;"	m	struct:ImGuiOldColumns
IsBuilt	imgui.h	/^    bool                        IsBuilt() const             { return Fonts.Size > 0 && (TexPixelsAlpha8 != NULL || TexPixelsRGBA32 != NULL); }$/;"	f	struct:ImFontAtlas
IsClippedEx	imgui.cpp	/^bool ImGui::IsClippedEx(const ImRect& bb, ImGuiID id, bool clip_even_when_logged)$/;"	f	class:ImGui
IsContextPopupOpen	imgui_internal.h	/^    bool                        IsContextPopupOpen;         \/\/ Set when default context menu is open (also see: ContextPopupColumn, InstanceInteracted).$/;"	m	struct:ImGuiTable
IsDataType	imgui.h	/^    bool IsDataType(const char* type) const { return DataFrameCount != -1 && strcmp(type, DataType) == 0; }$/;"	f	struct:ImGuiPayload
IsDefaultDisplayOrder	imgui_internal.h	/^    bool                        IsDefaultDisplayOrder;      \/\/ Set when display order is unchanged from default (DisplayOrder contains 0...Count-1)$/;"	m	struct:ImGuiTable
IsDefaultSizingPolicy	imgui_internal.h	/^    bool                        IsDefaultSizingPolicy;      \/\/ Set if user didn't explicitly set a sizing policy in BeginTable()$/;"	m	struct:ImGuiTable
IsDelivery	imgui.h	/^    bool IsDelivery() const                 { return Delivery; }$/;"	f	struct:ImGuiPayload
IsDragDropPayloadBeingAccepted	imgui.cpp	/^bool ImGui::IsDragDropPayloadBeingAccepted()$/;"	f	class:ImGui
IsEnabled	imgui_internal.h	/^    ImU8                    IsEnabled : 1; \/\/ "Visible" in ini file$/;"	m	struct:ImGuiTableColumnSettings
IsEnabled	imgui_internal.h	/^    bool                    IsEnabled;                      \/\/ Is the column not marked Hidden by the user? (even if off view, e.g. clipped by scrolling).$/;"	m	struct:ImGuiTableColumn
IsEnabledNextFrame	imgui_internal.h	/^    bool                    IsEnabledNextFrame;$/;"	m	struct:ImGuiTableColumn
IsFallbackWindow	imgui_internal.h	/^    bool                    IsFallbackWindow;                   \/\/ Set on the "Debug##Default" window.$/;"	m	struct:ImGuiWindow
IsFirstFrame	imgui_internal.h	/^    bool                IsFirstFrame;$/;"	m	struct:ImGuiOldColumns
IsGlyphRangeUnused	imgui_draw.cpp	/^bool ImFont::IsGlyphRangeUnused(unsigned int c_begin, unsigned int c_last)$/;"	f	class:ImFont
IsInitializing	imgui_internal.h	/^    bool                        IsInitializing;$/;"	m	struct:ImGuiTable
IsInsideRow	imgui_internal.h	/^    bool                        IsInsideRow;                \/\/ Set when inside TableBeginRow()\/TableEndRow().$/;"	m	struct:ImGuiTable
IsInverted	imgui_internal.h	/^    bool        IsInverted() const                  { return Min.x > Max.x || Min.y > Max.y; }$/;"	f	struct:ImRect
IsItemActivated	imgui.cpp	/^bool ImGui::IsItemActivated()$/;"	f	class:ImGui
IsItemActive	imgui.cpp	/^bool ImGui::IsItemActive()$/;"	f	class:ImGui
IsItemClicked	imgui.cpp	/^bool ImGui::IsItemClicked(ImGuiMouseButton mouse_button)$/;"	f	class:ImGui
IsItemDeactivated	imgui.cpp	/^bool ImGui::IsItemDeactivated()$/;"	f	class:ImGui
IsItemDeactivatedAfterEdit	imgui.cpp	/^bool ImGui::IsItemDeactivatedAfterEdit()$/;"	f	class:ImGui
IsItemEdited	imgui.cpp	/^bool ImGui::IsItemEdited()$/;"	f	class:ImGui
IsItemFocused	imgui.cpp	/^bool ImGui::IsItemFocused()$/;"	f	class:ImGui
IsItemHovered	imgui.cpp	/^bool ImGui::IsItemHovered(ImGuiHoveredFlags flags)$/;"	f	class:ImGui
IsItemToggledOpen	imgui.cpp	/^bool ImGui::IsItemToggledOpen()$/;"	f	class:ImGui
IsItemToggledSelection	imgui.cpp	/^bool ImGui::IsItemToggledSelection()$/;"	f	class:ImGui
IsItemVisible	imgui.cpp	/^bool ImGui::IsItemVisible()$/;"	f	class:ImGui
IsKeyDown	imgui.cpp	/^bool ImGui::IsKeyDown(int user_key_index)$/;"	f	class:ImGui
IsKeyPressed	imgui.cpp	/^bool ImGui::IsKeyPressed(int user_key_index, bool repeat)$/;"	f	class:ImGui
IsKeyPressedMap	imgui_internal.h	/^    inline bool             IsKeyPressedMap(ImGuiKey key, bool repeat = true)           { ImGuiContext& g = *GImGui; const int key_index = g.IO.KeyMap[key]; return (key_index >= 0) ? IsKeyPressed(key_index, repeat) : false; }$/;"	f	namespace:ImGui
IsKeyReleased	imgui.cpp	/^bool ImGui::IsKeyReleased(int user_key_index)$/;"	f	class:ImGui
IsLayoutLocked	imgui_internal.h	/^    bool                        IsLayoutLocked;             \/\/ Set by TableUpdateLayout() which is called when beginning the first row.$/;"	m	struct:ImGuiTable
IsLoaded	imgui.h	/^    bool                        IsLoaded() const                    { return ContainerAtlas != NULL; }$/;"	f	struct:ImFont
IsMouseClicked	imgui.cpp	/^bool ImGui::IsMouseClicked(ImGuiMouseButton button, bool repeat)$/;"	f	class:ImGui
IsMouseDoubleClicked	imgui.cpp	/^bool ImGui::IsMouseDoubleClicked(ImGuiMouseButton button)$/;"	f	class:ImGui
IsMouseDown	imgui.cpp	/^bool ImGui::IsMouseDown(ImGuiMouseButton button)$/;"	f	class:ImGui
IsMouseDragPastThreshold	imgui.cpp	/^bool ImGui::IsMouseDragPastThreshold(ImGuiMouseButton button, float lock_threshold)$/;"	f	class:ImGui
IsMouseDragging	imgui.cpp	/^bool ImGui::IsMouseDragging(ImGuiMouseButton button, float lock_threshold)$/;"	f	class:ImGui
IsMouseHoveringRect	imgui.cpp	/^bool ImGui::IsMouseHoveringRect(const ImVec2& r_min, const ImVec2& r_max, bool clip)$/;"	f	class:ImGui
IsMousePosValid	imgui.cpp	/^bool ImGui::IsMousePosValid(const ImVec2* mouse_pos)$/;"	f	class:ImGui
IsMouseReleased	imgui.cpp	/^bool ImGui::IsMouseReleased(ImGuiMouseButton button)$/;"	f	class:ImGui
IsNavInputDown	imgui_internal.h	/^    inline bool             IsNavInputDown(ImGuiNavInput n)                             { ImGuiContext& g = *GImGui; return g.IO.NavInputs[n] > 0.0f; }$/;"	f	namespace:ImGui
IsNavInputTest	imgui_internal.h	/^    inline bool             IsNavInputTest(ImGuiNavInput n, ImGuiInputReadMode rm)      { return (GetNavInputAmount(n, rm) > 0.0f); }$/;"	f	namespace:ImGui
IsPacked	imgui.h	/^    bool IsPacked() const           { return X != 0xFFFF; }$/;"	f	struct:ImFontAtlasCustomRect
IsPopupOpen	imgui.cpp	/^bool ImGui::IsPopupOpen(ImGuiID id, ImGuiPopupFlags popup_flags)$/;"	f	class:ImGui
IsPopupOpen	imgui.cpp	/^bool ImGui::IsPopupOpen(const char* str_id, ImGuiPopupFlags popup_flags)$/;"	f	class:ImGui
IsPreserveWidthAuto	imgui_internal.h	/^    bool                    IsPreserveWidthAuto;$/;"	m	struct:ImGuiTableColumn
IsPreview	imgui.h	/^    bool IsPreview() const                  { return Preview; }$/;"	f	struct:ImGuiPayload
IsRectVisible	imgui.cpp	/^bool ImGui::IsRectVisible(const ImVec2& rect_min, const ImVec2& rect_max)$/;"	f	class:ImGui
IsRectVisible	imgui.cpp	/^bool ImGui::IsRectVisible(const ImVec2& size)$/;"	f	class:ImGui
IsRequestOutput	imgui_internal.h	/^    bool                    IsRequestOutput;                \/\/ Return value for TableSetColumnIndex() \/ TableNextColumn(): whether we request user to output contents or not.$/;"	m	struct:ImGuiTableColumn
IsResetAllRequest	imgui_internal.h	/^    bool                        IsResetAllRequest;$/;"	m	struct:ImGuiTable
IsResetDisplayOrderRequest	imgui_internal.h	/^    bool                        IsResetDisplayOrderRequest;$/;"	m	struct:ImGuiTable
IsSettingsDirty	imgui_internal.h	/^    bool                        IsSettingsDirty;            \/\/ Set when table settings have changed and needs to be reported into ImGuiTableSetttings data.$/;"	m	struct:ImGuiTable
IsSettingsRequestLoad	imgui_internal.h	/^    bool                        IsSettingsRequestLoad;$/;"	m	struct:ImGuiTable
IsSkipItems	imgui_internal.h	/^    bool                    IsSkipItems;                    \/\/ Do we want item submissions to this column to be completely ignored (no layout will happen).$/;"	m	struct:ImGuiTableColumn
IsSortSpecsDirty	imgui_internal.h	/^    bool                        IsSortSpecsDirty;$/;"	m	struct:ImGuiTable
IsStretch	imgui_internal.h	/^    ImU8                    IsStretch : 1;$/;"	m	struct:ImGuiTableColumnSettings
IsUnfrozenRows	imgui_internal.h	/^    bool                        IsUnfrozenRows;             \/\/ Set when we got past the frozen row.$/;"	m	struct:ImGuiTable
IsUsingHeaders	imgui_internal.h	/^    bool                        IsUsingHeaders;             \/\/ Set when the first row had the ImGuiTableRowFlags_Headers flag.$/;"	m	struct:ImGuiTable
IsVisibleX	imgui_internal.h	/^    bool                    IsVisibleX;                     \/\/ Is actually in view (e.g. overlapping the host window clipping rectangle, not scrolled).$/;"	m	struct:ImGuiTableColumn
IsVisibleY	imgui_internal.h	/^    bool                    IsVisibleY;$/;"	m	struct:ImGuiTableColumn
IsWindowAbove	imgui.cpp	/^bool ImGui::IsWindowAbove(ImGuiWindow* potential_above, ImGuiWindow* potential_below)$/;"	f	class:ImGui
IsWindowActiveAndVisible	imgui.cpp	/^static bool IsWindowActiveAndVisible(ImGuiWindow* window)$/;"	f	file:
IsWindowAppearing	imgui.cpp	/^bool ImGui::IsWindowAppearing()$/;"	f	class:ImGui
IsWindowChildOf	imgui.cpp	/^bool ImGui::IsWindowChildOf(ImGuiWindow* window, ImGuiWindow* potential_parent)$/;"	f	class:ImGui
IsWindowCollapsed	imgui.cpp	/^bool ImGui::IsWindowCollapsed()$/;"	f	class:ImGui
IsWindowContentHoverable	imgui.cpp	/^static inline bool IsWindowContentHoverable(ImGuiWindow* window, ImGuiHoveredFlags flags)$/;"	f	file:
IsWindowFocused	imgui.cpp	/^bool ImGui::IsWindowFocused(ImGuiFocusedFlags flags)$/;"	f	class:ImGui
IsWindowHovered	imgui.cpp	/^bool ImGui::IsWindowHovered(ImGuiHoveredFlags flags)$/;"	f	class:ImGui
IsWindowNavFocusable	imgui.cpp	/^bool ImGui::IsWindowNavFocusable(ImGuiWindow* window)$/;"	f	class:ImGui
ItemAdd	imgui.cpp	/^bool ImGui::ItemAdd(const ImRect& bb, ImGuiID id, const ImRect* nav_bb_arg)$/;"	f	class:ImGui
ItemFlags	imgui_internal.h	/^    ImGuiItemFlags          ItemFlags;              \/\/ == g.ItemFlagsStack.back()$/;"	m	struct:ImGuiWindowTempData
ItemFlagsStack	imgui_internal.h	/^    ImVector<ImGuiItemFlags>ItemFlagsStack;                     \/\/ Stack for PushItemFlag()\/PopItemFlag() - inherited by Begin()$/;"	m	struct:ImGuiContext
ItemHoverable	imgui.cpp	/^bool ImGui::ItemHoverable(const ImRect& bb, ImGuiID id)$/;"	f	class:ImGui
ItemInnerSpacing	imgui.h	/^    ImVec2      ItemInnerSpacing;           \/\/ Horizontal and vertical spacing between within elements of a composed widget (e.g. a slider and its label).$/;"	m	struct:ImGuiStyle
ItemSize	imgui.cpp	/^void ImGui::ItemSize(const ImRect& bb, float text_baseline_y)$/;"	f	class:ImGui
ItemSize	imgui.cpp	/^void ImGui::ItemSize(const ImVec2& size, float text_baseline_y)$/;"	f	class:ImGui
ItemSpacing	imgui.h	/^    ImVec2      ItemSpacing;                \/\/ Horizontal and vertical spacing between widgets\/lines.$/;"	m	struct:ImGuiStyle
ItemSpacingY	imgui_internal.h	/^    float               ItemSpacingY;$/;"	m	struct:ImGuiTabBar
ItemWidth	imgui_internal.h	/^    float                   ItemWidth;                      \/\/ Current item width for the column, preserved across rows$/;"	m	struct:ImGuiTableColumn
ItemWidth	imgui_internal.h	/^    float                   ItemWidth;              \/\/ Current item width (>0.0: width in pixels, <0.0: align xx pixels to the right of window).$/;"	m	struct:ImGuiWindowTempData
ItemWidthDefault	imgui_internal.h	/^    float                   ItemWidthDefault;$/;"	m	struct:ImGuiWindow
ItemWidthStack	imgui_internal.h	/^    ImVector<float>         ItemWidthStack;         \/\/ Store item widths to restore (attention: .back() is not == ItemWidth)$/;"	m	struct:ImGuiWindowTempData
Items	imgui_demo.cpp	/^    ImVector<char*>       Items;$/;"	m	struct:ExampleAppConsole	file:
ItemsCount	imgui.h	/^    int     ItemsCount;$/;"	m	struct:ImGuiListClipper
ItemsFrozen	imgui.h	/^    int     ItemsFrozen;$/;"	m	struct:ImGuiListClipper
ItemsHeight	imgui.h	/^    float   ItemsHeight;$/;"	m	struct:ImGuiListClipper
Items_ArrayGetter	imgui_widgets.cpp	/^static bool Items_ArrayGetter(void* data, int idx, const char** out_text)$/;"	f	file:
Items_SingleStringGetter	imgui_widgets.cpp	/^static bool Items_SingleStringGetter(void* data, int idx, const char** out_text)$/;"	f	file:
KeepAliveID	imgui.cpp	/^void ImGui::KeepAliveID(ImGuiID id)$/;"	f	class:ImGui
KeyAlt	imgui.h	/^    bool        KeyAlt;                         \/\/ Keyboard modifier pressed: Alt$/;"	m	struct:ImGuiIO
KeyCtrl	imgui.h	/^    bool        KeyCtrl;                        \/\/ Keyboard modifier pressed: Control$/;"	m	struct:ImGuiIO
KeyMap	imgui.h	/^    int         KeyMap[ImGuiKey_COUNT];         \/\/ <unset>          \/\/ Map of indices into the KeysDown[512] entries array which represent your "native" keyboard state.$/;"	m	struct:ImGuiIO
KeyMods	imgui.h	/^    ImGuiKeyModFlags KeyMods;                   \/\/ Key mods flags (same as io.KeyCtrl\/KeyShift\/KeyAlt\/KeySuper but merged into flags), updated by NewFrame()$/;"	m	struct:ImGuiIO
KeyRepeatDelay	imgui.h	/^    float       KeyRepeatDelay;                 \/\/ = 0.250f         \/\/ When holding a key\/button, time before it starts repeating, in seconds (for buttons in Repeat mode, etc.).$/;"	m	struct:ImGuiIO
KeyRepeatRate	imgui.h	/^    float       KeyRepeatRate;                  \/\/ = 0.050f         \/\/ When holding a key\/button, rate at which it repeats, in seconds.$/;"	m	struct:ImGuiIO
KeyShift	imgui.h	/^    bool        KeyShift;                       \/\/ Keyboard modifier pressed: Shift$/;"	m	struct:ImGuiIO
KeySuper	imgui.h	/^    bool        KeySuper;                       \/\/ Keyboard modifier pressed: Cmd\/Super\/Windows$/;"	m	struct:ImGuiIO
KeysDown	imgui.h	/^    bool        KeysDown[512];                  \/\/ Keyboard keys that are pressed (ideally left in the "native" order your engine has access to keyboard keys, so you can use your own defines\/enums for keys).$/;"	m	struct:ImGuiIO
KeysDownDuration	imgui.h	/^    float       KeysDownDuration[512];          \/\/ Duration the keyboard key has been down (0.0f == just pressed)$/;"	m	struct:ImGuiIO
KeysDownDurationPrev	imgui.h	/^    float       KeysDownDurationPrev[512];      \/\/ Previous duration the key has been down$/;"	m	struct:ImGuiIO
LabelText	imgui_widgets.cpp	/^void ImGui::LabelText(const char* label, const char* fmt, ...)$/;"	f	class:ImGui
LabelTextV	imgui_widgets.cpp	/^void ImGui::LabelTextV(const char* label, const char* fmt, va_list args)$/;"	f	class:ImGui
LastActiveId	imgui_internal.h	/^    ImGuiID                 LastActiveId;                       \/\/ Store the last non-zero ActiveId, useful for animation.$/;"	m	struct:ImGuiContext
LastActiveIdTimer	imgui_internal.h	/^    float                   LastActiveIdTimer;                  \/\/ Store the last non-zero ActiveId timer since the beginning of activation, useful for animation.$/;"	m	struct:ImGuiContext
LastFirstRowHeight	imgui_internal.h	/^    float                       LastFirstRowHeight;         \/\/ Height of first row from last frame$/;"	m	struct:ImGuiTable
LastFrameActive	imgui_internal.h	/^    int                         LastFrameActive;$/;"	m	struct:ImGuiTable
LastFrameActive	imgui_internal.h	/^    int                     LastFrameActive;                    \/\/ Last frame number the window was Active.$/;"	m	struct:ImGuiWindow
LastFrameSelected	imgui_internal.h	/^    int                 LastFrameSelected;      \/\/ This allows us to infer an ordered list of the last activated tabs with little maintenance$/;"	m	struct:ImGuiTabItem
LastFrameVisible	imgui_internal.h	/^    int                 LastFrameVisible;$/;"	m	struct:ImGuiTabItem
LastItemDisplayRect	imgui_internal.h	/^    ImRect                  LastItemDisplayRect;    \/\/ End-user display rect for last item (only valid if LastItemStatusFlags & ImGuiItemStatusFlags_HasDisplayRect)$/;"	m	struct:ImGuiWindowTempData
LastItemDisplayRect	imgui_internal.h	/^    ImRect                  LastItemDisplayRect;$/;"	m	struct:ImGuiLastItemDataBackup
LastItemId	imgui_internal.h	/^    ImGuiID                 LastItemId;             \/\/ ID for last item$/;"	m	struct:ImGuiWindowTempData
LastItemId	imgui_internal.h	/^    ImGuiID                 LastItemId;$/;"	m	struct:ImGuiLastItemDataBackup
LastItemRect	imgui_internal.h	/^    ImRect                  LastItemRect;           \/\/ Interaction rect for last item$/;"	m	struct:ImGuiWindowTempData
LastItemRect	imgui_internal.h	/^    ImRect                  LastItemRect;$/;"	m	struct:ImGuiLastItemDataBackup
LastItemStatusFlags	imgui_internal.h	/^    ImGuiItemStatusFlags    LastItemStatusFlags;    \/\/ Status flags for last item (see ImGuiItemStatusFlags_)$/;"	m	struct:ImGuiWindowTempData
LastItemStatusFlags	imgui_internal.h	/^    ImGuiItemStatusFlags    LastItemStatusFlags;$/;"	m	struct:ImGuiLastItemDataBackup
LastOuterHeight	imgui_internal.h	/^    float                       LastOuterHeight;            \/\/ Outer height from last frame$/;"	m	struct:ImGuiTable
LastResizedColumn	imgui_internal.h	/^    ImGuiTableColumnIdx         LastResizedColumn;          \/\/ Index of column being resized from previous frame.$/;"	m	struct:ImGuiTable
LastRowFlags	imgui_internal.h	/^    ImGuiTableRowFlags          LastRowFlags : 16;$/;"	m	struct:ImGuiTable
LastTabItemIdx	imgui_internal.h	/^    ImS16               LastTabItemIdx;         \/\/ Index of last BeginTabItem() tab for use by EndTabItem()$/;"	m	struct:ImGuiTabBar
LastTimeActive	imgui_internal.h	/^    float                   LastTimeActive;                     \/\/ Last timestamp the window was Active (using float as we don't need high precision there)$/;"	m	struct:ImGuiWindow
LastValidMousePos	imgui_internal.h	/^    ImVec2                  LastValidMousePos;$/;"	m	struct:ImGuiContext
Layers	imgui_internal.h	/^    ImVector<ImDrawList*>   Layers[2];           \/\/ Global layers for: regular, tooltip$/;"	m	struct:ImDrawDataBuilder
LayoutType	imgui_internal.h	/^    ImGuiLayoutType         LayoutType;$/;"	m	struct:ImGuiWindowTempData
LeftMostEnabledColumn	imgui_internal.h	/^    ImGuiTableColumnIdx         LeftMostEnabledColumn;      \/\/ Index of left-most non-hidden column.$/;"	m	struct:ImGuiTable
LeftMostStretchedColumn	imgui_internal.h	/^    ImGuiTableColumnIdx         LeftMostStretchedColumn;    \/\/ Index of left-most stretched column.$/;"	m	struct:ImGuiTable
LineMaxY	imgui_internal.h	/^    float               LineMinY, LineMaxY;$/;"	m	struct:ImGuiOldColumns
LineMinY	imgui_internal.h	/^    float               LineMinY, LineMaxY;$/;"	m	struct:ImGuiOldColumns
LineOffsets	imgui_demo.cpp	/^    ImVector<int>       LineOffsets; \/\/ Index to lines offset. We maintain this with AddLog() calls.$/;"	m	struct:ExampleAppLog	file:
ListBox	imgui_widgets.cpp	/^bool ImGui::ListBox(const char* label, int* current_item, bool (*items_getter)(void*, int, const char**), void* data, int items_count, int height_in_items)$/;"	f	class:ImGui
ListBox	imgui_widgets.cpp	/^bool ImGui::ListBox(const char* label, int* current_item, const char* const items[], int items_count, int height_items)$/;"	f	class:ImGui
ListBoxFooter	imgui.h	/^    static inline void  ListBoxFooter() { EndListBox(); }$/;"	f	namespace:ImGui
ListBoxHeader	imgui.h	/^    static inline bool  ListBoxHeader(const char* label, const ImVec2& size = ImVec2(0, 0)) { return BeginListBox(label, size); }$/;"	f	namespace:ImGui
ListBoxHeader	imgui_widgets.cpp	/^bool ImGui::ListBoxHeader(const char* label, int items_count, int height_in_items)$/;"	f	class:ImGui
LoadIniSettingsFromDisk	imgui.cpp	/^void ImGui::LoadIniSettingsFromDisk(const char* ini_filename)$/;"	f	class:ImGui
LoadIniSettingsFromMemory	imgui.cpp	/^void ImGui::LoadIniSettingsFromMemory(const char* ini_data, size_t ini_size)$/;"	f	class:ImGui
Locked	imgui.h	/^    bool                        Locked;             \/\/ Marked as Locked by ImGui::NewFrame() so attempt to modify the atlas will assert.$/;"	m	struct:ImFontAtlas
LogBegin	imgui.cpp	/^void ImGui::LogBegin(ImGuiLogType type, int auto_open_depth)$/;"	f	class:ImGui
LogBuffer	imgui_internal.h	/^    ImGuiTextBuffer         LogBuffer;                          \/\/ Accumulation buffer when log to clipboard. This is pointer so our GImGui static constructor doesn't call heap allocators.$/;"	m	struct:ImGuiContext
LogButtons	imgui.cpp	/^void ImGui::LogButtons()$/;"	f	class:ImGui
LogDepthRef	imgui_internal.h	/^    int                     LogDepthRef;$/;"	m	struct:ImGuiContext
LogDepthToExpand	imgui_internal.h	/^    int                     LogDepthToExpand;$/;"	m	struct:ImGuiContext
LogDepthToExpandDefault	imgui_internal.h	/^    int                     LogDepthToExpandDefault;            \/\/ Default\/stored value for LogDepthMaxExpand if not specified in the LogXXX function call.$/;"	m	struct:ImGuiContext
LogEnabled	imgui_internal.h	/^    bool                    LogEnabled;                         \/\/ Currently capturing$/;"	m	struct:ImGuiContext
LogFile	imgui_internal.h	/^    ImFileHandle            LogFile;                            \/\/ If != NULL log to stdout\/ file$/;"	m	struct:ImGuiContext
LogFilename	imgui.h	/^    const char* LogFilename;                    \/\/ = "imgui_log.txt"\/\/ Path to .log file (default parameter to ImGui::LogToFile when no file is specified).$/;"	m	struct:ImGuiIO
LogFinish	imgui.cpp	/^void ImGui::LogFinish()$/;"	f	class:ImGui
LogLineFirstItem	imgui_internal.h	/^    bool                    LogLineFirstItem;$/;"	m	struct:ImGuiContext
LogLinePosY	imgui_internal.h	/^    float                   LogLinePosY;$/;"	m	struct:ImGuiContext
LogNextPrefix	imgui_internal.h	/^    const char*             LogNextPrefix;$/;"	m	struct:ImGuiContext
LogNextSuffix	imgui_internal.h	/^    const char*             LogNextSuffix;$/;"	m	struct:ImGuiContext
LogRenderedText	imgui.cpp	/^void ImGui::LogRenderedText(const ImVec2* ref_pos, const char* text, const char* text_end)$/;"	f	class:ImGui
LogSetNextTextDecoration	imgui.cpp	/^void ImGui::LogSetNextTextDecoration(const char* prefix, const char* suffix)$/;"	f	class:ImGui
LogSliderDeadzone	imgui.h	/^    float       LogSliderDeadzone;          \/\/ The size in pixels of the dead-zone around zero on logarithmic sliders that cross zero.$/;"	m	struct:ImGuiStyle
LogText	imgui.cpp	/^void ImGui::LogText(const char* fmt, ...)$/;"	f	class:ImGui
LogTextV	imgui.cpp	/^static inline void LogTextV(ImGuiContext& g, const char* fmt, va_list args)$/;"	f	file:
LogTextV	imgui.cpp	/^void ImGui::LogTextV(const char* fmt, va_list args)$/;"	f	class:ImGui
LogToBuffer	imgui.cpp	/^void ImGui::LogToBuffer(int auto_open_depth)$/;"	f	class:ImGui
LogToClipboard	imgui.cpp	/^void ImGui::LogToClipboard(int auto_open_depth)$/;"	f	class:ImGui
LogToFile	imgui.cpp	/^void ImGui::LogToFile(int auto_open_depth, const char* filename)$/;"	f	class:ImGui
LogToTTY	imgui.cpp	/^void ImGui::LogToTTY(int auto_open_depth)$/;"	f	class:ImGui
LogType	imgui_internal.h	/^    ImGuiLogType            LogType;                            \/\/ Capture target$/;"	m	struct:ImGuiContext
LowerBound	imgui.cpp	/^static ImGuiStorage::ImGuiStoragePair* LowerBound(ImVector<ImGuiStorage::ImGuiStoragePair>& data, ImGuiID key)$/;"	f	file:
MallocWrapper	imgui.cpp	/^static void*   MallocWrapper(size_t size, void* user_data)    { IM_UNUSED(user_data); IM_UNUSED(size); IM_ASSERT(0); return NULL; }$/;"	f	file:
MallocWrapper	imgui.cpp	/^static void*   MallocWrapper(size_t size, void* user_data)    { IM_UNUSED(user_data); return malloc(size); }$/;"	f	file:
Map	imgui_internal.h	/^    ImGuiStorage    Map;        \/\/ ID->Index$/;"	m	struct:ImPool
MarkIniSettingsDirty	imgui.cpp	/^void ImGui::MarkIniSettingsDirty()$/;"	f	class:ImGui
MarkIniSettingsDirty	imgui.cpp	/^void ImGui::MarkIniSettingsDirty(ImGuiWindow* window)$/;"	f	class:ImGui
MarkItemEdited	imgui.cpp	/^void ImGui::MarkItemEdited(ImGuiID id)$/;"	f	class:ImGui
Max	imgui_internal.h	/^    ImVec2      Max;    \/\/ Lower-right$/;"	m	struct:ImRect
MaxX	imgui_internal.h	/^    float                   MaxX;$/;"	m	struct:ImGuiTableColumn
MemAlloc	imgui.cpp	/^void* ImGui::MemAlloc(size_t size)$/;"	f	class:ImGui
MemFree	imgui.cpp	/^void ImGui::MemFree(void* ptr)$/;"	f	class:ImGui
MemoryCompacted	imgui_internal.h	/^    bool                        MemoryCompacted;$/;"	m	struct:ImGuiTable
MemoryCompacted	imgui_internal.h	/^    bool                    MemoryCompacted;                    \/\/ Set when window extraneous data have been garbage collected$/;"	m	struct:ImGuiWindow
MemoryDrawListIdxCapacity	imgui_internal.h	/^    int                     MemoryDrawListIdxCapacity;          \/\/ Backup of last idx\/vtx count, so when waking up the window we can preallocate and avoid iterative alloc\/copy$/;"	m	struct:ImGuiWindow
MemoryDrawListVtxCapacity	imgui_internal.h	/^    int                     MemoryDrawListVtxCapacity;$/;"	m	struct:ImGuiWindow
MenuBarAppending	imgui_internal.h	/^    bool                    MenuBarAppending;       \/\/ FIXME: Remove this$/;"	m	struct:ImGuiWindowTempData
MenuBarHeight	imgui_internal.h	/^    float       MenuBarHeight() const   { ImGuiContext& g = *GImGui; return (Flags & ImGuiWindowFlags_MenuBar) ? DC.MenuBarOffset.y + CalcFontSize() + g.Style.FramePadding.y * 2.0f : 0.0f; }$/;"	f	struct:ImGuiWindow
MenuBarOffset	imgui_internal.h	/^    ImVec2                  MenuBarOffset;          \/\/ MenuBarOffset.x is sort of equivalent of a per-layer CursorPos.x, saved\/restored as we switch to the menu bar. The only situation when MenuBarOffset.y is > 0 if when (SafeAreaPadding.y > FramePadding.y), often used on TVs.$/;"	m	struct:ImGuiWindowTempData
MenuBarOffsetMinVal	imgui_internal.h	/^    ImVec2                      MenuBarOffsetMinVal;    \/\/ *Always on* This is not exposed publicly, so we don't clear it.$/;"	m	struct:ImGuiNextWindowData
MenuBarRect	imgui_internal.h	/^    ImRect      MenuBarRect() const     { float y1 = Pos.y + TitleBarHeight(); return ImRect(Pos.x, y1, Pos.x + SizeFull.x, y1 + MenuBarHeight()); }$/;"	f	struct:ImGuiWindow
MenuColumns	imgui_internal.h	/^    ImGuiMenuColumns        MenuColumns;            \/\/ Simplified columns storage for menu items measurement$/;"	m	struct:ImGuiWindowTempData
MenuItem	imgui_widgets.cpp	/^bool ImGui::MenuItem(const char* label, const char* shortcut, bool selected, bool enabled)$/;"	f	class:ImGui
MenuItem	imgui_widgets.cpp	/^bool ImGui::MenuItem(const char* label, const char* shortcut, bool* p_selected, bool enabled)$/;"	f	class:ImGui
MenusIdSubmittedThisFrame	imgui_internal.h	/^    ImVector<ImGuiID>       MenusIdSubmittedThisFrame;          \/\/ A list of menu IDs that were rendered at least once$/;"	m	struct:ImGuiContext
Merge	imgui_draw.cpp	/^void ImDrawListSplitter::Merge(ImDrawList* draw_list)$/;"	f	class:ImDrawListSplitter
MergeMode	imgui.h	/^    bool            MergeMode;              \/\/ false    \/\/ Merge into previous ImFont, so you can combine multiple inputs font into one ImFont (e.g. ASCII font + icons + Japanese glyphs). You may want to use GlyphOffset.y when merge font of different heights.$/;"	m	struct:ImFontConfig
MetricsActiveAllocations	imgui.h	/^    int         MetricsActiveAllocations;       \/\/ Number of active allocations, updated by MemAlloc\/MemFree based on current context. May be off if you have multiple imgui contexts.$/;"	m	struct:ImGuiIO
MetricsActiveWindows	imgui.h	/^    int         MetricsActiveWindows;           \/\/ Number of active windows$/;"	m	struct:ImGuiIO
MetricsHelpMarker	imgui.cpp	/^static void MetricsHelpMarker(const char* desc)$/;"	f	file:
MetricsRenderIndices	imgui.h	/^    int         MetricsRenderIndices;           \/\/ Indices output during last call to Render() = number of triangles * 3$/;"	m	struct:ImGuiIO
MetricsRenderVertices	imgui.h	/^    int         MetricsRenderVertices;          \/\/ Vertices output during last call to Render()$/;"	m	struct:ImGuiIO
MetricsRenderWindows	imgui.h	/^    int         MetricsRenderWindows;           \/\/ Number of visible windows$/;"	m	struct:ImGuiIO
MetricsTotalSurface	imgui.h	/^    int                         MetricsTotalSurface;\/\/ 4     \/\/ out \/\/            \/\/ Total surface in pixels to get an idea of the font rasterization\/texture cost (not exact, we approximate the cost of padding between glyphs)$/;"	m	struct:ImFont
Min	imgui_internal.h	/^    ImVec2      Min;    \/\/ Upper-left$/;"	m	struct:ImRect
MinColumnWidth	imgui_internal.h	/^    float                       MinColumnWidth;$/;"	m	struct:ImGuiTable
MinX	imgui_internal.h	/^    float                   MinX;                           \/\/ Absolute positions$/;"	m	struct:ImGuiTableColumn
MouseClicked	imgui.h	/^    bool        MouseClicked[5];                \/\/ Mouse button went from !Down to Down$/;"	m	struct:ImGuiIO
MouseClickedPos	imgui.h	/^    ImVec2      MouseClickedPos[5];             \/\/ Position at time of clicking$/;"	m	struct:ImGuiIO
MouseClickedTime	imgui.h	/^    double      MouseClickedTime[5];            \/\/ Time of last click (used to figure out double-click)$/;"	m	struct:ImGuiIO
MouseCursor	imgui_internal.h	/^    ImGuiMouseCursor        MouseCursor;$/;"	m	struct:ImGuiContext
MouseCursorScale	imgui.h	/^    float       MouseCursorScale;           \/\/ Scale software rendered mouse cursor (when io.MouseDrawCursor is enabled). May be removed later.$/;"	m	struct:ImGuiStyle
MouseDelta	imgui.h	/^    ImVec2      MouseDelta;                     \/\/ Mouse delta. Note that this is zero if either current or previous position are invalid (-FLT_MAX,-FLT_MAX), so a disappearing\/reappearing mouse won't have a huge delta.$/;"	m	struct:ImGuiIO
MouseDoubleClickMaxDist	imgui.h	/^    float       MouseDoubleClickMaxDist;        \/\/ = 6.0f           \/\/ Distance threshold to stay in to validate a double-click, in pixels.$/;"	m	struct:ImGuiIO
MouseDoubleClickTime	imgui.h	/^    float       MouseDoubleClickTime;           \/\/ = 0.30f          \/\/ Time for a double-click, in seconds.$/;"	m	struct:ImGuiIO
MouseDoubleClicked	imgui.h	/^    bool        MouseDoubleClicked[5];          \/\/ Has mouse button been double-clicked?$/;"	m	struct:ImGuiIO
MouseDown	imgui.h	/^    bool        MouseDown[5];                   \/\/ Mouse buttons: 0=left, 1=right, 2=middle + extras (ImGuiMouseButton_COUNT == 5). Dear ImGui mostly uses left and right buttons. Others buttons allows us to track if the mouse is being used by your application + available to user as a convenience via IsMouse** API.$/;"	m	struct:ImGuiIO
MouseDownDuration	imgui.h	/^    float       MouseDownDuration[5];           \/\/ Duration the mouse button has been down (0.0f == just clicked)$/;"	m	struct:ImGuiIO
MouseDownDurationPrev	imgui.h	/^    float       MouseDownDurationPrev[5];       \/\/ Previous time the mouse button has been down$/;"	m	struct:ImGuiIO
MouseDownOwned	imgui.h	/^    bool        MouseDownOwned[5];              \/\/ Track if button was clicked inside a dear imgui window. We don't request mouse capture from the application if click started outside ImGui bounds.$/;"	m	struct:ImGuiIO
MouseDownWasDoubleClick	imgui.h	/^    bool        MouseDownWasDoubleClick[5];     \/\/ Track if button down was a double-click$/;"	m	struct:ImGuiIO
MouseDragMaxDistanceAbs	imgui.h	/^    ImVec2      MouseDragMaxDistanceAbs[5];     \/\/ Maximum distance, absolute, on each axis, of how much mouse has traveled from the clicking point$/;"	m	struct:ImGuiIO
MouseDragMaxDistanceSqr	imgui.h	/^    float       MouseDragMaxDistanceSqr[5];     \/\/ Squared maximum distance of how much mouse has traveled from the clicking point$/;"	m	struct:ImGuiIO
MouseDragThreshold	imgui.h	/^    float       MouseDragThreshold;             \/\/ = 6.0f           \/\/ Distance threshold before considering we are dragging.$/;"	m	struct:ImGuiIO
MouseDrawCursor	imgui.h	/^    bool        MouseDrawCursor;                \/\/ = false          \/\/ Request ImGui to draw a mouse cursor for you (if you are on a platform without a mouse cursor). Cannot be easily renamed to 'io.ConfigXXX' because this is frequently used by backend implementations.$/;"	m	struct:ImGuiIO
MousePos	imgui.h	/^    ImVec2      MousePos;                       \/\/ Mouse position, in pixels. Set to ImVec2(-FLT_MAX, -FLT_MAX) if mouse is unavailable (on another screen, etc.)$/;"	m	struct:ImGuiIO
MousePosPrev	imgui.h	/^    ImVec2      MousePosPrev;                   \/\/ Previous mouse position (note that MouseDelta is not necessary == MousePos-MousePosPrev, in case either position is invalid)$/;"	m	struct:ImGuiIO
MouseReleased	imgui.h	/^    bool        MouseReleased[5];               \/\/ Mouse button went from Down to !Down$/;"	m	struct:ImGuiIO
MouseWheel	imgui.h	/^    float       MouseWheel;                     \/\/ Mouse wheel Vertical: 1 unit scrolls about 5 lines text.$/;"	m	struct:ImGuiIO
MouseWheelH	imgui.h	/^    float       MouseWheelH;                    \/\/ Mouse wheel Horizontal. Most users don't have a mouse with an horizontal wheel, may not be filled by all backends.$/;"	m	struct:ImGuiIO
MoveId	imgui_internal.h	/^    ImGuiID                 MoveId;                             \/\/ == window->GetID("#MOVE")$/;"	m	struct:ImGuiWindow
MovingWindow	imgui_internal.h	/^    ImGuiWindow*            MovingWindow;                       \/\/ Track the window we clicked on (in order to preserve focus). The actual window that is moved is generally MovingWindow->RootWindow.$/;"	m	struct:ImGuiContext
MyDocument	imgui_demo.cpp	/^    MyDocument(const char* name, bool open = true, const ImVec4& color = ImVec4(1.0f, 1.0f, 1.0f, 1.0f))$/;"	f	struct:MyDocument
MyDocument	imgui_demo.cpp	/^struct MyDocument$/;"	s	file:
MyItem	imgui_demo.cpp	/^struct MyItem$/;"	s	namespace:__anon29	file:
MyItemColumnID	imgui_demo.cpp	/^enum MyItemColumnID$/;"	g	namespace:__anon29	file:
MyItemColumnID_Action	imgui_demo.cpp	/^    MyItemColumnID_Action,$/;"	e	enum:__anon29::MyItemColumnID	file:
MyItemColumnID_Description	imgui_demo.cpp	/^    MyItemColumnID_Description$/;"	e	enum:__anon29::MyItemColumnID	file:
MyItemColumnID_ID	imgui_demo.cpp	/^    MyItemColumnID_ID,$/;"	e	enum:__anon29::MyItemColumnID	file:
MyItemColumnID_Name	imgui_demo.cpp	/^    MyItemColumnID_Name,$/;"	e	enum:__anon29::MyItemColumnID	file:
MyItemColumnID_Quantity	imgui_demo.cpp	/^    MyItemColumnID_Quantity,$/;"	e	enum:__anon29::MyItemColumnID	file:
NAV_MAP_KEY	imgui.cpp	/^        #define NAV_MAP_KEY(/;"	d	file:
NAV_MAP_KEY	imgui.cpp	/^        #undef NAV_MAP_KEY$/;"	d	file:
NAV_WINDOWING_HIGHLIGHT_DELAY	imgui.cpp	/^static const float NAV_WINDOWING_HIGHLIGHT_DELAY            = 0.20f;    \/\/ Time before the highlight and screen dimming starts fading in$/;"	v	file:
NAV_WINDOWING_LIST_APPEAR_DELAY	imgui.cpp	/^static const float NAV_WINDOWING_LIST_APPEAR_DELAY          = 0.15f;    \/\/ Time before the window list starts to appear$/;"	v	file:
NOMINMAX	imgui.cpp	/^#define NOMINMAX$/;"	d	file:
Name	imgui.h	/^    char            Name[40];               \/\/ Name (strictly to ease debugging)$/;"	m	struct:ImFontConfig
Name	imgui_demo.cpp	/^    const char* Name;       \/\/ Document title$/;"	m	struct:MyDocument	file:
Name	imgui_demo.cpp	/^    const char* Name;$/;"	m	struct:__anon29::MyItem	file:
Name	imgui_internal.h	/^    char*                   Name;                               \/\/ Window name, owned by the window.$/;"	m	struct:ImGuiWindow
Name	imgui_internal.h	/^    const char* Name;           \/\/ Short descriptive name for the type, for debugging$/;"	m	struct:ImGuiDataTypeInfo
NameBufLen	imgui_internal.h	/^    int                     NameBufLen;                         \/\/ Size of buffer storing Name. May be larger than strlen(Name)!$/;"	m	struct:ImGuiWindow
NameOffset	imgui_internal.h	/^    ImS16                   NameOffset;                     \/\/ Offset into parent ColumnsNames[]$/;"	m	struct:ImGuiTableColumn
NameOffset	imgui_internal.h	/^    ImS16               NameOffset;             \/\/ When Window==NULL, offset to name within parent ImGuiTabBar::TabsNames$/;"	m	struct:ImGuiTabItem
NavActivateDownId	imgui_internal.h	/^    ImGuiID                 NavActivateDownId;                  \/\/ ~~ IsNavInputDown(ImGuiNavInput_Activate) ? NavId : 0$/;"	m	struct:ImGuiContext
NavActivateId	imgui_internal.h	/^    ImGuiID                 NavActivateId;                      \/\/ ~~ (g.ActiveId == 0) && IsNavInputPressed(ImGuiNavInput_Activate) ? NavId : 0, also set when calling ActivateItem()$/;"	m	struct:ImGuiContext
NavActivatePressedId	imgui_internal.h	/^    ImGuiID                 NavActivatePressedId;               \/\/ ~~ IsNavInputPressed(ImGuiNavInput_Activate) ? NavId : 0$/;"	m	struct:ImGuiContext
NavActive	imgui.h	/^    bool        NavActive;                      \/\/ Keyboard\/Gamepad navigation is currently allowed (will handle ImGuiKey_NavXXX events) = a window is focused and it doesn't use the ImGuiWindowFlags_NoNavInputs flag.$/;"	m	struct:ImGuiIO
NavAnyRequest	imgui_internal.h	/^    bool                    NavAnyRequest;                      \/\/ ~~ NavMoveRequest || NavInitRequest$/;"	m	struct:ImGuiContext
NavApplyItemToResult	imgui.cpp	/^static void ImGui::NavApplyItemToResult(ImGuiNavItemData* result, ImGuiWindow* window, ImGuiID id, const ImRect& nav_bb_rel)$/;"	f	class:ImGui
NavCalcPreferredRefPos	imgui.cpp	/^static ImVec2 ImGui::NavCalcPreferredRefPos()$/;"	f	class:ImGui
NavClampRectToVisibleAreaForMoveDir	imgui.cpp	/^static void inline NavClampRectToVisibleAreaForMoveDir(ImGuiDir move_dir, ImRect& r, const ImRect& clip_rect)$/;"	f	file:
NavDisableHighlight	imgui_internal.h	/^    bool                    NavDisableHighlight;                \/\/ When user starts using mouse, we hide gamepad\/keyboard highlight (NB: but they are still available, which is why NavDisableHighlight isn't always != NavDisableMouseHover)$/;"	m	struct:ImGuiContext
NavDisableMouseHover	imgui_internal.h	/^    bool                    NavDisableMouseHover;               \/\/ When user starts using gamepad\/keyboard, we hide mouse hovering highlight until mouse is touched again.$/;"	m	struct:ImGuiContext
NavEndFrame	imgui.cpp	/^static void ImGui::NavEndFrame()$/;"	f	class:ImGui
NavFocusScopeId	imgui_internal.h	/^    ImGuiID                 NavFocusScopeId;                    \/\/ Identify a selection scope (selection code often wants to "clear other items" when landing on an item of the selection set)$/;"	m	struct:ImGuiContext
NavFocusScopeIdCurrent	imgui_internal.h	/^    ImGuiID                 NavFocusScopeIdCurrent; \/\/ Current focus scope ID while appending$/;"	m	struct:ImGuiWindowTempData
NavHasScroll	imgui_internal.h	/^    bool                    NavHasScroll;           \/\/ Set when scrolling can be used (ScrollMax > 0.0f)$/;"	m	struct:ImGuiWindowTempData
NavHideHighlightOneFrame	imgui_internal.h	/^    bool                    NavHideHighlightOneFrame;$/;"	m	struct:ImGuiWindowTempData
NavId	imgui_internal.h	/^    ImGuiID                 NavId;                              \/\/ Focused item for navigation$/;"	m	struct:ImGuiContext
NavIdIsAlive	imgui_internal.h	/^    bool                    NavIdIsAlive;                       \/\/ Nav widget has been seen this frame ~~ NavRectRel is valid$/;"	m	struct:ImGuiContext
NavIdTabCounter	imgui_internal.h	/^    int                     NavIdTabCounter;                    \/\/ == NavWindow->DC.FocusIdxTabCounter at time of NavId processing$/;"	m	struct:ImGuiContext
NavInitRequest	imgui_internal.h	/^    bool                    NavInitRequest;                     \/\/ Init request for appearing window to select first item$/;"	m	struct:ImGuiContext
NavInitRequestFromMove	imgui_internal.h	/^    bool                    NavInitRequestFromMove;$/;"	m	struct:ImGuiContext
NavInitResultId	imgui_internal.h	/^    ImGuiID                 NavInitResultId;                    \/\/ Init request result (first item of the window, or one for which SetItemDefaultFocus() was called)$/;"	m	struct:ImGuiContext
NavInitResultRectRel	imgui_internal.h	/^    ImRect                  NavInitResultRectRel;               \/\/ Init request result rectangle (relative to parent window)$/;"	m	struct:ImGuiContext
NavInitWindow	imgui.cpp	/^void ImGui::NavInitWindow(ImGuiWindow* window, bool force_reinit)$/;"	f	class:ImGui
NavInputId	imgui_internal.h	/^    ImGuiID                 NavInputId;                         \/\/ ~~ IsNavInputPressed(ImGuiNavInput_Input) ? NavId : 0$/;"	m	struct:ImGuiContext
NavInputSource	imgui_internal.h	/^    ImGuiInputSource        NavInputSource;                     \/\/ Keyboard or Gamepad mode? THIS WILL ONLY BE None or NavGamepad or NavKeyboard.$/;"	m	struct:ImGuiContext
NavInputs	imgui.h	/^    float       NavInputs[ImGuiNavInput_COUNT]; \/\/ Gamepad inputs. Cleared back to zero by EndFrame(). Keyboard keys will be auto-mapped and be written here by NewFrame().$/;"	m	struct:ImGuiIO
NavInputsDownDuration	imgui.h	/^    float       NavInputsDownDuration[ImGuiNavInput_COUNT];$/;"	m	struct:ImGuiIO
NavInputsDownDurationPrev	imgui.h	/^    float       NavInputsDownDurationPrev[ImGuiNavInput_COUNT];$/;"	m	struct:ImGuiIO
NavJustMovedToFocusScopeId	imgui_internal.h	/^    ImGuiID                 NavJustMovedToFocusScopeId;         \/\/ Just navigated to this focus scope id (result of a successfully MoveRequest).$/;"	m	struct:ImGuiContext
NavJustMovedToId	imgui_internal.h	/^    ImGuiID                 NavJustMovedToId;                   \/\/ Just navigated to this id (result of a successfully MoveRequest).$/;"	m	struct:ImGuiContext
NavJustMovedToKeyMods	imgui_internal.h	/^    ImGuiKeyModFlags        NavJustMovedToKeyMods;$/;"	m	struct:ImGuiContext
NavJustTabbedId	imgui_internal.h	/^    ImGuiID                 NavJustTabbedId;                    \/\/ Just tabbed to this id.$/;"	m	struct:ImGuiContext
NavLastChildNavWindow	imgui_internal.h	/^    ImGuiWindow*            NavLastChildNavWindow;              \/\/ When going to the menu bar, we remember the child window we came from. (This could probably be made implicit if we kept g.Windows sorted by last focused including child window.)$/;"	m	struct:ImGuiWindow
NavLastIds	imgui_internal.h	/^    ImGuiID                 NavLastIds[ImGuiNavLayer_COUNT];    \/\/ Last known NavId for this window, per layer (0\/1)$/;"	m	struct:ImGuiWindow
NavLayer	imgui_internal.h	/^    ImGuiNavLayer           NavLayer;                           \/\/ Layer we are navigating on. For now the system is hard-coded for 0=main contents and 1=menu\/title bar, may expose layers later.$/;"	m	struct:ImGuiContext
NavLayerCurrent	imgui_internal.h	/^    ImGuiNavLayer           NavLayerCurrent;        \/\/ Current layer, 0..31 (we currently only use 0..1)$/;"	m	struct:ImGuiWindowTempData
NavLayerCurrent	imgui_internal.h	/^    ImS8                    NavLayerCurrent;                \/\/ ImGuiNavLayer in 1 byte$/;"	m	struct:ImGuiTableColumn
NavLayersActiveMask	imgui_internal.h	/^    short                   NavLayersActiveMask;    \/\/ Which layers have been written to (result from previous frame)$/;"	m	struct:ImGuiWindowTempData
NavLayersActiveMaskNext	imgui_internal.h	/^    short                   NavLayersActiveMaskNext;\/\/ Which layers have been written to (accumulator for current frame)$/;"	m	struct:ImGuiWindowTempData
NavMousePosDirty	imgui_internal.h	/^    bool                    NavMousePosDirty;                   \/\/ When set we will update mouse position if (io.ConfigFlags & ImGuiConfigFlags_NavEnableSetMousePos) if set (NB: this not enabled by default)$/;"	m	struct:ImGuiContext
NavMoveClipDir	imgui_internal.h	/^    ImGuiDir                NavMoveClipDir;                     \/\/ FIXME-NAV: Describe the purpose of this better. Might want to rename?$/;"	m	struct:ImGuiContext
NavMoveDir	imgui_internal.h	/^    ImGuiDir                NavMoveDir, NavMoveDirLast;         \/\/ Direction of the move request (left\/right\/up\/down), direction of the previous move request$/;"	m	struct:ImGuiContext
NavMoveDirLast	imgui_internal.h	/^    ImGuiDir                NavMoveDir, NavMoveDirLast;         \/\/ Direction of the move request (left\/right\/up\/down), direction of the previous move request$/;"	m	struct:ImGuiContext
NavMoveRequest	imgui_internal.h	/^    bool                    NavMoveRequest;                     \/\/ Move request for this frame$/;"	m	struct:ImGuiContext
NavMoveRequestButNoResultYet	imgui.cpp	/^bool ImGui::NavMoveRequestButNoResultYet()$/;"	f	class:ImGui
NavMoveRequestCancel	imgui.cpp	/^void ImGui::NavMoveRequestCancel()$/;"	f	class:ImGui
NavMoveRequestFlags	imgui_internal.h	/^    ImGuiNavMoveFlags       NavMoveRequestFlags;$/;"	m	struct:ImGuiContext
NavMoveRequestForward	imgui.cpp	/^void ImGui::NavMoveRequestForward(ImGuiDir move_dir, ImGuiDir clip_dir, const ImRect& bb_rel, ImGuiNavMoveFlags move_flags)$/;"	f	class:ImGui
NavMoveRequestForward	imgui_internal.h	/^    ImGuiNavForward         NavMoveRequestForward;              \/\/ None \/ ForwardQueued \/ ForwardActive (this is used to navigate sibling parent menus from a child menu)$/;"	m	struct:ImGuiContext
NavMoveRequestKeyMods	imgui_internal.h	/^    ImGuiKeyModFlags        NavMoveRequestKeyMods;$/;"	m	struct:ImGuiContext
NavMoveRequestTryWrapping	imgui.cpp	/^void ImGui::NavMoveRequestTryWrapping(ImGuiWindow* window, ImGuiNavMoveFlags move_flags)$/;"	f	class:ImGui
NavMoveResultLocal	imgui_internal.h	/^    ImGuiNavItemData        NavMoveResultLocal;                 \/\/ Best move request candidate within NavWindow$/;"	m	struct:ImGuiContext
NavMoveResultLocalVisibleSet	imgui_internal.h	/^    ImGuiNavItemData        NavMoveResultLocalVisibleSet;       \/\/ Best move request candidate within NavWindow that are mostly visible (when using ImGuiNavMoveFlags_AlsoScoreVisibleSet flag)$/;"	m	struct:ImGuiContext
NavMoveResultOther	imgui_internal.h	/^    ImGuiNavItemData        NavMoveResultOther;                 \/\/ Best move request candidate within NavWindow's flattened hierarchy (when using ImGuiWindowFlags_NavFlattened flag)$/;"	m	struct:ImGuiContext
NavNextActivateId	imgui_internal.h	/^    ImGuiID                 NavNextActivateId;                  \/\/ Set by ActivateItem(), queued until next frame.$/;"	m	struct:ImGuiContext
NavProcessItem	imgui.cpp	/^static void ImGui::NavProcessItem(ImGuiWindow* window, const ImRect& nav_bb, const ImGuiID id)$/;"	f	class:ImGui
NavRectRel	imgui_internal.h	/^    ImRect                  NavRectRel[ImGuiNavLayer_COUNT];    \/\/ Reference rectangle, in window relative space$/;"	m	struct:ImGuiWindow
NavRestoreLastChildNavWindow	imgui.cpp	/^static ImGuiWindow* ImGui::NavRestoreLastChildNavWindow(ImGuiWindow* window)$/;"	f	class:ImGui
NavRestoreLayer	imgui.cpp	/^void ImGui::NavRestoreLayer(ImGuiNavLayer layer)$/;"	f	class:ImGui
NavSaveLastChildNavWindowIntoParent	imgui.cpp	/^static void ImGui::NavSaveLastChildNavWindowIntoParent(ImGuiWindow* nav_window)$/;"	f	class:ImGui
NavScoreItem	imgui.cpp	/^static bool ImGui::NavScoreItem(ImGuiNavItemData* result, ImRect cand)$/;"	f	class:ImGui
NavScoreItemDistInterval	imgui.cpp	/^static float inline NavScoreItemDistInterval(float a0, float a1, float b0, float b1)$/;"	f	file:
NavScoringCount	imgui_internal.h	/^    int                     NavScoringCount;                    \/\/ Metrics for debugging$/;"	m	struct:ImGuiContext
NavScoringRect	imgui_internal.h	/^    ImRect                  NavScoringRect;                     \/\/ Rectangle used for scoring, in screen space. Based of window->NavRectRel[], modified for directional navigation scoring.$/;"	m	struct:ImGuiContext
NavUpdate	imgui.cpp	/^static void ImGui::NavUpdate()$/;"	f	class:ImGui
NavUpdateAnyRequestFlag	imgui.cpp	/^static inline void ImGui::NavUpdateAnyRequestFlag()$/;"	f	class:ImGui
NavUpdateInitResult	imgui.cpp	/^static void ImGui::NavUpdateInitResult()$/;"	f	class:ImGui
NavUpdateMoveResult	imgui.cpp	/^static void ImGui::NavUpdateMoveResult()$/;"	f	class:ImGui
NavUpdatePageUpPageDown	imgui.cpp	/^static float ImGui::NavUpdatePageUpPageDown()$/;"	f	class:ImGui
NavUpdateWindowing	imgui.cpp	/^static void ImGui::NavUpdateWindowing()$/;"	f	class:ImGui
NavUpdateWindowingHighlightWindow	imgui.cpp	/^static void NavUpdateWindowingHighlightWindow(int focus_change_dir)$/;"	f	file:
NavUpdateWindowingOverlay	imgui.cpp	/^void ImGui::NavUpdateWindowingOverlay()$/;"	f	class:ImGui
NavVisible	imgui.h	/^    bool        NavVisible;                     \/\/ Keyboard\/Gamepad navigation is visible and allowed (will handle ImGuiKey_NavXXX events).$/;"	m	struct:ImGuiIO
NavWindow	imgui_internal.h	/^    ImGuiWindow*            NavWindow;                          \/\/ Focused window for navigation. Could be called 'FocusWindow'$/;"	m	struct:ImGuiContext
NavWindowingHighlightAlpha	imgui_internal.h	/^    float                   NavWindowingHighlightAlpha;$/;"	m	struct:ImGuiContext
NavWindowingListWindow	imgui_internal.h	/^    ImGuiWindow*            NavWindowingListWindow;             \/\/ Internal window actually listing the CTRL+Tab contents$/;"	m	struct:ImGuiContext
NavWindowingTarget	imgui_internal.h	/^    ImGuiWindow*            NavWindowingTarget;                 \/\/ Target window when doing CTRL+Tab (or Pad Menu + FocusPrev\/Next), this window is temporarily displayed top-most!$/;"	m	struct:ImGuiContext
NavWindowingTargetAnim	imgui_internal.h	/^    ImGuiWindow*            NavWindowingTargetAnim;             \/\/ Record of last valid NavWindowingTarget until DimBgRatio and NavWindowingHighlightAlpha becomes 0.0f, so the fade-out can stay on it.$/;"	m	struct:ImGuiContext
NavWindowingTimer	imgui_internal.h	/^    float                   NavWindowingTimer;$/;"	m	struct:ImGuiContext
NavWindowingToggleLayer	imgui_internal.h	/^    bool                    NavWindowingToggleLayer;$/;"	m	struct:ImGuiContext
NavWrapRequestFlags	imgui_internal.h	/^    ImGuiNavMoveFlags       NavWrapRequestFlags;                \/\/ Wrap-around operation flags.$/;"	m	struct:ImGuiContext
NavWrapRequestWindow	imgui_internal.h	/^    ImGuiWindow*            NavWrapRequestWindow;               \/\/ Window which requested trying nav wrap-around.$/;"	m	struct:ImGuiContext
NewFrame	imgui.cpp	/^void ImGui::NewFrame()$/;"	f	class:ImGui
NewLine	imgui_widgets.cpp	/^void ImGui::NewLine()$/;"	f	class:ImGui
NextColumn	imgui_tables.cpp	/^void ImGui::NextColumn()$/;"	f	class:ImGui
NextEnabledColumn	imgui_internal.h	/^    ImGuiTableColumnIdx     NextEnabledColumn;              \/\/ Index of next enabled\/visible column within Columns[], -1 if last enabled\/visible column$/;"	m	struct:ImGuiTableColumn
NextItemData	imgui_internal.h	/^    ImGuiNextItemData       NextItemData;                       \/\/ Storage for SetNextItem** functions$/;"	m	struct:ImGuiContext
NextSelectedTabId	imgui_internal.h	/^    ImGuiID             NextSelectedTabId;      \/\/ Next selected tab\/window. Will also trigger a scrolling animation$/;"	m	struct:ImGuiTabBar
NextWidth	imgui_internal.h	/^    float       Width, NextWidth;$/;"	m	struct:ImGuiMenuColumns
NextWidths	imgui_internal.h	/^    float       Pos[3], NextWidths[3];$/;"	m	struct:ImGuiMenuColumns
NextWindowData	imgui_internal.h	/^    ImGuiNextWindowData     NextWindowData;                     \/\/ Storage for SetNextWindow** functions$/;"	m	struct:ImGuiContext
NodeFont	imgui_demo.cpp	/^static void NodeFont(ImFont* font)$/;"	f	file:
NotifyOfDocumentsClosedElsewhere	imgui_demo.cpp	/^static void NotifyOfDocumentsClosedElsewhere(ExampleAppDocuments& app)$/;"	f	file:
OffMaxX	imgui_internal.h	/^    float               OffMinX, OffMaxX;       \/\/ Offsets from HostWorkRect.Min.x$/;"	m	struct:ImGuiOldColumns
OffMinX	imgui_internal.h	/^    float               OffMinX, OffMaxX;       \/\/ Offsets from HostWorkRect.Min.x$/;"	m	struct:ImGuiOldColumns
Offset	imgui.cpp	/^    ImU32           Offset;$/;"	m	struct:ImGuiStyleVarInfo	file:
Offset	imgui_internal.h	/^    float               Offset;                 \/\/ Position relative to beginning of tab$/;"	m	struct:ImGuiTabItem
OffsetNorm	imgui_internal.h	/^    float               OffsetNorm;         \/\/ Column start offset, normalized 0.0 (far left) -> 1.0 (far right)$/;"	m	struct:ImGuiOldColumnData
OffsetNormBeforeResize	imgui_internal.h	/^    float               OffsetNormBeforeResize;$/;"	m	struct:ImGuiOldColumnData
Offsets	imgui_internal.h	/^    int     Offsets[CHUNKS];$/;"	m	struct:ImSpanAllocator
OnKeyPressed	imgui_widgets.cpp	/^void ImGuiInputTextState::OnKeyPressed(int key)$/;"	f	class:ImGuiInputTextState
Open	imgui_demo.cpp	/^    bool        Open;       \/\/ Set when open (we keep an array of all available documents to simplify demo code!)$/;"	m	struct:MyDocument	file:
OpenCond	imgui_internal.h	/^    ImGuiCond                   OpenCond;$/;"	m	struct:ImGuiNextItemData
OpenFrameCount	imgui_internal.h	/^    int                 OpenFrameCount; \/\/ Set on OpenPopup()$/;"	m	struct:ImGuiPopupData
OpenMousePos	imgui_internal.h	/^    ImVec2              OpenMousePos;   \/\/ Set on OpenPopup(), copy of mouse position at the time of opening popup$/;"	m	struct:ImGuiPopupData
OpenParentId	imgui_internal.h	/^    ImGuiID             OpenParentId;   \/\/ Set on OpenPopup(), we need this to differentiate multiple menu sets from each others (e.g. inside menu bar vs loose menu items)$/;"	m	struct:ImGuiPopupData
OpenPopup	imgui.cpp	/^void ImGui::OpenPopup(ImGuiID id, ImGuiPopupFlags popup_flags)$/;"	f	class:ImGui
OpenPopup	imgui.cpp	/^void ImGui::OpenPopup(const char* str_id, ImGuiPopupFlags popup_flags)$/;"	f	class:ImGui
OpenPopupContextItem	imgui.h	/^    static inline void  OpenPopupContextItem(const char* str_id = NULL, ImGuiMouseButton mb = 1) { OpenPopupOnItemClick(str_id, mb); } \/\/ Bool return value removed. Use IsWindowAppearing() in BeginPopup() instead. Renamed in 1.77, renamed back in 1.79. Sorry!$/;"	f	namespace:ImGui
OpenPopupEx	imgui.cpp	/^void ImGui::OpenPopupEx(ImGuiID id, ImGuiPopupFlags popup_flags)$/;"	f	class:ImGui
OpenPopupOnItemClick	imgui.cpp	/^void ImGui::OpenPopupOnItemClick(const char* str_id, ImGuiPopupFlags popup_flags)$/;"	f	class:ImGui
OpenPopupPos	imgui_internal.h	/^    ImVec2              OpenPopupPos;   \/\/ Set on OpenPopup(), preferred popup position (typically == OpenMousePos when using mouse)$/;"	m	struct:ImGuiPopupData
OpenPopupStack	imgui_internal.h	/^    ImVector<ImGuiPopupData>OpenPopupStack;                     \/\/ Which popups are open (persistent)$/;"	m	struct:ImGuiContext
OpenPrev	imgui_demo.cpp	/^    bool        OpenPrev;   \/\/ Copy of Open from last update.$/;"	m	struct:MyDocument	file:
OpenVal	imgui_internal.h	/^    bool                        OpenVal;        \/\/ Set by SetNextItemOpen()$/;"	m	struct:ImGuiNextItemData
OuterAngle	imgui.cpp	/^    float  OuterAngle;$/;"	m	struct:ImGuiResizeBorderDef	file:
OuterPaddingX	imgui_internal.h	/^    float                       OuterPaddingX;$/;"	m	struct:ImGuiTable
OuterRect	imgui_internal.h	/^    ImRect                      OuterRect;                  \/\/ Note: for non-scrolling table, OuterRect.Max.y is often FLT_MAX until EndTable(), unless a height has been specified in BeginTable().$/;"	m	struct:ImGuiTable
OuterRectClipped	imgui_internal.h	/^    ImRect                  OuterRectClipped;                   \/\/ == Window->Rect() just after setup in Begin(). == window->Rect() for root window.$/;"	m	struct:ImGuiWindow
OuterWindow	imgui_internal.h	/^    ImGuiWindow*                OuterWindow;                \/\/ Parent window for the table$/;"	m	struct:ImGuiTable
Overlaps	imgui_internal.h	/^    bool        Overlaps(const ImRect& r) const     { return r.Min.y <  Max.y && r.Max.y >  Min.y && r.Min.x <  Max.x && r.Max.x >  Min.x; }$/;"	f	struct:ImRect
OversampleH	imgui.h	/^    int             OversampleH;            \/\/ 3        \/\/ Rasterize at higher quality for sub-pixel positioning. Note the difference between 2 and 3 is minimal so you can reduce this to 2 to save memory. Read https:\/\/github.com\/nothings\/stb\/blob\/master\/tests\/oversample\/README.md for details.$/;"	m	struct:ImFontConfig
OversampleV	imgui.h	/^    int             OversampleV;            \/\/ 1        \/\/ Rasterize at higher quality for sub-pixel positioning. This is not really useful as we don't use sub-pixel positions on the Y axis.$/;"	m	struct:ImFontConfig
Owner	imgui_internal.h	/^    ImGuiID                     Owner;$/;"	m	struct:ImGuiContextHook
PackIdLines	imgui.h	/^    int                         PackIdLines;        \/\/ Custom texture rectangle ID for baked anti-aliased lines$/;"	m	struct:ImFontAtlas
PackIdMouseCursors	imgui.h	/^    int                         PackIdMouseCursors; \/\/ Custom texture rectangle ID for white pixel and mouse cursors$/;"	m	struct:ImFontAtlas
PackRange	imgui_draw.cpp	/^    stbtt_pack_range    PackRange;          \/\/ Hold the list of codepoints to pack (essentially points to Codepoints.Data)$/;"	m	struct:ImFontBuildSrcData	file:
PackedChars	imgui_draw.cpp	/^    stbtt_packedchar*   PackedChars;        \/\/ Output glyphs$/;"	m	struct:ImFontBuildSrcData	file:
ParentLayoutType	imgui_internal.h	/^    ImGuiLayoutType         ParentLayoutType;       \/\/ Layout type of parent window at the time of Begin()$/;"	m	struct:ImGuiWindowTempData
ParentWindow	imgui_internal.h	/^    ImGuiWindow*            ParentWindow;                       \/\/ If we are a child _or_ popup window, this is pointing to our parent. Otherwise NULL.$/;"	m	struct:ImGuiWindow
ParentWorkRect	imgui_internal.h	/^    ImRect                  ParentWorkRect;                     \/\/ Backup of WorkRect before entering a container such as columns\/tables. Used by e.g. SpanAllColumns functions to easily access. Stacked containers are responsible for maintaining this. \/\/ FIXME-WORKRECT: Could be a stack?$/;"	m	struct:ImGuiWindow
PassFilter	imgui.cpp	/^bool ImGuiTextFilter::PassFilter(const char* text, const char* text_end) const$/;"	f	class:ImGuiTextFilter
PatchFormatStringFloatToInt	imgui_widgets.cpp	/^static const char* PatchFormatStringFloatToInt(const char* fmt)$/;"	f	file:
PathArcTo	imgui_draw.cpp	/^void ImDrawList::PathArcTo(const ImVec2& center, float radius, float a_min, float a_max, int num_segments)$/;"	f	class:ImDrawList
PathArcToFast	imgui_draw.cpp	/^void ImDrawList::PathArcToFast(const ImVec2& center, float radius, int a_min_of_12, int a_max_of_12)$/;"	f	class:ImDrawList
PathBezierCubicCurveTo	imgui_draw.cpp	/^void ImDrawList::PathBezierCubicCurveTo(const ImVec2& p2, const ImVec2& p3, const ImVec2& p4, int num_segments)$/;"	f	class:ImDrawList
PathBezierCubicCurveToCasteljau	imgui_draw.cpp	/^static void PathBezierCubicCurveToCasteljau(ImVector<ImVec2>* path, float x1, float y1, float x2, float y2, float x3, float y3, float x4, float y4, float tess_tol, int level)$/;"	f	file:
PathBezierCurveTo	imgui.h	/^    inline    void  PathBezierCurveTo(const ImVec2& p2, const ImVec2& p3, const ImVec2& p4, int num_segments = 0) { PathBezierCubicCurveTo(p2, p3, p4, num_segments); }$/;"	f	struct:ImDrawList
PathBezierQuadraticCurveTo	imgui_draw.cpp	/^void ImDrawList::PathBezierQuadraticCurveTo(const ImVec2& p2, const ImVec2& p3, int num_segments)$/;"	f	class:ImDrawList
PathBezierQuadraticCurveToCasteljau	imgui_draw.cpp	/^static void PathBezierQuadraticCurveToCasteljau(ImVector<ImVec2>* path, float x1, float y1, float x2, float y2, float x3, float y3, float tess_tol, int level)$/;"	f	file:
PathClear	imgui.h	/^    inline    void  PathClear()                                                 { _Path.Size = 0; }$/;"	f	struct:ImDrawList
PathFillConvex	imgui.h	/^    inline    void  PathFillConvex(ImU32 col)                                   { AddConvexPolyFilled(_Path.Data, _Path.Size, col); _Path.Size = 0; }  \/\/ Note: Anti-aliased filling requires points to be in clockwise order.$/;"	f	struct:ImDrawList
PathLineTo	imgui.h	/^    inline    void  PathLineTo(const ImVec2& pos)                               { _Path.push_back(pos); }$/;"	f	struct:ImDrawList
PathLineToMergeDuplicate	imgui.h	/^    inline    void  PathLineToMergeDuplicate(const ImVec2& pos)                 { if (_Path.Size == 0 || memcmp(&_Path.Data[_Path.Size - 1], &pos, 8) != 0) _Path.push_back(pos); }$/;"	f	struct:ImDrawList
PathRect	imgui_draw.cpp	/^void ImDrawList::PathRect(const ImVec2& a, const ImVec2& b, float rounding, ImDrawFlags flags)$/;"	f	class:ImDrawList
PathStroke	imgui.h	/^    inline    void  PathStroke(ImU32 col, ImDrawFlags flags = 0, float thickness = 1.0f) { AddPolyline(_Path.Data, _Path.Size, col, flags, thickness); _Path.Size = 0; }$/;"	f	struct:ImDrawList
PenPressure	imgui.h	/^    float       PenPressure;                    \/\/ Touch\/Pen pressure (0.0f to 1.0f, should be >0.0f only when MouseDown[0] == true). Helper storage currently unused by Dear ImGui.$/;"	m	struct:ImGuiIO
PixelSnapH	imgui.h	/^    bool            PixelSnapH;             \/\/ false    \/\/ Align every glyph to pixel boundary. Useful e.g. if you are merging a non-pixel aligned font with the default font. If enabled, you can set OversampleH\/V to 1.$/;"	m	struct:ImFontConfig
PlatformImeLastPos	imgui_internal.h	/^    ImVec2                  PlatformImeLastPos;$/;"	m	struct:ImGuiContext
PlatformImePos	imgui_internal.h	/^    ImVec2                  PlatformImePos;                     \/\/ Cursor position request & last passed to the OS Input Method Editor$/;"	m	struct:ImGuiContext
PlatformLocaleDecimalPoint	imgui_internal.h	/^    char                    PlatformLocaleDecimalPoint;         \/\/ '.' or *localeconv()->decimal_point$/;"	m	struct:ImGuiContext
PlotEx	imgui_widgets.cpp	/^int ImGui::PlotEx(ImGuiPlotType plot_type, const char* label, float (*values_getter)(void* data, int idx), void* data, int values_count, int values_offset, const char* overlay_text, float scale_min, float scale_max, ImVec2 frame_size)$/;"	f	class:ImGui
PlotHistogram	imgui_widgets.cpp	/^void ImGui::PlotHistogram(const char* label, const float* values, int values_count, int values_offset, const char* overlay_text, float scale_min, float scale_max, ImVec2 graph_size, int stride)$/;"	f	class:ImGui
PlotHistogram	imgui_widgets.cpp	/^void ImGui::PlotHistogram(const char* label, float (*values_getter)(void* data, int idx), void* data, int values_count, int values_offset, const char* overlay_text, float scale_min, float scale_max, ImVec2 graph_size)$/;"	f	class:ImGui
PlotLines	imgui_widgets.cpp	/^void ImGui::PlotLines(const char* label, const float* values, int values_count, int values_offset, const char* overlay_text, float scale_min, float scale_max, ImVec2 graph_size, int stride)$/;"	f	class:ImGui
PlotLines	imgui_widgets.cpp	/^void ImGui::PlotLines(const char* label, float (*values_getter)(void* data, int idx), void* data, int values_count, int values_offset, const char* overlay_text, float scale_min, float scale_max, ImVec2 graph_size)$/;"	f	class:ImGui
Plot_ArrayGetter	imgui_widgets.cpp	/^static float Plot_ArrayGetter(void* data, int idx)$/;"	f	file:
PopAllowKeyboardFocus	imgui.cpp	/^void ImGui::PopAllowKeyboardFocus()$/;"	f	class:ImGui
PopButtonRepeat	imgui.cpp	/^void ImGui::PopButtonRepeat()$/;"	f	class:ImGui
PopClipRect	imgui.cpp	/^void ImGui::PopClipRect()$/;"	f	class:ImGui
PopClipRect	imgui_draw.cpp	/^void ImDrawList::PopClipRect()$/;"	f	class:ImDrawList
PopColumnsBackground	imgui_tables.cpp	/^void ImGui::PopColumnsBackground()$/;"	f	class:ImGui
PopFocusScope	imgui.cpp	/^void ImGui::PopFocusScope()$/;"	f	class:ImGui
PopFont	imgui.cpp	/^void  ImGui::PopFont()$/;"	f	class:ImGui
PopID	imgui.cpp	/^void ImGui::PopID()$/;"	f	class:ImGui
PopItemFlag	imgui.cpp	/^void ImGui::PopItemFlag()$/;"	f	class:ImGui
PopItemWidth	imgui.cpp	/^void ImGui::PopItemWidth()$/;"	f	class:ImGui
PopStyleColor	imgui.cpp	/^void ImGui::PopStyleColor(int count)$/;"	f	class:ImGui
PopStyleCompact	imgui_demo.cpp	/^static void PopStyleCompact()$/;"	f	file:
PopStyleVar	imgui.cpp	/^void ImGui::PopStyleVar(int count)$/;"	f	class:ImGui
PopTextWrapPos	imgui.cpp	/^void ImGui::PopTextWrapPos()$/;"	f	class:ImGui
PopTextureID	imgui_draw.cpp	/^void ImDrawList::PopTextureID()$/;"	f	class:ImDrawList
PopupBorderSize	imgui.h	/^    float       PopupBorderSize;            \/\/ Thickness of border around popup\/tooltip windows. Generally set to 0.0f or 1.0f. (Other values are not well tested and more CPU\/GPU costly).$/;"	m	struct:ImGuiStyle
PopupId	imgui_internal.h	/^    ImGuiID                 PopupId;                            \/\/ ID in the popup stack when this window is used as a popup\/menu (because we use generic Name\/ID for recycling)$/;"	m	struct:ImGuiWindow
PopupId	imgui_internal.h	/^    ImGuiID             PopupId;        \/\/ Set on OpenPopup()$/;"	m	struct:ImGuiPopupData
PopupRounding	imgui.h	/^    float       PopupRounding;              \/\/ Radius of popup window corners rounding. (Note that tooltip windows use WindowRounding)$/;"	m	struct:ImGuiStyle
Pos	imgui.h	/^    ImVec2              Pos;                    \/\/ Main Area: Position of the viewport (Dear ImGui coordinates are the same as OS desktop\/native coordinates)$/;"	m	struct:ImGuiViewport
Pos	imgui.h	/^    ImVec2  Pos;            \/\/ Read-only.   Window position, for reference.$/;"	m	struct:ImGuiSizeCallbackData
Pos	imgui_internal.h	/^    ImVec2                  Pos;                                \/\/ Position (always rounded-up to nearest pixel)$/;"	m	struct:ImGuiWindow
Pos	imgui_internal.h	/^    ImVec2ih    Pos;$/;"	m	struct:ImGuiWindowSettings
Pos	imgui_internal.h	/^    float       Pos[3], NextWidths[3];$/;"	m	struct:ImGuiMenuColumns
PosCond	imgui_internal.h	/^    ImGuiCond                   PosCond;$/;"	m	struct:ImGuiNextWindowData
PosPivotVal	imgui_internal.h	/^    ImVec2                      PosPivotVal;$/;"	m	struct:ImGuiNextWindowData
PosVal	imgui_internal.h	/^    ImVec2                      PosVal;$/;"	m	struct:ImGuiNextWindowData
PrevEnabledColumn	imgui_internal.h	/^    ImGuiTableColumnIdx     PrevEnabledColumn;              \/\/ Index of prev enabled\/visible column within Columns[], -1 if first enabled\/visible column$/;"	m	struct:ImGuiTableColumn
PrevFrameVisible	imgui_internal.h	/^    int                 PrevFrameVisible;$/;"	m	struct:ImGuiTabBar
PrevLineSize	imgui_internal.h	/^    ImVec2                  PrevLineSize;$/;"	m	struct:ImGuiWindowTempData
PrevLineTextBaseOffset	imgui_internal.h	/^    float                   PrevLineTextBaseOffset;$/;"	m	struct:ImGuiWindowTempData
PrevTabsContentsHeight	imgui_internal.h	/^    float               PrevTabsContentsHeight; \/\/ Record the height of contents submitted below the tab bar$/;"	m	struct:ImGuiTabBar
Preview	imgui.h	/^    bool            Preview;            \/\/ Set when AcceptDragDropPayload() was called and mouse has been hovering the target item (nb: handle overlapping drag targets)$/;"	m	struct:ImGuiPayload
PrimQuadUV	imgui_draw.cpp	/^void ImDrawList::PrimQuadUV(const ImVec2& a, const ImVec2& b, const ImVec2& c, const ImVec2& d, const ImVec2& uv_a, const ImVec2& uv_b, const ImVec2& uv_c, const ImVec2& uv_d, ImU32 col)$/;"	f	class:ImDrawList
PrimRect	imgui_draw.cpp	/^void ImDrawList::PrimRect(const ImVec2& a, const ImVec2& c, ImU32 col)$/;"	f	class:ImDrawList
PrimRectUV	imgui_draw.cpp	/^void ImDrawList::PrimRectUV(const ImVec2& a, const ImVec2& c, const ImVec2& uv_a, const ImVec2& uv_c, ImU32 col)$/;"	f	class:ImDrawList
PrimReserve	imgui_draw.cpp	/^void ImDrawList::PrimReserve(int idx_count, int vtx_count)$/;"	f	class:ImDrawList
PrimUnreserve	imgui_draw.cpp	/^void ImDrawList::PrimUnreserve(int idx_count, int vtx_count)$/;"	f	class:ImDrawList
PrimVtx	imgui.h	/^    inline    void  PrimVtx(const ImVec2& pos, const ImVec2& uv, ImU32 col)         { PrimWriteIdx((ImDrawIdx)_VtxCurrentIdx); PrimWriteVtx(pos, uv, col); } \/\/ Write vertex with unique index$/;"	f	struct:ImDrawList
PrimWriteIdx	imgui.h	/^    inline    void  PrimWriteIdx(ImDrawIdx idx)                                     { *_IdxWritePtr = idx; _IdxWritePtr++; }$/;"	f	struct:ImDrawList
PrimWriteVtx	imgui.h	/^    inline    void  PrimWriteVtx(const ImVec2& pos, const ImVec2& uv, ImU32 col)    { _VtxWritePtr->pos = pos; _VtxWritePtr->uv = uv; _VtxWritePtr->col = col; _VtxWritePtr++; _VtxCurrentIdx++; }$/;"	f	struct:ImDrawList
PrintFmt	imgui_internal.h	/^    const char* PrintFmt;       \/\/ Default printf format for the type$/;"	m	struct:ImGuiDataTypeInfo
ProgressBar	imgui_widgets.cpp	/^void ImGui::ProgressBar(float fraction, const ImVec2& size_arg, const char* overlay)$/;"	f	class:ImGui
Ptr	imgui_internal.h	/^    void*       Ptr;            \/\/ Either field can be set, not both. e.g. Dock node tab bars are loose while BeginTabBar() ones are in a pool.$/;"	m	struct:ImGuiPtrOrIndex
PushAllowKeyboardFocus	imgui.cpp	/^void ImGui::PushAllowKeyboardFocus(bool allow_keyboard_focus)$/;"	f	class:ImGui
PushButtonRepeat	imgui.cpp	/^void ImGui::PushButtonRepeat(bool repeat)$/;"	f	class:ImGui
PushClipRect	imgui.cpp	/^void ImGui::PushClipRect(const ImVec2& clip_rect_min, const ImVec2& clip_rect_max, bool intersect_with_current_clip_rect)$/;"	f	class:ImGui
PushClipRect	imgui_draw.cpp	/^void ImDrawList::PushClipRect(ImVec2 cr_min, ImVec2 cr_max, bool intersect_with_current_clip_rect)$/;"	f	class:ImDrawList
PushClipRectFullScreen	imgui_draw.cpp	/^void ImDrawList::PushClipRectFullScreen()$/;"	f	class:ImDrawList
PushColumnClipRect	imgui_tables.cpp	/^void ImGui::PushColumnClipRect(int column_index)$/;"	f	class:ImGui
PushColumnsBackground	imgui_tables.cpp	/^void ImGui::PushColumnsBackground()$/;"	f	class:ImGui
PushFocusScope	imgui.cpp	/^void ImGui::PushFocusScope(ImGuiID id)$/;"	f	class:ImGui
PushFont	imgui.cpp	/^void ImGui::PushFont(ImFont* font)$/;"	f	class:ImGui
PushID	imgui.cpp	/^void ImGui::PushID(const char* str_id)$/;"	f	class:ImGui
PushID	imgui.cpp	/^void ImGui::PushID(const char* str_id_begin, const char* str_id_end)$/;"	f	class:ImGui
PushID	imgui.cpp	/^void ImGui::PushID(const void* ptr_id)$/;"	f	class:ImGui
PushID	imgui.cpp	/^void ImGui::PushID(int int_id)$/;"	f	class:ImGui
PushItemFlag	imgui.cpp	/^void ImGui::PushItemFlag(ImGuiItemFlags option, bool enabled)$/;"	f	class:ImGui
PushItemWidth	imgui.cpp	/^void ImGui::PushItemWidth(float item_width)$/;"	f	class:ImGui
PushMultiItemsWidths	imgui.cpp	/^void ImGui::PushMultiItemsWidths(int components, float w_full)$/;"	f	class:ImGui
PushOverrideID	imgui.cpp	/^void ImGui::PushOverrideID(ImGuiID id)$/;"	f	class:ImGui
PushStyleColor	imgui.cpp	/^void ImGui::PushStyleColor(ImGuiCol idx, ImU32 col)$/;"	f	class:ImGui
PushStyleColor	imgui.cpp	/^void ImGui::PushStyleColor(ImGuiCol idx, const ImVec4& col)$/;"	f	class:ImGui
PushStyleCompact	imgui_demo.cpp	/^static void PushStyleCompact()$/;"	f	file:
PushStyleVar	imgui.cpp	/^void ImGui::PushStyleVar(ImGuiStyleVar idx, const ImVec2& val)$/;"	f	class:ImGui
PushStyleVar	imgui.cpp	/^void ImGui::PushStyleVar(ImGuiStyleVar idx, float val)$/;"	f	class:ImGui
PushTextWrapPos	imgui.cpp	/^void ImGui::PushTextWrapPos(float wrap_pos_x)$/;"	f	class:ImGui
PushTextureID	imgui_draw.cpp	/^void ImDrawList::PushTextureID(ImTextureID texture_id)$/;"	f	class:ImDrawList
Quantity	imgui_demo.cpp	/^    int         Quantity;$/;"	m	struct:__anon29::MyItem	file:
RadioButton	imgui_widgets.cpp	/^bool ImGui::RadioButton(const char* label, bool active)$/;"	f	class:ImGui
RadioButton	imgui_widgets.cpp	/^bool ImGui::RadioButton(const char* label, int* v, int v_button)$/;"	f	class:ImGui
RasterizerMultiply	imgui.h	/^    float           RasterizerMultiply;     \/\/ 1.0f     \/\/ Brighten (>1.0f) or darken (<1.0f) font output. Brightening small fonts may be a good workaround to make them more readable.$/;"	m	struct:ImFontConfig
RawData	imgui_internal.h	/^    void*                       RawData;                    \/\/ Single allocation to hold Columns[], DisplayOrderToIndex[] and RowCellData[]$/;"	m	struct:ImGuiTable
ReadInitFn	imgui_internal.h	/^    void        (*ReadInitFn)(ImGuiContext* ctx, ImGuiSettingsHandler* handler);                                \/\/ Read: Called before reading (in registration order)$/;"	m	struct:ImGuiSettingsHandler
ReadLineFn	imgui_internal.h	/^    void        (*ReadLineFn)(ImGuiContext* ctx, ImGuiSettingsHandler* handler, void* entry, const char* line); \/\/ Read: Called for every line of text within an ini entry$/;"	m	struct:ImGuiSettingsHandler
ReadOpenFn	imgui_internal.h	/^    void*       (*ReadOpenFn)(ImGuiContext* ctx, ImGuiSettingsHandler* handler, const char* name);              \/\/ Read: Called when entering into a new ini entry e.g. "[Window][Name]"$/;"	m	struct:ImGuiSettingsHandler
Rect	imgui_internal.h	/^    ImRect      Rect() const            { return ImRect(Pos.x, Pos.y, Pos.x + Size.x, Pos.y + Size.y); }$/;"	f	struct:ImGuiWindow
RectRel	imgui_internal.h	/^    ImRect              RectRel;        \/\/ Init,Move    \/\/ Best candidate bounding box in window relative space$/;"	m	struct:ImGuiNavItemData
Rects	imgui_draw.cpp	/^    stbrp_rect*         Rects;              \/\/ Rectangle to pack. We first fill in their size and the packer will give us their position.$/;"	m	struct:ImFontBuildSrcData	file:
RefFrame	imgui.h	/^    mutable int RefFrame;$/;"	m	struct:ImGuiOnceUponAFrame
RefScale	imgui_internal.h	/^    float                       RefScale;                   \/\/ Reference scale to be able to rescale columns on font\/dpi changes.$/;"	m	struct:ImGuiTable
RefScale	imgui_internal.h	/^    float                       RefScale;               \/\/ Reference scale to be able to rescale columns on font\/dpi changes.$/;"	m	struct:ImGuiTableSettings
Remove	imgui_internal.h	/^    void        Remove(ImGuiID key, ImPoolIdx idx)  { Buf[idx].~T(); *(int*)&Buf[idx] = FreeIdx; FreeIdx = idx; Map.SetInt(key, -1); }$/;"	f	struct:ImPool
Remove	imgui_internal.h	/^    void        Remove(ImGuiID key, const T* p)     { Remove(key, GetIndex(p)); }$/;"	f	struct:ImPool
RemoveContextHook	imgui.cpp	/^void ImGui::RemoveContextHook(ImGuiContext* ctx, ImGuiID hook_id)$/;"	f	class:ImGui
Render	imgui.cpp	/^void ImGui::Render()$/;"	f	class:ImGui
RenderArrow	imgui_draw.cpp	/^void ImGui::RenderArrow(ImDrawList* draw_list, ImVec2 pos, ImU32 col, ImGuiDir dir, float scale)$/;"	f	class:ImGui
RenderArrow	imgui_internal.h	/^    inline void RenderArrow(ImVec2 pos, ImGuiDir dir, float scale=1.0f) { ImGuiWindow* window = GetCurrentWindow(); RenderArrow(window->DrawList, pos, GetColorU32(ImGuiCol_Text), dir, scale); }$/;"	f	namespace:ImGui
RenderArrowPointingAt	imgui_draw.cpp	/^void ImGui::RenderArrowPointingAt(ImDrawList* draw_list, ImVec2 pos, ImVec2 half_sz, ImGuiDir direction, ImU32 col)$/;"	f	class:ImGui
RenderArrowsForVerticalBar	imgui_widgets.cpp	/^static void RenderArrowsForVerticalBar(ImDrawList* draw_list, ImVec2 pos, ImVec2 half_sz, float bar_w, float alpha)$/;"	f	file:
RenderBullet	imgui_draw.cpp	/^void ImGui::RenderBullet(ImDrawList* draw_list, ImVec2 pos, ImU32 col)$/;"	f	class:ImGui
RenderBullet	imgui_internal.h	/^    inline void RenderBullet(ImVec2 pos)                                { ImGuiWindow* window = GetCurrentWindow(); RenderBullet(window->DrawList, pos, GetColorU32(ImGuiCol_Text)); }$/;"	f	namespace:ImGui
RenderChar	imgui_draw.cpp	/^void ImFont::RenderChar(ImDrawList* draw_list, float size, ImVec2 pos, ImU32 col, ImWchar c) const$/;"	f	class:ImFont
RenderCheckMark	imgui_draw.cpp	/^void ImGui::RenderCheckMark(ImDrawList* draw_list, ImVec2 pos, ImU32 col, float sz)$/;"	f	class:ImGui
RenderColorRectWithAlphaCheckerboard	imgui_draw.cpp	/^void ImGui::RenderColorRectWithAlphaCheckerboard(ImDrawList* draw_list, ImVec2 p_min, ImVec2 p_max, ImU32 col, float grid_step, ImVec2 grid_off, float rounding, ImDrawFlags flags)$/;"	f	class:ImGui
RenderFrame	imgui.cpp	/^void ImGui::RenderFrame(ImVec2 p_min, ImVec2 p_max, ImU32 fill_col, bool border, float rounding)$/;"	f	class:ImGui
RenderFrameBorder	imgui.cpp	/^void ImGui::RenderFrameBorder(ImVec2 p_min, ImVec2 p_max, float rounding)$/;"	f	class:ImGui
RenderMouseCursor	imgui_draw.cpp	/^void ImGui::RenderMouseCursor(ImDrawList* draw_list, ImVec2 pos, float scale, ImGuiMouseCursor mouse_cursor, ImU32 col_fill, ImU32 col_border, ImU32 col_shadow)$/;"	f	class:ImGui
RenderNavHighlight	imgui.cpp	/^void ImGui::RenderNavHighlight(const ImRect& bb, ImGuiID id, ImGuiNavHighlightFlags flags)$/;"	f	class:ImGui
RenderRectFilledRangeH	imgui_draw.cpp	/^void ImGui::RenderRectFilledRangeH(ImDrawList* draw_list, const ImRect& rect, ImU32 col, float x_start_norm, float x_end_norm, float rounding)$/;"	f	class:ImGui
RenderRectFilledWithHole	imgui_draw.cpp	/^void ImGui::RenderRectFilledWithHole(ImDrawList* draw_list, ImRect outer, ImRect inner, ImU32 col, float rounding)$/;"	f	class:ImGui
RenderText	imgui.cpp	/^void ImGui::RenderText(ImVec2 pos, const char* text, const char* text_end, bool hide_text_after_hash)$/;"	f	class:ImGui
RenderText	imgui_draw.cpp	/^void ImFont::RenderText(ImDrawList* draw_list, float size, ImVec2 pos, ImU32 col, const ImVec4& clip_rect, const char* text_begin, const char* text_end, float wrap_width, bool cpu_fine_clip) const$/;"	f	class:ImFont
RenderTextClipped	imgui.cpp	/^void ImGui::RenderTextClipped(const ImVec2& pos_min, const ImVec2& pos_max, const char* text, const char* text_end, const ImVec2* text_size_if_known, const ImVec2& align, const ImRect* clip_rect)$/;"	f	class:ImGui
RenderTextClippedEx	imgui.cpp	/^void ImGui::RenderTextClippedEx(ImDrawList* draw_list, const ImVec2& pos_min, const ImVec2& pos_max, const char* text, const char* text_display_end, const ImVec2* text_size_if_known, const ImVec2& align, const ImRect* clip_rect)$/;"	f	class:ImGui
RenderTextEllipsis	imgui.cpp	/^void ImGui::RenderTextEllipsis(ImDrawList* draw_list, const ImVec2& pos_min, const ImVec2& pos_max, float clip_max_x, float ellipsis_max_x, const char* text, const char* text_end_full, const ImVec2* text_size_if_known)$/;"	f	class:ImGui
RenderTextWrapped	imgui.cpp	/^void ImGui::RenderTextWrapped(ImVec2 pos, const char* text, const char* text_end, float wrap_width)$/;"	f	class:ImGui
RenderViewportsThumbnails	imgui.cpp	/^static void RenderViewportsThumbnails()$/;"	f	file:
RenderWindowDecorations	imgui.cpp	/^void ImGui::RenderWindowDecorations(ImGuiWindow* window, const ImRect& title_bar_rect, bool title_bar_is_highlight, int resize_grip_count, const ImU32 resize_grip_col[4], float resize_grip_draw_size)$/;"	f	class:ImGui
RenderWindowOuterBorders	imgui.cpp	/^static void ImGui::RenderWindowOuterBorders(ImGuiWindow* window)$/;"	f	class:ImGui
RenderWindowTitleBarContents	imgui.cpp	/^void ImGui::RenderWindowTitleBarContents(ImGuiWindow* window, const ImRect& title_bar_rect, const char* name, bool* p_open)$/;"	f	class:ImGui
ReorderColumn	imgui_internal.h	/^    ImGuiTableColumnIdx         ReorderColumn;              \/\/ Index of column being reordered. (not cleared)$/;"	m	struct:ImGuiTable
ReorderColumnDir	imgui_internal.h	/^    ImGuiTableColumnIdx         ReorderColumnDir;           \/\/ -1 or +1$/;"	m	struct:ImGuiTable
ReorderRequestOffset	imgui_internal.h	/^    ImS16               ReorderRequestOffset;$/;"	m	struct:ImGuiTabBar
ReorderRequestTabId	imgui_internal.h	/^    ImGuiID             ReorderRequestTabId;$/;"	m	struct:ImGuiTabBar
RequestOutputMaskByIndex	imgui_internal.h	/^    ImU64                       RequestOutputMaskByIndex;   \/\/ Column Index -> IsVisible || AutoFit (== expect user to submit items)$/;"	m	struct:ImGuiTable
Reserve	imgui_internal.h	/^    inline void  Reserve(int n, size_t sz, int a=4) { IM_ASSERT(n == CurrIdx && n < CHUNKS); CurrOff = IM_MEMALIGN(CurrOff, a); Offsets[n] = CurrOff; Sizes[n] = (int)sz; CurrIdx++; CurrOff += (int)sz; }$/;"	f	struct:ImSpanAllocator
Reserve	imgui_internal.h	/^    void        Reserve(int capacity)               { Buf.reserve(capacity); Map.Data.reserve(capacity); }$/;"	f	struct:ImPool
ResetMouseDragDelta	imgui.cpp	/^void ImGui::ResetMouseDragDelta(ImGuiMouseButton button)$/;"	f	class:ImGui
ResizeBorderHeld	imgui_internal.h	/^    signed char             ResizeBorderHeld;                   \/\/ Current border being held for resize (-1: none, otherwise 0-3)$/;"	m	struct:ImGuiWindow
ResizeLockMinContentsX2	imgui_internal.h	/^    float                       ResizeLockMinContentsX2;    \/\/ Lock minimum contents width while resizing down in order to not create feedback loops. But we allow growing the table.$/;"	m	struct:ImGuiTable
ResizedColumn	imgui_internal.h	/^    ImGuiTableColumnIdx         ResizedColumn;              \/\/ Index of column being resized. Reset when InstanceCurrent==0.$/;"	m	struct:ImGuiTable
ResizedColumnNextWidth	imgui_internal.h	/^    float                       ResizedColumnNextWidth;$/;"	m	struct:ImGuiTable
Restore	imgui_internal.h	/^    void Restore() const    { ImGuiWindow* window = GImGui->CurrentWindow; window->DC.LastItemId = LastItemId; window->DC.LastItemStatusFlags = LastItemStatusFlags; window->DC.LastItemRect = LastItemRect; window->DC.LastItemDisplayRect = LastItemDisplayRect; }$/;"	f	struct:ImGuiLastItemDataBackup
RightMostEnabledColumn	imgui_internal.h	/^    ImGuiTableColumnIdx         RightMostEnabledColumn;     \/\/ Index of right-most non-hidden column.$/;"	m	struct:ImGuiTable
RightMostStretchedColumn	imgui_internal.h	/^    ImGuiTableColumnIdx         RightMostStretchedColumn;   \/\/ Index of right-most stretched column.$/;"	m	struct:ImGuiTable
RootWindow	imgui_internal.h	/^    ImGuiWindow*            RootWindow;                         \/\/ Point to ourself or first ancestor that is not a child window == Top-level window.$/;"	m	struct:ImGuiWindow
RootWindowForNav	imgui_internal.h	/^    ImGuiWindow*            RootWindowForNav;                   \/\/ Point to ourself or first ancestor which doesn't have the NavFlattened flag.$/;"	m	struct:ImGuiWindow
RootWindowForTitleBarHighlight	imgui_internal.h	/^    ImGuiWindow*            RootWindowForTitleBarHighlight;     \/\/ Point to ourself or first ancestor which will display TitleBgActive color when this window is active.$/;"	m	struct:ImGuiWindow
RoundScalarWithFormatT	imgui_widgets.cpp	/^TYPE ImGui::RoundScalarWithFormatT(const char* format, ImGuiDataType data_type, TYPE v)$/;"	f	class:ImGui
RowBgColor	imgui_internal.h	/^    ImU32                       RowBgColor[2];              \/\/ Background color override for current row.$/;"	m	struct:ImGuiTable
RowBgColorCounter	imgui_internal.h	/^    int                         RowBgColorCounter;          \/\/ Counter for alternating background colors (can be fast-forwarded by e.g clipper), not same as CurrentRow because header rows typically don't increase this.$/;"	m	struct:ImGuiTable
RowCellData	imgui_internal.h	/^    ImSpan<ImGuiTableCellData>  RowCellData;                \/\/ Point within RawData[]. Store cells background requests for current row.$/;"	m	struct:ImGuiTable
RowCellDataCurrent	imgui_internal.h	/^    ImGuiTableColumnIdx         RowCellDataCurrent;         \/\/ Index of current RowCellData[] entry in current row$/;"	m	struct:ImGuiTable
RowFlags	imgui_internal.h	/^    ImGuiTableRowFlags          RowFlags : 16;              \/\/ Current row flags, see ImGuiTableRowFlags_$/;"	m	struct:ImGuiTable
RowIndentOffsetX	imgui_internal.h	/^    float                       RowIndentOffsetX;$/;"	m	struct:ImGuiTable
RowMinHeight	imgui_internal.h	/^    float                       RowMinHeight;               \/\/ Height submitted to TableNextRow()$/;"	m	struct:ImGuiTable
RowPosY1	imgui_internal.h	/^    float                       RowPosY1;$/;"	m	struct:ImGuiTable
RowPosY2	imgui_internal.h	/^    float                       RowPosY2;$/;"	m	struct:ImGuiTable
RowTextBaseline	imgui_internal.h	/^    float                       RowTextBaseline;$/;"	m	struct:ImGuiTable
STBRP_ASSERT	imgui_draw.cpp	/^#define STBRP_ASSERT(/;"	d	file:
STBRP_ASSERT	imstb_rectpack.h	/^#define STBRP_ASSERT /;"	d
STBRP_DEF	imstb_rectpack.h	/^#define STBRP_DEF /;"	d
STBRP_HEURISTIC_Skyline_BF_sortHeight	imstb_rectpack.h	/^   STBRP_HEURISTIC_Skyline_BF_sortHeight$/;"	e	enum:__anon26
STBRP_HEURISTIC_Skyline_BL_sortHeight	imstb_rectpack.h	/^   STBRP_HEURISTIC_Skyline_BL_sortHeight = STBRP_HEURISTIC_Skyline_default,$/;"	e	enum:__anon26
STBRP_HEURISTIC_Skyline_default	imstb_rectpack.h	/^   STBRP_HEURISTIC_Skyline_default=0,$/;"	e	enum:__anon26
STBRP_SORT	imgui_draw.cpp	/^#define STBRP_SORT /;"	d	file:
STBRP_SORT	imstb_rectpack.h	/^#define STBRP_SORT /;"	d
STBRP_STATIC	imgui_draw.cpp	/^#define STBRP_STATIC$/;"	d	file:
STBRP__CDECL	imstb_rectpack.h	/^#define STBRP__CDECL /;"	d
STBRP__CDECL	imstb_rectpack.h	/^#define STBRP__CDECL$/;"	d
STBRP__INIT_skyline	imstb_rectpack.h	/^   STBRP__INIT_skyline = 1$/;"	e	enum:__anon27
STBRP__MAXVAL	imstb_rectpack.h	/^#define STBRP__MAXVAL /;"	d
STBRP__NOTUSED	imstb_rectpack.h	/^#define STBRP__NOTUSED(/;"	d
STBTT_DEF	imstb_truetype.h	/^#define STBTT_DEF /;"	d
STBTT_FIX	imstb_truetype.h	/^#define STBTT_FIX /;"	d
STBTT_FIXMASK	imstb_truetype.h	/^#define STBTT_FIXMASK /;"	d
STBTT_FIXSHIFT	imstb_truetype.h	/^#define STBTT_FIXSHIFT /;"	d
STBTT_GPOS_TODO_assert	imstb_truetype.h	/^#define STBTT_GPOS_TODO_assert(/;"	d
STBTT_MACSTYLE_BOLD	imstb_truetype.h	/^#define STBTT_MACSTYLE_BOLD /;"	d
STBTT_MACSTYLE_DONTCARE	imstb_truetype.h	/^#define STBTT_MACSTYLE_DONTCARE /;"	d
STBTT_MACSTYLE_ITALIC	imstb_truetype.h	/^#define STBTT_MACSTYLE_ITALIC /;"	d
STBTT_MACSTYLE_NONE	imstb_truetype.h	/^#define STBTT_MACSTYLE_NONE /;"	d
STBTT_MACSTYLE_UNDERSCORE	imstb_truetype.h	/^#define STBTT_MACSTYLE_UNDERSCORE /;"	d
STBTT_MAC_EID_ARABIC	imstb_truetype.h	/^   STBTT_MAC_EID_ROMAN        =0,   STBTT_MAC_EID_ARABIC       =4,$/;"	e	enum:__anon18
STBTT_MAC_EID_CHINESE_TRAD	imstb_truetype.h	/^   STBTT_MAC_EID_CHINESE_TRAD =2,   STBTT_MAC_EID_GREEK        =6,$/;"	e	enum:__anon18
STBTT_MAC_EID_GREEK	imstb_truetype.h	/^   STBTT_MAC_EID_CHINESE_TRAD =2,   STBTT_MAC_EID_GREEK        =6,$/;"	e	enum:__anon18
STBTT_MAC_EID_HEBREW	imstb_truetype.h	/^   STBTT_MAC_EID_JAPANESE     =1,   STBTT_MAC_EID_HEBREW       =5,$/;"	e	enum:__anon18
STBTT_MAC_EID_JAPANESE	imstb_truetype.h	/^   STBTT_MAC_EID_JAPANESE     =1,   STBTT_MAC_EID_HEBREW       =5,$/;"	e	enum:__anon18
STBTT_MAC_EID_KOREAN	imstb_truetype.h	/^   STBTT_MAC_EID_KOREAN       =3,   STBTT_MAC_EID_RUSSIAN      =7$/;"	e	enum:__anon18
STBTT_MAC_EID_ROMAN	imstb_truetype.h	/^   STBTT_MAC_EID_ROMAN        =0,   STBTT_MAC_EID_ARABIC       =4,$/;"	e	enum:__anon18
STBTT_MAC_EID_RUSSIAN	imstb_truetype.h	/^   STBTT_MAC_EID_KOREAN       =3,   STBTT_MAC_EID_RUSSIAN      =7$/;"	e	enum:__anon18
STBTT_MAC_LANG_ARABIC	imstb_truetype.h	/^   STBTT_MAC_LANG_ARABIC       =12,   STBTT_MAC_LANG_KOREAN       =23,$/;"	e	enum:__anon20
STBTT_MAC_LANG_CHINESE_SIMPLIFIED	imstb_truetype.h	/^   STBTT_MAC_LANG_HEBREW       =10,   STBTT_MAC_LANG_CHINESE_SIMPLIFIED =33,$/;"	e	enum:__anon20
STBTT_MAC_LANG_CHINESE_TRAD	imstb_truetype.h	/^   STBTT_MAC_LANG_ITALIAN      =3 ,   STBTT_MAC_LANG_CHINESE_TRAD =19$/;"	e	enum:__anon20
STBTT_MAC_LANG_DUTCH	imstb_truetype.h	/^   STBTT_MAC_LANG_DUTCH        =4 ,   STBTT_MAC_LANG_RUSSIAN      =32,$/;"	e	enum:__anon20
STBTT_MAC_LANG_ENGLISH	imstb_truetype.h	/^   STBTT_MAC_LANG_ENGLISH      =0 ,   STBTT_MAC_LANG_JAPANESE     =11,$/;"	e	enum:__anon20
STBTT_MAC_LANG_FRENCH	imstb_truetype.h	/^   STBTT_MAC_LANG_FRENCH       =1 ,   STBTT_MAC_LANG_SPANISH      =6 ,$/;"	e	enum:__anon20
STBTT_MAC_LANG_GERMAN	imstb_truetype.h	/^   STBTT_MAC_LANG_GERMAN       =2 ,   STBTT_MAC_LANG_SWEDISH      =5 ,$/;"	e	enum:__anon20
STBTT_MAC_LANG_HEBREW	imstb_truetype.h	/^   STBTT_MAC_LANG_HEBREW       =10,   STBTT_MAC_LANG_CHINESE_SIMPLIFIED =33,$/;"	e	enum:__anon20
STBTT_MAC_LANG_ITALIAN	imstb_truetype.h	/^   STBTT_MAC_LANG_ITALIAN      =3 ,   STBTT_MAC_LANG_CHINESE_TRAD =19$/;"	e	enum:__anon20
STBTT_MAC_LANG_JAPANESE	imstb_truetype.h	/^   STBTT_MAC_LANG_ENGLISH      =0 ,   STBTT_MAC_LANG_JAPANESE     =11,$/;"	e	enum:__anon20
STBTT_MAC_LANG_KOREAN	imstb_truetype.h	/^   STBTT_MAC_LANG_ARABIC       =12,   STBTT_MAC_LANG_KOREAN       =23,$/;"	e	enum:__anon20
STBTT_MAC_LANG_RUSSIAN	imstb_truetype.h	/^   STBTT_MAC_LANG_DUTCH        =4 ,   STBTT_MAC_LANG_RUSSIAN      =32,$/;"	e	enum:__anon20
STBTT_MAC_LANG_SPANISH	imstb_truetype.h	/^   STBTT_MAC_LANG_FRENCH       =1 ,   STBTT_MAC_LANG_SPANISH      =6 ,$/;"	e	enum:__anon20
STBTT_MAC_LANG_SWEDISH	imstb_truetype.h	/^   STBTT_MAC_LANG_GERMAN       =2 ,   STBTT_MAC_LANG_SWEDISH      =5 ,$/;"	e	enum:__anon20
STBTT_MAX_OVERSAMPLE	imstb_truetype.h	/^#define STBTT_MAX_OVERSAMPLE /;"	d
STBTT_MS_EID_SHIFTJIS	imstb_truetype.h	/^   STBTT_MS_EID_SHIFTJIS      =2,$/;"	e	enum:__anon17
STBTT_MS_EID_SYMBOL	imstb_truetype.h	/^   STBTT_MS_EID_SYMBOL        =0,$/;"	e	enum:__anon17
STBTT_MS_EID_UNICODE_BMP	imstb_truetype.h	/^   STBTT_MS_EID_UNICODE_BMP   =1,$/;"	e	enum:__anon17
STBTT_MS_EID_UNICODE_FULL	imstb_truetype.h	/^   STBTT_MS_EID_UNICODE_FULL  =10$/;"	e	enum:__anon17
STBTT_MS_LANG_CHINESE	imstb_truetype.h	/^   STBTT_MS_LANG_CHINESE     =0x0804,   STBTT_MS_LANG_JAPANESE    =0x0411,$/;"	e	enum:__anon19
STBTT_MS_LANG_DUTCH	imstb_truetype.h	/^   STBTT_MS_LANG_DUTCH       =0x0413,   STBTT_MS_LANG_KOREAN      =0x0412,$/;"	e	enum:__anon19
STBTT_MS_LANG_ENGLISH	imstb_truetype.h	/^   STBTT_MS_LANG_ENGLISH     =0x0409,   STBTT_MS_LANG_ITALIAN     =0x0410,$/;"	e	enum:__anon19
STBTT_MS_LANG_FRENCH	imstb_truetype.h	/^   STBTT_MS_LANG_FRENCH      =0x040c,   STBTT_MS_LANG_RUSSIAN     =0x0419,$/;"	e	enum:__anon19
STBTT_MS_LANG_GERMAN	imstb_truetype.h	/^   STBTT_MS_LANG_GERMAN      =0x0407,   STBTT_MS_LANG_SPANISH     =0x0409,$/;"	e	enum:__anon19
STBTT_MS_LANG_HEBREW	imstb_truetype.h	/^   STBTT_MS_LANG_HEBREW      =0x040d,   STBTT_MS_LANG_SWEDISH     =0x041D$/;"	e	enum:__anon19
STBTT_MS_LANG_ITALIAN	imstb_truetype.h	/^   STBTT_MS_LANG_ENGLISH     =0x0409,   STBTT_MS_LANG_ITALIAN     =0x0410,$/;"	e	enum:__anon19
STBTT_MS_LANG_JAPANESE	imstb_truetype.h	/^   STBTT_MS_LANG_CHINESE     =0x0804,   STBTT_MS_LANG_JAPANESE    =0x0411,$/;"	e	enum:__anon19
STBTT_MS_LANG_KOREAN	imstb_truetype.h	/^   STBTT_MS_LANG_DUTCH       =0x0413,   STBTT_MS_LANG_KOREAN      =0x0412,$/;"	e	enum:__anon19
STBTT_MS_LANG_RUSSIAN	imstb_truetype.h	/^   STBTT_MS_LANG_FRENCH      =0x040c,   STBTT_MS_LANG_RUSSIAN     =0x0419,$/;"	e	enum:__anon19
STBTT_MS_LANG_SPANISH	imstb_truetype.h	/^   STBTT_MS_LANG_GERMAN      =0x0407,   STBTT_MS_LANG_SPANISH     =0x0409,$/;"	e	enum:__anon19
STBTT_MS_LANG_SWEDISH	imstb_truetype.h	/^   STBTT_MS_LANG_HEBREW      =0x040d,   STBTT_MS_LANG_SWEDISH     =0x041D$/;"	e	enum:__anon19
STBTT_PLATFORM_ID_ISO	imstb_truetype.h	/^   STBTT_PLATFORM_ID_ISO       =2,$/;"	e	enum:__anon15
STBTT_PLATFORM_ID_MAC	imstb_truetype.h	/^   STBTT_PLATFORM_ID_MAC       =1,$/;"	e	enum:__anon15
STBTT_PLATFORM_ID_MICROSOFT	imstb_truetype.h	/^   STBTT_PLATFORM_ID_MICROSOFT =3$/;"	e	enum:__anon15
STBTT_PLATFORM_ID_UNICODE	imstb_truetype.h	/^   STBTT_PLATFORM_ID_UNICODE   =0,$/;"	e	enum:__anon15
STBTT_POINT_SIZE	imstb_truetype.h	/^#define STBTT_POINT_SIZE(/;"	d
STBTT_RASTERIZER_VERSION	imstb_truetype.h	/^#define STBTT_RASTERIZER_VERSION /;"	d
STBTT_STATIC	imgui_draw.cpp	/^#define STBTT_STATIC$/;"	d	file:
STBTT_UNICODE_EID_ISO_10646	imstb_truetype.h	/^   STBTT_UNICODE_EID_ISO_10646      =2,$/;"	e	enum:__anon16
STBTT_UNICODE_EID_UNICODE_1_0	imstb_truetype.h	/^   STBTT_UNICODE_EID_UNICODE_1_0    =0,$/;"	e	enum:__anon16
STBTT_UNICODE_EID_UNICODE_1_1	imstb_truetype.h	/^   STBTT_UNICODE_EID_UNICODE_1_1    =1,$/;"	e	enum:__anon16
STBTT_UNICODE_EID_UNICODE_2_0_BMP	imstb_truetype.h	/^   STBTT_UNICODE_EID_UNICODE_2_0_BMP=3,$/;"	e	enum:__anon16
STBTT_UNICODE_EID_UNICODE_2_0_FULL	imstb_truetype.h	/^   STBTT_UNICODE_EID_UNICODE_2_0_FULL=4$/;"	e	enum:__anon16
STBTT__COMPARE	imstb_truetype.h	/^#define STBTT__COMPARE(/;"	d
STBTT__CSCTX_INIT	imstb_truetype.h	/^#define STBTT__CSCTX_INIT(/;"	d
STBTT__CSERR	imstb_truetype.h	/^#define STBTT__CSERR(/;"	d
STBTT__CSERR	imstb_truetype.h	/^#undef STBTT__CSERR$/;"	d
STBTT__NOTUSED	imstb_truetype.h	/^#define STBTT__NOTUSED(/;"	d
STBTT__OVER_MASK	imstb_truetype.h	/^#define STBTT__OVER_MASK /;"	d
STBTT_acos	imstb_truetype.h	/^   #define STBTT_acos(/;"	d
STBTT_assert	imgui_draw.cpp	/^#define STBTT_assert(/;"	d	file:
STBTT_assert	imstb_truetype.h	/^   #define STBTT_assert(/;"	d
STBTT_cos	imstb_truetype.h	/^   #define STBTT_cos(/;"	d
STBTT_fabs	imgui_draw.cpp	/^#define STBTT_fabs(/;"	d	file:
STBTT_fabs	imstb_truetype.h	/^   #define STBTT_fabs(/;"	d
STBTT_fmod	imgui_draw.cpp	/^#define STBTT_fmod(/;"	d	file:
STBTT_fmod	imstb_truetype.h	/^   #define STBTT_fmod(/;"	d
STBTT_free	imgui_draw.cpp	/^#define STBTT_free(/;"	d	file:
STBTT_free	imstb_truetype.h	/^   #define STBTT_free(/;"	d
STBTT_iceil	imgui_draw.cpp	/^#define STBTT_iceil(/;"	d	file:
STBTT_iceil	imstb_truetype.h	/^   #define STBTT_iceil(/;"	d
STBTT_ifloor	imgui_draw.cpp	/^#define STBTT_ifloor(/;"	d	file:
STBTT_ifloor	imstb_truetype.h	/^   #define STBTT_ifloor(/;"	d
STBTT_malloc	imgui_draw.cpp	/^#define STBTT_malloc(/;"	d	file:
STBTT_malloc	imstb_truetype.h	/^   #define STBTT_malloc(/;"	d
STBTT_max	imstb_truetype.h	/^#define STBTT_max(/;"	d
STBTT_memcpy	imstb_truetype.h	/^   #define STBTT_memcpy /;"	d
STBTT_memset	imstb_truetype.h	/^   #define STBTT_memset /;"	d
STBTT_min	imstb_truetype.h	/^#define STBTT_min(/;"	d
STBTT_pow	imgui_draw.cpp	/^#define STBTT_pow(/;"	d	file:
STBTT_pow	imstb_truetype.h	/^   #define STBTT_pow(/;"	d
STBTT_sqrt	imgui_draw.cpp	/^#define STBTT_sqrt(/;"	d	file:
STBTT_sqrt	imstb_truetype.h	/^   #define STBTT_sqrt(/;"	d
STBTT_strlen	imstb_truetype.h	/^   #define STBTT_strlen(/;"	d
STBTT_vcubic	imstb_truetype.h	/^      STBTT_vcubic$/;"	e	enum:__anon12
STBTT_vcurve	imstb_truetype.h	/^      STBTT_vcurve,$/;"	e	enum:__anon12
STBTT_vline	imstb_truetype.h	/^      STBTT_vline,$/;"	e	enum:__anon12
STBTT_vmove	imstb_truetype.h	/^      STBTT_vmove=1,$/;"	e	enum:__anon12
STB_INCLUDE_STB_RECT_PACK_H	imstb_rectpack.h	/^#define STB_INCLUDE_STB_RECT_PACK_H$/;"	d
STB_RECT_PACK_IMPLEMENTATION	imgui_draw.cpp	/^#define STB_RECT_PACK_IMPLEMENTATION$/;"	d	file:
STB_RECT_PACK_VERSION	imstb_rectpack.h	/^#define STB_RECT_PACK_VERSION /;"	d
STB_SPRINTF_IMPLEMENTATION	imgui.cpp	/^#define STB_SPRINTF_IMPLEMENTATION$/;"	d	file:
STB_TEXTEDIT_CHARTYPE	imgui_internal.h	/^#define STB_TEXTEDIT_CHARTYPE /;"	d
STB_TEXTEDIT_CHARTYPE	imgui_internal.h	/^#undef STB_TEXTEDIT_CHARTYPE$/;"	d
STB_TEXTEDIT_CHARTYPE	imstb_textedit.h	/^#define STB_TEXTEDIT_CHARTYPE /;"	d
STB_TEXTEDIT_DELETECHARS	imgui_widgets.cpp	/^static void STB_TEXTEDIT_DELETECHARS(STB_TEXTEDIT_STRING* obj, int pos, int n)$/;"	f	namespace:ImStb
STB_TEXTEDIT_GETCHAR	imgui_widgets.cpp	/^static ImWchar STB_TEXTEDIT_GETCHAR(const STB_TEXTEDIT_STRING* obj, int idx)                      { return obj->TextW[idx]; }$/;"	f	namespace:ImStb
STB_TEXTEDIT_GETWIDTH	imgui_widgets.cpp	/^static float   STB_TEXTEDIT_GETWIDTH(STB_TEXTEDIT_STRING* obj, int line_start_idx, int char_idx)  { ImWchar c = obj->TextW[line_start_idx + char_idx]; if (c == '\\n') return STB_TEXTEDIT_GETWIDTH_NEWLINE; ImGuiContext& g = *GImGui; return g.Font->GetCharAdvance(c) * (g.FontSize \/ g.Font->FontSize); }$/;"	f	namespace:ImStb
STB_TEXTEDIT_GETWIDTH_NEWLINE	imgui_internal.h	/^#define STB_TEXTEDIT_GETWIDTH_NEWLINE /;"	d
STB_TEXTEDIT_IMPLEMENTATION	imgui_widgets.cpp	/^#define STB_TEXTEDIT_IMPLEMENTATION$/;"	d	file:
STB_TEXTEDIT_INSERTCHARS	imgui_widgets.cpp	/^static bool STB_TEXTEDIT_INSERTCHARS(STB_TEXTEDIT_STRING* obj, int pos, const ImWchar* new_text, int new_text_len)$/;"	f	namespace:ImStb
STB_TEXTEDIT_KEYTOTEXT	imgui_widgets.cpp	/^static int     STB_TEXTEDIT_KEYTOTEXT(int key)                                                    { return key >= 0x200000 ? 0 : key; }$/;"	f	namespace:ImStb
STB_TEXTEDIT_KEYTYPE	imstb_textedit.h	/^#define STB_TEXTEDIT_KEYTYPE /;"	d
STB_TEXTEDIT_K_BACKSPACE	imgui_widgets.cpp	/^#define STB_TEXTEDIT_K_BACKSPACE /;"	d	file:
STB_TEXTEDIT_K_DELETE	imgui_widgets.cpp	/^#define STB_TEXTEDIT_K_DELETE /;"	d	file:
STB_TEXTEDIT_K_DOWN	imgui_widgets.cpp	/^#define STB_TEXTEDIT_K_DOWN /;"	d	file:
STB_TEXTEDIT_K_LEFT	imgui_widgets.cpp	/^#define STB_TEXTEDIT_K_LEFT /;"	d	file:
STB_TEXTEDIT_K_LINEEND	imgui_widgets.cpp	/^#define STB_TEXTEDIT_K_LINEEND /;"	d	file:
STB_TEXTEDIT_K_LINESTART	imgui_widgets.cpp	/^#define STB_TEXTEDIT_K_LINESTART /;"	d	file:
STB_TEXTEDIT_K_PGDOWN	imgui_widgets.cpp	/^#define STB_TEXTEDIT_K_PGDOWN /;"	d	file:
STB_TEXTEDIT_K_PGUP	imgui_widgets.cpp	/^#define STB_TEXTEDIT_K_PGUP /;"	d	file:
STB_TEXTEDIT_K_REDO	imgui_widgets.cpp	/^#define STB_TEXTEDIT_K_REDO /;"	d	file:
STB_TEXTEDIT_K_RIGHT	imgui_widgets.cpp	/^#define STB_TEXTEDIT_K_RIGHT /;"	d	file:
STB_TEXTEDIT_K_SHIFT	imgui_widgets.cpp	/^#define STB_TEXTEDIT_K_SHIFT /;"	d	file:
STB_TEXTEDIT_K_TEXTEND	imgui_widgets.cpp	/^#define STB_TEXTEDIT_K_TEXTEND /;"	d	file:
STB_TEXTEDIT_K_TEXTSTART	imgui_widgets.cpp	/^#define STB_TEXTEDIT_K_TEXTSTART /;"	d	file:
STB_TEXTEDIT_K_UNDO	imgui_widgets.cpp	/^#define STB_TEXTEDIT_K_UNDO /;"	d	file:
STB_TEXTEDIT_K_UP	imgui_widgets.cpp	/^#define STB_TEXTEDIT_K_UP /;"	d	file:
STB_TEXTEDIT_K_WORDLEFT	imgui_widgets.cpp	/^#define STB_TEXTEDIT_K_WORDLEFT /;"	d	file:
STB_TEXTEDIT_K_WORDRIGHT	imgui_widgets.cpp	/^#define STB_TEXTEDIT_K_WORDRIGHT /;"	d	file:
STB_TEXTEDIT_LAYOUTROW	imgui_widgets.cpp	/^static void    STB_TEXTEDIT_LAYOUTROW(StbTexteditRow* r, STB_TEXTEDIT_STRING* obj, int line_start_idx)$/;"	f	namespace:ImStb
STB_TEXTEDIT_MOVEWORDLEFT	imgui_widgets.cpp	/^#define STB_TEXTEDIT_MOVEWORDLEFT /;"	d	file:
STB_TEXTEDIT_MOVEWORDLEFT	imstb_textedit.h	/^#define STB_TEXTEDIT_MOVEWORDLEFT /;"	d
STB_TEXTEDIT_MOVEWORDLEFT_IMPL	imgui_widgets.cpp	/^static int  STB_TEXTEDIT_MOVEWORDLEFT_IMPL(STB_TEXTEDIT_STRING* obj, int idx)   { idx--; while (idx >= 0 && !is_word_boundary_from_right(obj, idx)) idx--; return idx < 0 ? 0 : idx; }$/;"	f	namespace:ImStb
STB_TEXTEDIT_MOVEWORDRIGHT	imgui_widgets.cpp	/^#define STB_TEXTEDIT_MOVEWORDRIGHT /;"	d	file:
STB_TEXTEDIT_MOVEWORDRIGHT	imstb_textedit.h	/^#define STB_TEXTEDIT_MOVEWORDRIGHT /;"	d
STB_TEXTEDIT_MOVEWORDRIGHT_IMPL	imgui_widgets.cpp	/^static int  STB_TEXTEDIT_MOVEWORDRIGHT_IMPL(STB_TEXTEDIT_STRING* obj, int idx)  { idx++; int len = obj->CurLenW; while (idx < len && !is_word_boundary_from_left(obj, idx)) idx++; return idx > len ? len : idx; }$/;"	f	namespace:ImStb
STB_TEXTEDIT_MOVEWORDRIGHT_IMPL	imgui_widgets.cpp	/^static int  STB_TEXTEDIT_MOVEWORDRIGHT_IMPL(STB_TEXTEDIT_STRING* obj, int idx)  { idx++; int len = obj->CurLenW; while (idx < len && !is_word_boundary_from_right(obj, idx)) idx++; return idx > len ? len : idx; }$/;"	f	namespace:ImStb
STB_TEXTEDIT_NEWLINE	imgui_widgets.cpp	/^static ImWchar STB_TEXTEDIT_NEWLINE = '\\n';$/;"	m	namespace:ImStb	file:
STB_TEXTEDIT_POSITIONTYPE	imstb_textedit.h	/^#define STB_TEXTEDIT_POSITIONTYPE /;"	d
STB_TEXTEDIT_STRING	imgui_internal.h	/^#define STB_TEXTEDIT_STRING /;"	d
STB_TEXTEDIT_STRING	imgui_internal.h	/^#undef STB_TEXTEDIT_STRING$/;"	d
STB_TEXTEDIT_STRINGLEN	imgui_widgets.cpp	/^static int     STB_TEXTEDIT_STRINGLEN(const STB_TEXTEDIT_STRING* obj)                             { return obj->CurLenW; }$/;"	f	namespace:ImStb
STB_TEXTEDIT_UNDOCHARCOUNT	imgui_internal.h	/^#define STB_TEXTEDIT_UNDOCHARCOUNT /;"	d
STB_TEXTEDIT_UNDOCHARCOUNT	imstb_textedit.h	/^#define STB_TEXTEDIT_UNDOCHARCOUNT /;"	d
STB_TEXTEDIT_UNDOSTATECOUNT	imgui_internal.h	/^#define STB_TEXTEDIT_UNDOSTATECOUNT /;"	d
STB_TEXTEDIT_UNDOSTATECOUNT	imstb_textedit.h	/^#define STB_TEXTEDIT_UNDOSTATECOUNT /;"	d
STB_TEXTEDIT_memmove	imstb_textedit.h	/^#define STB_TEXTEDIT_memmove /;"	d
STB_TEXT_HAS_SELECTION	imstb_textedit.h	/^#define STB_TEXT_HAS_SELECTION(/;"	d
STB_TRUETYPE_IMPLEMENTATION	imgui_draw.cpp	/^#define STB_TRUETYPE_IMPLEMENTATION$/;"	d	file:
STB_TexteditState	imstb_textedit.h	/^} STB_TexteditState;$/;"	t	typeref:struct:__anon4
SameLine	imgui.cpp	/^void ImGui::SameLine(float offset_from_start_x, float spacing_w)$/;"	f	class:ImGui
SanitizeFormatString	imgui_widgets.cpp	/^static void SanitizeFormatString(const char* fmt, char* fmt_out, size_t fmt_out_size)$/;"	f	file:
SaveFlags	imgui_internal.h	/^    ImGuiTableFlags             SaveFlags;              \/\/ Indicate data we want to save using the Resizable\/Reorderable\/Sortable\/Hideable flags (could be using its own flags..)$/;"	m	struct:ImGuiTableSettings
SaveIniSettingsToDisk	imgui.cpp	/^void ImGui::SaveIniSettingsToDisk(const char* ini_filename)$/;"	f	class:ImGui
SaveIniSettingsToMemory	imgui.cpp	/^const char* ImGui::SaveIniSettingsToMemory(size_t* out_size)$/;"	f	class:ImGui
Scale	imgui.h	/^    float                       Scale;              \/\/ 4     \/\/ in  \/\/ = 1.f      \/\/ Base font scale, multiplied by the per-window font scale which you can adjust with SetWindowFontScale()$/;"	m	struct:ImFont
ScaleAllSizes	imgui.cpp	/^void ImGuiStyle::ScaleAllSizes(float scale_factor)$/;"	f	class:ImGuiStyle
ScaleClipRects	imgui_draw.cpp	/^void ImDrawData::ScaleClipRects(const ImVec2& fb_scale)$/;"	f	class:ImDrawData
ScaleRatioFromValueT	imgui_widgets.cpp	/^float ImGui::ScaleRatioFromValueT(ImGuiDataType data_type, TYPE v, TYPE v_min, TYPE v_max, bool is_logarithmic, float logarithmic_zero_epsilon, float zero_deadzone_halfsize)$/;"	f	class:ImGui
ScaleValueFromRatioT	imgui_widgets.cpp	/^TYPE ImGui::ScaleValueFromRatioT(ImGuiDataType data_type, float t, TYPE v_min, TYPE v_max, bool is_logarithmic, float logarithmic_zero_epsilon, float zero_deadzone_halfsize)$/;"	f	class:ImGui
ScanFmt	imgui_internal.h	/^    const char* ScanFmt;        \/\/ Default scanf format for the type$/;"	m	struct:ImGuiDataTypeInfo
Scroll	imgui_internal.h	/^    ImVec2                  Scroll;$/;"	m	struct:ImGuiWindow
ScrollMax	imgui_internal.h	/^    ImVec2                  ScrollMax;$/;"	m	struct:ImGuiWindow
ScrollTarget	imgui_internal.h	/^    ImVec2                  ScrollTarget;                       \/\/ target scroll position. stored as cursor position with scrolling canceled out, so the highest point is always 0.0f. (FLT_MAX for no change)$/;"	m	struct:ImGuiWindow
ScrollTargetCenterRatio	imgui_internal.h	/^    ImVec2                  ScrollTargetCenterRatio;            \/\/ 0.0f = scroll so that target position is at top, 0.5f = scroll so that target position is centered$/;"	m	struct:ImGuiWindow
ScrollTargetEdgeSnapDist	imgui_internal.h	/^    ImVec2                  ScrollTargetEdgeSnapDist;           \/\/ 0.0f = no snapping, >0.0f snapping threshold$/;"	m	struct:ImGuiWindow
ScrollToBottom	imgui_demo.cpp	/^    bool                  ScrollToBottom;$/;"	m	struct:ExampleAppConsole	file:
ScrollToBringRectIntoView	imgui.cpp	/^ImVec2 ImGui::ScrollToBringRectIntoView(ImGuiWindow* window, const ImRect& item_rect)$/;"	f	class:ImGui
ScrollVal	imgui_internal.h	/^    ImVec2                      ScrollVal;$/;"	m	struct:ImGuiNextWindowData
ScrollX	imgui_internal.h	/^    float                   ScrollX;                \/\/ horizontal scrolling\/offset$/;"	m	struct:ImGuiInputTextState
Scrollbar	imgui_widgets.cpp	/^void ImGui::Scrollbar(ImGuiAxis axis)$/;"	f	class:ImGui
ScrollbarClickDeltaToGrabCenter	imgui_internal.h	/^    float                   ScrollbarClickDeltaToGrabCenter;    \/\/ Distance between mouse and center of grab box, normalized in parent space. Use storage?$/;"	m	struct:ImGuiContext
ScrollbarEx	imgui_widgets.cpp	/^bool ImGui::ScrollbarEx(const ImRect& bb_frame, ImGuiID id, ImGuiAxis axis, float* p_scroll_v, float size_avail_v, float size_contents_v, ImDrawFlags flags)$/;"	f	class:ImGui
ScrollbarRounding	imgui.h	/^    float       ScrollbarRounding;          \/\/ Radius of grab corners for scrollbar.$/;"	m	struct:ImGuiStyle
ScrollbarSize	imgui.h	/^    float       ScrollbarSize;              \/\/ Width of the vertical scrollbar, Height of the horizontal scrollbar.$/;"	m	struct:ImGuiStyle
ScrollbarSizes	imgui_internal.h	/^    ImVec2                  ScrollbarSizes;                     \/\/ Size taken by each scrollbars on their smaller axis. Pay attention! ScrollbarSizes.x == width of the vertical scrollbar, ScrollbarSizes.y = height of the horizontal scrollbar.$/;"	m	struct:ImGuiWindow
ScrollbarX	imgui_internal.h	/^    bool                    ScrollbarX, ScrollbarY;             \/\/ Are scrollbars visible?$/;"	m	struct:ImGuiWindow
ScrollbarY	imgui_internal.h	/^    bool                    ScrollbarX, ScrollbarY;             \/\/ Are scrollbars visible?$/;"	m	struct:ImGuiWindow
ScrollingAnim	imgui_internal.h	/^    float               ScrollingAnim;$/;"	m	struct:ImGuiTabBar
ScrollingRectMaxX	imgui_internal.h	/^    float               ScrollingRectMaxX;$/;"	m	struct:ImGuiTabBar
ScrollingRectMinX	imgui_internal.h	/^    float               ScrollingRectMinX;$/;"	m	struct:ImGuiTabBar
ScrollingSpeed	imgui_internal.h	/^    float               ScrollingSpeed;$/;"	m	struct:ImGuiTabBar
ScrollingTarget	imgui_internal.h	/^    float               ScrollingTarget;$/;"	m	struct:ImGuiTabBar
ScrollingTargetDistToVisibility	imgui_internal.h	/^    float               ScrollingTargetDistToVisibility;$/;"	m	struct:ImGuiTabBar
SegmentN1	imgui.cpp	/^    ImVec2 SegmentN1, SegmentN2;$/;"	m	struct:ImGuiResizeBorderDef	file:
SegmentN2	imgui.cpp	/^    ImVec2 SegmentN1, SegmentN2;$/;"	m	struct:ImGuiResizeBorderDef	file:
SelectAll	imgui.h	/^    void                SelectAll()             { SelectionStart = 0; SelectionEnd = BufTextLen; }$/;"	f	struct:ImGuiInputTextCallbackData
SelectAll	imgui_internal.h	/^    void        SelectAll()                 { Stb.select_start = 0; Stb.cursor = Stb.select_end = CurLenW; Stb.has_preferred_x = 0; }$/;"	f	struct:ImGuiInputTextState
Selectable	imgui_widgets.cpp	/^bool ImGui::Selectable(const char* label, bool selected, ImGuiSelectableFlags flags, const ImVec2& size_arg)$/;"	f	class:ImGui
Selectable	imgui_widgets.cpp	/^bool ImGui::Selectable(const char* label, bool* p_selected, ImGuiSelectableFlags flags, const ImVec2& size_arg)$/;"	f	class:ImGui
SelectableTextAlign	imgui.h	/^    ImVec2      SelectableTextAlign;        \/\/ Alignment of selectable text. Defaults to (0.0f, 0.0f) (top-left aligned). It's generally important to keep this left-aligned if you want to lay multiple items on a same line.$/;"	m	struct:ImGuiStyle
SelectedAllMouseLock	imgui_internal.h	/^    bool                    SelectedAllMouseLock;   \/\/ after a double-click to select all, we ignore further mouse drags to update selection$/;"	m	struct:ImGuiInputTextState
SelectedTabId	imgui_internal.h	/^    ImGuiID             SelectedTabId;          \/\/ Selected tab\/window$/;"	m	struct:ImGuiTabBar
SelectionEnd	imgui.h	/^    int                 SelectionEnd;   \/\/                                      \/\/ Read-write   \/\/ [Completion,History,Always]$/;"	m	struct:ImGuiInputTextCallbackData
SelectionStart	imgui.h	/^    int                 SelectionStart; \/\/                                      \/\/ Read-write   \/\/ [Completion,History,Always] == to SelectionEnd when no selection)$/;"	m	struct:ImGuiInputTextCallbackData
Separator	imgui_widgets.cpp	/^void ImGui::Separator()$/;"	f	class:ImGui
SeparatorEx	imgui_widgets.cpp	/^void ImGui::SeparatorEx(ImGuiSeparatorFlags flags)$/;"	f	class:ImGui
SetActiveID	imgui.cpp	/^void ImGui::SetActiveID(ImGuiID id, ImGuiWindow* window)$/;"	f	class:ImGui
SetAllBits	imgui_internal.h	/^    void            SetAllBits()                { memset(Storage, 255, sizeof(Storage)); }$/;"	f	struct:ImBitArray
SetAllInt	imgui.cpp	/^void ImGuiStorage::SetAllInt(int v)$/;"	f	class:ImGuiStorage
SetAllocatorFunctions	imgui.cpp	/^void ImGui::SetAllocatorFunctions(ImGuiMemAllocFunc alloc_func, ImGuiMemFreeFunc free_func, void* user_data)$/;"	f	class:ImGui
SetArenaBasePtr	imgui_internal.h	/^    inline void  SetArenaBasePtr(void* base_ptr)    { BasePtr = (char*)base_ptr; }$/;"	f	struct:ImSpanAllocator
SetBit	imgui.h	/^    inline void     SetBit(size_t n)        { int off = (int)(n >> 5); ImU32 mask = 1u << (n & 31); UsedChars[off] |= mask; }               \/\/ Set bit n in the array$/;"	f	struct:ImFontGlyphRangesBuilder
SetBit	imgui_internal.h	/^    void            SetBit(int n)               { IM_ASSERT(n < (Storage.Size << 5)); ImBitArraySetBit(Storage.Data, n); }$/;"	f	struct:ImBitVector
SetBit	imgui_internal.h	/^    void            SetBit(int n)               { IM_ASSERT(n < BITCOUNT); ImBitArraySetBit(Storage, n); }$/;"	f	struct:ImBitArray
SetBitRange	imgui_internal.h	/^    void            SetBitRange(int n, int n2)  { ImBitArraySetBitRange(Storage, n, n2); } \/\/ Works on range [n..n2)$/;"	f	struct:ImBitArray
SetBool	imgui.cpp	/^void ImGuiStorage::SetBool(ImGuiID key, bool val)$/;"	f	class:ImGuiStorage
SetCircleTessellationMaxError	imgui_draw.cpp	/^void ImDrawListSharedData::SetCircleTessellationMaxError(float max_error)$/;"	f	class:ImDrawListSharedData
SetClipboardText	imgui.cpp	/^void ImGui::SetClipboardText(const char* text)$/;"	f	class:ImGui
SetClipboardTextFn	imgui.h	/^    void        (*SetClipboardTextFn)(void* user_data, const char* text);$/;"	m	struct:ImGuiIO
SetClipboardTextFn_DefaultImpl	imgui.cpp	/^static void SetClipboardTextFn_DefaultImpl(void*, const char* text)$/;"	f	file:
SetColorEditOptions	imgui_widgets.cpp	/^void ImGui::SetColorEditOptions(ImGuiColorEditFlags flags)$/;"	f	class:ImGui
SetColumnOffset	imgui_tables.cpp	/^void ImGui::SetColumnOffset(int column_index, float offset)$/;"	f	class:ImGui
SetColumnWidth	imgui_tables.cpp	/^void ImGui::SetColumnWidth(int column_index, float width)$/;"	f	class:ImGui
SetCurrentChannel	imgui_draw.cpp	/^void ImDrawListSplitter::SetCurrentChannel(ImDrawList* draw_list, int idx)$/;"	f	class:ImDrawListSplitter
SetCurrentContext	imgui.cpp	/^void ImGui::SetCurrentContext(ImGuiContext* ctx)$/;"	f	class:ImGui
SetCurrentFont	imgui.cpp	/^void ImGui::SetCurrentFont(ImFont* font)$/;"	f	class:ImGui
SetCurrentWindow	imgui.cpp	/^static void SetCurrentWindow(ImGuiWindow* window)$/;"	f	file:
SetCursorPos	imgui.cpp	/^void ImGui::SetCursorPos(const ImVec2& local_pos)$/;"	f	class:ImGui
SetCursorPosX	imgui.cpp	/^void ImGui::SetCursorPosX(float x)$/;"	f	class:ImGui
SetCursorPosY	imgui.cpp	/^void ImGui::SetCursorPosY(float y)$/;"	f	class:ImGui
SetCursorPosYAndSetupForPrevLine	imgui.cpp	/^static void SetCursorPosYAndSetupForPrevLine(float pos_y, float line_height)$/;"	f	file:
SetCursorScreenPos	imgui.cpp	/^void ImGui::SetCursorScreenPos(const ImVec2& pos)$/;"	f	class:ImGui
SetDragDropPayload	imgui.cpp	/^bool ImGui::SetDragDropPayload(const char* type, const void* data, size_t data_size, ImGuiCond cond)$/;"	f	class:ImGui
SetFallbackChar	imgui_draw.cpp	/^void ImFont::SetFallbackChar(ImWchar c)$/;"	f	class:ImFont
SetFloat	imgui.cpp	/^void ImGuiStorage::SetFloat(ImGuiID key, float val)$/;"	f	class:ImGuiStorage
SetFocusID	imgui.cpp	/^void ImGui::SetFocusID(ImGuiID id, ImGuiWindow* window)$/;"	f	class:ImGui
SetGlyphVisible	imgui_draw.cpp	/^void ImFont::SetGlyphVisible(ImWchar c, bool visible)$/;"	f	class:ImFont
SetHSV	imgui.h	/^    inline void    SetHSV(float h, float s, float v, float a = 1.0f){ ImGui::ColorConvertHSVtoRGB(h, s, v, Value.x, Value.y, Value.z); Value.w = a; }$/;"	f	struct:ImColor
SetHoveredID	imgui.cpp	/^void ImGui::SetHoveredID(ImGuiID id)$/;"	f	class:ImGui
SetInt	imgui.cpp	/^void ImGuiStorage::SetInt(ImGuiID key, int val)$/;"	f	class:ImGuiStorage
SetItemAllowOverlap	imgui.cpp	/^void ImGui::SetItemAllowOverlap()$/;"	f	class:ImGui
SetItemDefaultFocus	imgui.cpp	/^void ImGui::SetItemDefaultFocus()$/;"	f	class:ImGui
SetItemUsingMouseWheel	imgui.cpp	/^void ImGui::SetItemUsingMouseWheel()$/;"	f	class:ImGui
SetKeyboardFocusHere	imgui.cpp	/^void ImGui::SetKeyboardFocusHere(int offset)$/;"	f	class:ImGui
SetLastItemData	imgui.cpp	/^void ImGui::SetLastItemData(ImGuiWindow* window, ImGuiID item_id, ImGuiItemStatusFlags item_flags, const ImRect& item_rect)$/;"	f	class:ImGui
SetMouseCursor	imgui.cpp	/^void ImGui::SetMouseCursor(ImGuiMouseCursor cursor_type)$/;"	f	class:ImGui
SetNavID	imgui.cpp	/^void ImGui::SetNavID(ImGuiID id, ImGuiNavLayer nav_layer, ImGuiID focus_scope_id, const ImRect& rect_rel)$/;"	f	class:ImGui
SetNextItemOpen	imgui_widgets.cpp	/^void ImGui::SetNextItemOpen(bool is_open, ImGuiCond cond)$/;"	f	class:ImGui
SetNextItemWidth	imgui.cpp	/^void ImGui::SetNextItemWidth(float item_width)$/;"	f	class:ImGui
SetNextTreeNodeOpen	imgui.h	/^    static inline void  SetNextTreeNodeOpen(bool open, ImGuiCond cond = 0) { SetNextItemOpen(open, cond); }$/;"	f	namespace:ImGui
SetNextWindowBgAlpha	imgui.cpp	/^void ImGui::SetNextWindowBgAlpha(float alpha)$/;"	f	class:ImGui
SetNextWindowCollapsed	imgui.cpp	/^void ImGui::SetNextWindowCollapsed(bool collapsed, ImGuiCond cond)$/;"	f	class:ImGui
SetNextWindowContentSize	imgui.cpp	/^void ImGui::SetNextWindowContentSize(const ImVec2& size)$/;"	f	class:ImGui
SetNextWindowFocus	imgui.cpp	/^void ImGui::SetNextWindowFocus()$/;"	f	class:ImGui
SetNextWindowPos	imgui.cpp	/^void ImGui::SetNextWindowPos(const ImVec2& pos, ImGuiCond cond, const ImVec2& pivot)$/;"	f	class:ImGui
SetNextWindowScroll	imgui.cpp	/^void ImGui::SetNextWindowScroll(const ImVec2& scroll)$/;"	f	class:ImGui
SetNextWindowSize	imgui.cpp	/^void ImGui::SetNextWindowSize(const ImVec2& size, ImGuiCond cond)$/;"	f	class:ImGui
SetNextWindowSizeConstraints	imgui.cpp	/^void ImGui::SetNextWindowSizeConstraints(const ImVec2& size_min, const ImVec2& size_max, ImGuiSizeCallback custom_callback, void* custom_callback_user_data)$/;"	f	class:ImGui
SetScrollFromPosX	imgui.cpp	/^void ImGui::SetScrollFromPosX(ImGuiWindow* window, float local_x, float center_x_ratio)$/;"	f	class:ImGui
SetScrollFromPosX	imgui.cpp	/^void ImGui::SetScrollFromPosX(float local_x, float center_x_ratio)$/;"	f	class:ImGui
SetScrollFromPosY	imgui.cpp	/^void ImGui::SetScrollFromPosY(ImGuiWindow* window, float local_y, float center_y_ratio)$/;"	f	class:ImGui
SetScrollFromPosY	imgui.cpp	/^void ImGui::SetScrollFromPosY(float local_y, float center_y_ratio)$/;"	f	class:ImGui
SetScrollHereX	imgui.cpp	/^void ImGui::SetScrollHereX(float center_x_ratio)$/;"	f	class:ImGui
SetScrollHereY	imgui.cpp	/^void ImGui::SetScrollHereY(float center_y_ratio)$/;"	f	class:ImGui
SetScrollX	imgui.cpp	/^void ImGui::SetScrollX(ImGuiWindow* window, float scroll_x)$/;"	f	class:ImGui
SetScrollX	imgui.cpp	/^void ImGui::SetScrollX(float scroll_x)$/;"	f	class:ImGui
SetScrollY	imgui.cpp	/^void ImGui::SetScrollY(ImGuiWindow* window, float scroll_y)$/;"	f	class:ImGui
SetScrollY	imgui.cpp	/^void ImGui::SetScrollY(float scroll_y)$/;"	f	class:ImGui
SetStateStorage	imgui.cpp	/^void ImGui::SetStateStorage(ImGuiStorage* tree)$/;"	f	class:ImGui
SetTabItemClosed	imgui_widgets.cpp	/^void    ImGui::SetTabItemClosed(const char* label)$/;"	f	class:ImGui
SetTexID	imgui.h	/^    void                        SetTexID(ImTextureID id)    { TexID = id; }$/;"	f	struct:ImFontAtlas
SetToCurrentState	imgui.cpp	/^void ImGuiStackSizes::SetToCurrentState()$/;"	f	class:ImGuiStackSizes
SetTooltip	imgui.cpp	/^void ImGui::SetTooltip(const char* fmt, ...)$/;"	f	class:ImGui
SetTooltipV	imgui.cpp	/^void ImGui::SetTooltipV(const char* fmt, va_list args)$/;"	f	class:ImGui
SetVoidPtr	imgui.cpp	/^void ImGuiStorage::SetVoidPtr(ImGuiID key, void* val)$/;"	f	class:ImGuiStorage
SetWindowClipRectBeforeSetChannel	imgui_tables.cpp	/^void ImGui::SetWindowClipRectBeforeSetChannel(ImGuiWindow* window, const ImRect& clip_rect)$/;"	f	class:ImGui
SetWindowCollapsed	imgui.cpp	/^void ImGui::SetWindowCollapsed(ImGuiWindow* window, bool collapsed, ImGuiCond cond)$/;"	f	class:ImGui
SetWindowCollapsed	imgui.cpp	/^void ImGui::SetWindowCollapsed(bool collapsed, ImGuiCond cond)$/;"	f	class:ImGui
SetWindowCollapsed	imgui.cpp	/^void ImGui::SetWindowCollapsed(const char* name, bool collapsed, ImGuiCond cond)$/;"	f	class:ImGui
SetWindowCollapsedAllowFlags	imgui_internal.h	/^    ImGuiCond               SetWindowCollapsedAllowFlags : 8;   \/\/ store acceptable condition flags for SetNextWindowCollapsed() use.$/;"	m	struct:ImGuiWindow
SetWindowConditionAllowFlags	imgui.cpp	/^static void SetWindowConditionAllowFlags(ImGuiWindow* window, ImGuiCond flags, bool enabled)$/;"	f	file:
SetWindowFocus	imgui.cpp	/^void ImGui::SetWindowFocus()$/;"	f	class:ImGui
SetWindowFocus	imgui.cpp	/^void ImGui::SetWindowFocus(const char* name)$/;"	f	class:ImGui
SetWindowFontScale	imgui.cpp	/^void ImGui::SetWindowFontScale(float scale)$/;"	f	class:ImGui
SetWindowHitTestHole	imgui.cpp	/^void ImGui::SetWindowHitTestHole(ImGuiWindow* window, const ImVec2& pos, const ImVec2& size)$/;"	f	class:ImGui
SetWindowPos	imgui.cpp	/^void ImGui::SetWindowPos(ImGuiWindow* window, const ImVec2& pos, ImGuiCond cond)$/;"	f	class:ImGui
SetWindowPos	imgui.cpp	/^void ImGui::SetWindowPos(const ImVec2& pos, ImGuiCond cond)$/;"	f	class:ImGui
SetWindowPos	imgui.cpp	/^void ImGui::SetWindowPos(const char* name, const ImVec2& pos, ImGuiCond cond)$/;"	f	class:ImGui
SetWindowPosAllowFlags	imgui_internal.h	/^    ImGuiCond               SetWindowPosAllowFlags : 8;         \/\/ store acceptable condition flags for SetNextWindowPos() use.$/;"	m	struct:ImGuiWindow
SetWindowPosPivot	imgui_internal.h	/^    ImVec2                  SetWindowPosPivot;                  \/\/ store window pivot for positioning. ImVec2(0, 0) when positioning from top-left corner; ImVec2(0.5f, 0.5f) for centering; ImVec2(1, 1) for bottom right.$/;"	m	struct:ImGuiWindow
SetWindowPosVal	imgui_internal.h	/^    ImVec2                  SetWindowPosVal;                    \/\/ store window position when using a non-zero Pivot (position set needs to be processed when we know the window size)$/;"	m	struct:ImGuiWindow
SetWindowSize	imgui.cpp	/^void ImGui::SetWindowSize(ImGuiWindow* window, const ImVec2& size, ImGuiCond cond)$/;"	f	class:ImGui
SetWindowSize	imgui.cpp	/^void ImGui::SetWindowSize(const ImVec2& size, ImGuiCond cond)$/;"	f	class:ImGui
SetWindowSize	imgui.cpp	/^void ImGui::SetWindowSize(const char* name, const ImVec2& size, ImGuiCond cond)$/;"	f	class:ImGui
SetWindowSizeAllowFlags	imgui_internal.h	/^    ImGuiCond               SetWindowSizeAllowFlags : 8;        \/\/ store acceptable condition flags for SetNextWindowSize() use.$/;"	m	struct:ImGuiWindow
SettingsDirtyTimer	imgui_internal.h	/^    float                   SettingsDirtyTimer;                 \/\/ Save .ini Settings to memory when time reaches zero$/;"	m	struct:ImGuiContext
SettingsHandlers	imgui_internal.h	/^    ImVector<ImGuiSettingsHandler>      SettingsHandlers;       \/\/ List of .ini settings handlers$/;"	m	struct:ImGuiContext
SettingsIniData	imgui_internal.h	/^    ImGuiTextBuffer         SettingsIniData;                    \/\/ In memory .ini settings$/;"	m	struct:ImGuiContext
SettingsLoaded	imgui_internal.h	/^    bool                    SettingsLoaded;$/;"	m	struct:ImGuiContext
SettingsLoadedFlags	imgui_internal.h	/^    ImGuiTableFlags             SettingsLoadedFlags;        \/\/ Which data were loaded from the .ini file (e.g. when order is not altered we won't save order)$/;"	m	struct:ImGuiTable
SettingsOffset	imgui_internal.h	/^    int                         SettingsOffset;             \/\/ Offset in g.SettingsTables$/;"	m	struct:ImGuiTable
SettingsOffset	imgui_internal.h	/^    int                     SettingsOffset;                     \/\/ Offset into SettingsWindows[] (offsets are always valid as we only grow the array from the back)$/;"	m	struct:ImGuiWindow
SettingsTables	imgui_internal.h	/^    ImChunkStream<ImGuiTableSettings>   SettingsTables;         \/\/ ImGuiTable .ini settings entries$/;"	m	struct:ImGuiContext
SettingsWindows	imgui_internal.h	/^    ImChunkStream<ImGuiWindowSettings>  SettingsWindows;        \/\/ ImGuiWindow .ini settings entries$/;"	m	struct:ImGuiContext
SetupViewportDrawData	imgui.cpp	/^static void SetupViewportDrawData(ImGuiViewportP* viewport, ImVector<ImDrawList*>* draw_lists)$/;"	f	file:
ShadeVertsLinearColorGradientKeepAlpha	imgui_draw.cpp	/^void ImGui::ShadeVertsLinearColorGradientKeepAlpha(ImDrawList* draw_list, int vert_start_idx, int vert_end_idx, ImVec2 gradient_p0, ImVec2 gradient_p1, ImU32 col0, ImU32 col1)$/;"	f	class:ImGui
ShadeVertsLinearUV	imgui_draw.cpp	/^void ImGui::ShadeVertsLinearUV(ImDrawList* draw_list, int vert_start_idx, int vert_end_idx, const ImVec2& a, const ImVec2& b, const ImVec2& uv_a, const ImVec2& uv_b, bool clamp)$/;"	f	class:ImGui
ShowAboutWindow	imgui_demo.cpp	/^void ImGui::ShowAboutWindow(bool* p_open)$/;"	f	class:ImGui
ShowAboutWindow	imgui_demo.cpp	/^void ImGui::ShowAboutWindow(bool*) {}$/;"	f	class:ImGui
ShowDemoWindow	imgui_demo.cpp	/^void ImGui::ShowDemoWindow(bool* p_open)$/;"	f	class:ImGui
ShowDemoWindow	imgui_demo.cpp	/^void ImGui::ShowDemoWindow(bool*) {}$/;"	f	class:ImGui
ShowDemoWindowColumns	imgui_demo.cpp	/^static void ShowDemoWindowColumns()$/;"	f	file:
ShowDemoWindowLayout	imgui_demo.cpp	/^static void ShowDemoWindowLayout()$/;"	f	file:
ShowDemoWindowMisc	imgui_demo.cpp	/^static void ShowDemoWindowMisc()$/;"	f	file:
ShowDemoWindowPopups	imgui_demo.cpp	/^static void ShowDemoWindowPopups()$/;"	f	file:
ShowDemoWindowTables	imgui_demo.cpp	/^static void ShowDemoWindowTables()$/;"	f	file:
ShowDemoWindowWidgets	imgui_demo.cpp	/^static void ShowDemoWindowWidgets()$/;"	f	file:
ShowDrawCmdBoundingBoxes	imgui_internal.h	/^    bool        ShowDrawCmdBoundingBoxes;$/;"	m	struct:ImGuiMetricsConfig
ShowDrawCmdMesh	imgui_internal.h	/^    bool        ShowDrawCmdMesh;$/;"	m	struct:ImGuiMetricsConfig
ShowExampleAppAutoResize	imgui_demo.cpp	/^static void ShowExampleAppAutoResize(bool* p_open)$/;"	f	file:
ShowExampleAppConsole	imgui_demo.cpp	/^static void ShowExampleAppConsole(bool* p_open)$/;"	f	file:
ShowExampleAppConstrainedResize	imgui_demo.cpp	/^static void ShowExampleAppConstrainedResize(bool* p_open)$/;"	f	file:
ShowExampleAppCustomRendering	imgui_demo.cpp	/^static void ShowExampleAppCustomRendering(bool* p_open)$/;"	f	file:
ShowExampleAppDocuments	imgui_demo.cpp	/^void ShowExampleAppDocuments(bool* p_open)$/;"	f
ShowExampleAppFullscreen	imgui_demo.cpp	/^static void ShowExampleAppFullscreen(bool* p_open)$/;"	f	file:
ShowExampleAppLayout	imgui_demo.cpp	/^static void ShowExampleAppLayout(bool* p_open)$/;"	f	file:
ShowExampleAppLog	imgui_demo.cpp	/^static void ShowExampleAppLog(bool* p_open)$/;"	f	file:
ShowExampleAppLongText	imgui_demo.cpp	/^static void ShowExampleAppLongText(bool* p_open)$/;"	f	file:
ShowExampleAppMainMenuBar	imgui_demo.cpp	/^static void ShowExampleAppMainMenuBar()$/;"	f	file:
ShowExampleAppPropertyEditor	imgui_demo.cpp	/^static void ShowExampleAppPropertyEditor(bool* p_open)$/;"	f	file:
ShowExampleAppSimpleOverlay	imgui_demo.cpp	/^static void ShowExampleAppSimpleOverlay(bool* p_open)$/;"	f	file:
ShowExampleAppWindowTitles	imgui_demo.cpp	/^static void ShowExampleAppWindowTitles(bool*)$/;"	f	file:
ShowExampleMenuFile	imgui_demo.cpp	/^static void ShowExampleMenuFile()$/;"	f	file:
ShowFontSelector	imgui_demo.cpp	/^void ImGui::ShowFontSelector(const char* label)$/;"	f	class:ImGui
ShowMetricsWindow	imgui.cpp	/^void ImGui::ShowMetricsWindow(bool* p_open)$/;"	f	class:ImGui
ShowMetricsWindow	imgui.cpp	/^void ImGui::ShowMetricsWindow(bool*) {}$/;"	f	class:ImGui
ShowPlaceholderObject	imgui_demo.cpp	/^static void ShowPlaceholderObject(const char* prefix, int uid)$/;"	f	file:
ShowStyleEditor	imgui_demo.cpp	/^void ImGui::ShowStyleEditor(ImGuiStyle* ref)$/;"	f	class:ImGui
ShowStyleEditor	imgui_demo.cpp	/^void ImGui::ShowStyleEditor(ImGuiStyle*) {}$/;"	f	class:ImGui
ShowStyleSelector	imgui_demo.cpp	/^bool ImGui::ShowStyleSelector(const char* label)$/;"	f	class:ImGui
ShowTableColumnsStatusFlags	imgui_demo.cpp	/^static void ShowTableColumnsStatusFlags(ImGuiTableColumnFlags flags)$/;"	f	file:
ShowTablesRects	imgui_internal.h	/^    bool        ShowTablesRects;$/;"	m	struct:ImGuiMetricsConfig
ShowTablesRectsType	imgui_internal.h	/^    int         ShowTablesRectsType;$/;"	m	struct:ImGuiMetricsConfig
ShowUserGuide	imgui_demo.cpp	/^void ImGui::ShowUserGuide() {}$/;"	f	class:ImGui
ShowUserGuide	imgui_demo.cpp	/^void ImGui::ShowUserGuide()$/;"	f	class:ImGui
ShowWindowsBeginOrder	imgui_internal.h	/^    bool        ShowWindowsBeginOrder;$/;"	m	struct:ImGuiMetricsConfig
ShowWindowsRects	imgui_internal.h	/^    bool        ShowWindowsRects;$/;"	m	struct:ImGuiMetricsConfig
ShowWindowsRectsType	imgui_internal.h	/^    int         ShowWindowsRectsType;$/;"	m	struct:ImGuiMetricsConfig
ShrinkWidthBuffer	imgui_internal.h	/^    ImVector<ImGuiShrinkWidthItem>  ShrinkWidthBuffer;$/;"	m	struct:ImGuiContext
ShrinkWidthItemComparer	imgui_widgets.cpp	/^static int IMGUI_CDECL ShrinkWidthItemComparer(const void* lhs, const void* rhs)$/;"	f	file:
ShrinkWidths	imgui_widgets.cpp	/^void ImGui::ShrinkWidths(ImGuiShrinkWidthItem* items, int count, float width_excess)$/;"	f	class:ImGui
Shutdown	imgui.cpp	/^void ImGui::Shutdown(ImGuiContext* context)$/;"	f	class:ImGui
Size	imgui.h	/^    ImVec2              Size;                   \/\/ Main Area: Size of the viewport.$/;"	m	struct:ImGuiViewport
Size	imgui.h	/^    int                 Size;$/;"	m	struct:ImVector
Size	imgui_internal.h	/^    ImVec2                  Size;                               \/\/ Current size (==SizeFull or collapsed title bar size)$/;"	m	struct:ImGuiWindow
Size	imgui_internal.h	/^    ImVec2ih    Size;$/;"	m	struct:ImGuiWindowSettings
Size	imgui_internal.h	/^    size_t      Size;           \/\/ Size in bytes$/;"	m	struct:ImGuiDataTypeInfo
SizeCallback	imgui_internal.h	/^    ImGuiSizeCallback           SizeCallback;$/;"	m	struct:ImGuiNextWindowData
SizeCallbackUserData	imgui_internal.h	/^    void*                       SizeCallbackUserData;$/;"	m	struct:ImGuiNextWindowData
SizeCond	imgui_internal.h	/^    ImGuiCond                   SizeCond;$/;"	m	struct:ImGuiNextWindowData
SizeConstraintRect	imgui_internal.h	/^    ImRect                      SizeConstraintRect;$/;"	m	struct:ImGuiNextWindowData
SizeFull	imgui_internal.h	/^    ImVec2                  SizeFull;                           \/\/ Size when non collapsed$/;"	m	struct:ImGuiWindow
SizeOfBeginPopupStack	imgui_internal.h	/^    short   SizeOfBeginPopupStack;$/;"	m	struct:ImGuiStackSizes
SizeOfColorStack	imgui_internal.h	/^    short   SizeOfColorStack;$/;"	m	struct:ImGuiStackSizes
SizeOfFocusScopeStack	imgui_internal.h	/^    short   SizeOfFocusScopeStack;$/;"	m	struct:ImGuiStackSizes
SizeOfFontStack	imgui_internal.h	/^    short   SizeOfFontStack;$/;"	m	struct:ImGuiStackSizes
SizeOfGroupStack	imgui_internal.h	/^    short   SizeOfGroupStack;$/;"	m	struct:ImGuiStackSizes
SizeOfIDStack	imgui_internal.h	/^    short   SizeOfIDStack;$/;"	m	struct:ImGuiStackSizes
SizeOfStyleVarStack	imgui_internal.h	/^    short   SizeOfStyleVarStack;$/;"	m	struct:ImGuiStackSizes
SizePixels	imgui.h	/^    float           SizePixels;             \/\/          \/\/ Size in pixels for rasterizer (more or less maps to the resulting font height).$/;"	m	struct:ImFontConfig
SizeVal	imgui_internal.h	/^    ImVec2                      SizeVal;$/;"	m	struct:ImGuiNextWindowData
Sizes	imgui_internal.h	/^    int     Sizes[CHUNKS];$/;"	m	struct:ImSpanAllocator
SkipItems	imgui_internal.h	/^    bool                    SkipItems;                          \/\/ Set when items can safely be all clipped (e.g. window not visible or collapsed)$/;"	m	struct:ImGuiWindow
SliderAngle	imgui_widgets.cpp	/^bool ImGui::SliderAngle(const char* label, float* v_rad, float v_degrees_min, float v_degrees_max, const char* format, ImGuiSliderFlags flags)$/;"	f	class:ImGui
SliderBehavior	imgui_widgets.cpp	/^bool ImGui::SliderBehavior(const ImRect& bb, ImGuiID id, ImGuiDataType data_type, void* p_v, const void* p_min, const void* p_max, const char* format, ImGuiSliderFlags flags, ImRect* out_grab_bb)$/;"	f	class:ImGui
SliderBehaviorT	imgui_widgets.cpp	/^bool ImGui::SliderBehaviorT(const ImRect& bb, ImGuiID id, ImGuiDataType data_type, TYPE* v, const TYPE v_min, const TYPE v_max, const char* format, ImGuiSliderFlags flags, ImRect* out_grab_bb)$/;"	f	class:ImGui
SliderCurrentAccum	imgui_internal.h	/^    float                   SliderCurrentAccum;                 \/\/ Accumulated slider delta when using navigation controls.$/;"	m	struct:ImGuiContext
SliderCurrentAccumDirty	imgui_internal.h	/^    bool                    SliderCurrentAccumDirty;            \/\/ Has the accumulated slider delta changed since last time we tried to apply it?$/;"	m	struct:ImGuiContext
SliderFloat	imgui.h	/^    static inline bool  SliderFloat(const char* label, float* v, float v_min, float v_max, const char* format, float power)                 { return SliderScalar(label, ImGuiDataType_Float, v, &v_min, &v_max, format, power); }$/;"	f	namespace:ImGui
SliderFloat	imgui_widgets.cpp	/^bool ImGui::SliderFloat(const char* label, float* v, float v_min, float v_max, const char* format, ImGuiSliderFlags flags)$/;"	f	class:ImGui
SliderFloat2	imgui.h	/^    static inline bool  SliderFloat2(const char* label, float v[2], float v_min, float v_max, const char* format, float power)              { return SliderScalarN(label, ImGuiDataType_Float, v, 2, &v_min, &v_max, format, power); }$/;"	f	namespace:ImGui
SliderFloat2	imgui_widgets.cpp	/^bool ImGui::SliderFloat2(const char* label, float v[2], float v_min, float v_max, const char* format, ImGuiSliderFlags flags)$/;"	f	class:ImGui
SliderFloat3	imgui.h	/^    static inline bool  SliderFloat3(const char* label, float v[3], float v_min, float v_max, const char* format, float power)              { return SliderScalarN(label, ImGuiDataType_Float, v, 3, &v_min, &v_max, format, power); }$/;"	f	namespace:ImGui
SliderFloat3	imgui_widgets.cpp	/^bool ImGui::SliderFloat3(const char* label, float v[3], float v_min, float v_max, const char* format, ImGuiSliderFlags flags)$/;"	f	class:ImGui
SliderFloat4	imgui.h	/^    static inline bool  SliderFloat4(const char* label, float v[4], float v_min, float v_max, const char* format, float power)              { return SliderScalarN(label, ImGuiDataType_Float, v, 4, &v_min, &v_max, format, power); }$/;"	f	namespace:ImGui
SliderFloat4	imgui_widgets.cpp	/^bool ImGui::SliderFloat4(const char* label, float v[4], float v_min, float v_max, const char* format, ImGuiSliderFlags flags)$/;"	f	class:ImGui
SliderInt	imgui_widgets.cpp	/^bool ImGui::SliderInt(const char* label, int* v, int v_min, int v_max, const char* format, ImGuiSliderFlags flags)$/;"	f	class:ImGui
SliderInt2	imgui_widgets.cpp	/^bool ImGui::SliderInt2(const char* label, int v[2], int v_min, int v_max, const char* format, ImGuiSliderFlags flags)$/;"	f	class:ImGui
SliderInt3	imgui_widgets.cpp	/^bool ImGui::SliderInt3(const char* label, int v[3], int v_min, int v_max, const char* format, ImGuiSliderFlags flags)$/;"	f	class:ImGui
SliderInt4	imgui_widgets.cpp	/^bool ImGui::SliderInt4(const char* label, int v[4], int v_min, int v_max, const char* format, ImGuiSliderFlags flags)$/;"	f	class:ImGui
SliderScalar	imgui_widgets.cpp	/^bool ImGui::SliderScalar(const char* label, ImGuiDataType data_type, void* p_data, const void* p_min, const void* p_max, const char* format, ImGuiSliderFlags flags)$/;"	f	class:ImGui
SliderScalar	imgui_widgets.cpp	/^bool ImGui::SliderScalar(const char* label, ImGuiDataType data_type, void* p_data, const void* p_min, const void* p_max, const char* format, float power)$/;"	f	class:ImGui
SliderScalarN	imgui_widgets.cpp	/^bool ImGui::SliderScalarN(const char* label, ImGuiDataType data_type, void* v, int components, const void* v_min, const void* v_max, const char* format, ImGuiSliderFlags flags)$/;"	f	class:ImGui
SliderScalarN	imgui_widgets.cpp	/^bool ImGui::SliderScalarN(const char* label, ImGuiDataType data_type, void* v, int components, const void* v_min, const void* v_max, const char* format, float power)$/;"	f	class:ImGui
SmallButton	imgui_widgets.cpp	/^bool ImGui::SmallButton(const char* label)$/;"	f	class:ImGui
SortDirection	imgui.h	/^    ImGuiSortDirection          SortDirection : 8;  \/\/ ImGuiSortDirection_Ascending or ImGuiSortDirection_Descending (you can use this or SortSign, whichever is more convenient for your sort function)$/;"	m	struct:ImGuiTableColumnSortSpecs
SortDirection	imgui_internal.h	/^    ImU8                    SortDirection : 2;              \/\/ ImGuiSortDirection_Ascending or ImGuiSortDirection_Descending$/;"	m	struct:ImGuiTableColumn
SortDirection	imgui_internal.h	/^    ImU8                    SortDirection : 2;$/;"	m	struct:ImGuiTableColumnSettings
SortDirectionsAvailCount	imgui_internal.h	/^    ImU8                    SortDirectionsAvailCount : 2;   \/\/ Number of available sort directions (0 to 3)$/;"	m	struct:ImGuiTableColumn
SortDirectionsAvailList	imgui_internal.h	/^    ImU8                    SortDirectionsAvailList;        \/\/ Ordered of available sort directions (2-bits each)$/;"	m	struct:ImGuiTableColumn
SortDirectionsAvailMask	imgui_internal.h	/^    ImU8                    SortDirectionsAvailMask : 4;    \/\/ Mask of available sort directions (1-bit each)$/;"	m	struct:ImGuiTableColumn
SortOrder	imgui.h	/^    ImS16                       SortOrder;          \/\/ Index within parent ImGuiTableSortSpecs (always stored in order starting from 0, tables sorted on a single criteria will always have a 0 here)$/;"	m	struct:ImGuiTableColumnSortSpecs
SortOrder	imgui_internal.h	/^    ImGuiTableColumnIdx     SortOrder;                      \/\/ Index of this column within sort specs, -1 if not sorting on this column, 0 for single-sort, may be >0 on multi-sort$/;"	m	struct:ImGuiTableColumn
SortOrder	imgui_internal.h	/^    ImGuiTableColumnIdx     SortOrder;$/;"	m	struct:ImGuiTableColumnSettings
SortSpecs	imgui_internal.h	/^    ImGuiTableSortSpecs         SortSpecs;                  \/\/ Public facing sorts specs, this is what we return in TableGetSortSpecs()$/;"	m	struct:ImGuiTable
SortSpecsCount	imgui_internal.h	/^    ImGuiTableColumnIdx         SortSpecsCount;$/;"	m	struct:ImGuiTable
SortSpecsMulti	imgui_internal.h	/^    ImVector<ImGuiTableColumnSortSpecs> SortSpecsMulti;     \/\/ FIXME-OPT: Using a small-vector pattern would work be good.$/;"	m	struct:ImGuiTable
SortSpecsSingle	imgui_internal.h	/^    ImGuiTableColumnSortSpecs   SortSpecsSingle;$/;"	m	struct:ImGuiTable
SourceId	imgui.h	/^    ImGuiID         SourceId;           \/\/ Source item id$/;"	m	struct:ImGuiPayload
SourceParentId	imgui.h	/^    ImGuiID         SourceParentId;     \/\/ Source parent id (if available)$/;"	m	struct:ImGuiPayload
SourceWindow	imgui_internal.h	/^    ImGuiWindow*        SourceWindow;   \/\/ Set on OpenPopup() copy of NavWindow at the time of opening the popup$/;"	m	struct:ImGuiPopupData
Spacing	imgui_internal.h	/^    float       Spacing;$/;"	m	struct:ImGuiMenuColumns
Spacing	imgui_widgets.cpp	/^    float               Spacing;                \/\/ Horizontal spacing at the end of the section.$/;"	m	struct:ImGuiTabBarSection	file:
Spacing	imgui_widgets.cpp	/^void ImGui::Spacing()$/;"	f	class:ImGui
Specs	imgui.h	/^    const ImGuiTableColumnSortSpecs* Specs;     \/\/ Pointer to sort spec array.$/;"	m	struct:ImGuiTableSortSpecs
SpecsCount	imgui.h	/^    int                         SpecsCount;     \/\/ Sort spec count. Most often 1. May be > 1 when ImGuiTableFlags_SortMulti is enabled. May be == 0 when ImGuiTableFlags_SortTristate is enabled.$/;"	m	struct:ImGuiTableSortSpecs
SpecsDirty	imgui.h	/^    bool                        SpecsDirty;     \/\/ Set to true when specs have changed since last time! Use this to sort again, then clear the flag.$/;"	m	struct:ImGuiTableSortSpecs
Split	imgui_draw.cpp	/^void ImDrawListSplitter::Split(ImDrawList* draw_list, int channels_count)$/;"	f	class:ImDrawListSplitter
Splitter	imgui_internal.h	/^    ImDrawListSplitter  Splitter;$/;"	m	struct:ImGuiOldColumns
SplitterBehavior	imgui_widgets.cpp	/^bool ImGui::SplitterBehavior(const ImRect& bb, ImGuiID id, ImGuiAxis axis, float* size1, float* size2, float min_size1, float min_size2, float hover_extend, float hover_visibility_delay)$/;"	f	class:ImGui
SrcCount	imgui_draw.cpp	/^    int                 SrcCount;           \/\/ Number of source fonts targeting this destination font.$/;"	m	struct:ImFontBuildDstData	file:
SrcRanges	imgui_draw.cpp	/^    const ImWchar*      SrcRanges;          \/\/ Ranges as requested by user (user is allowed to request too much, e.g. 0x0020..0xFFFF)$/;"	m	struct:ImFontBuildSrcData	file:
StackSizesOnBegin	imgui_internal.h	/^    ImGuiStackSizes         StackSizesOnBegin;      \/\/ Store size of various stacks for asserting$/;"	m	struct:ImGuiWindowTempData
StartLockWheelingWindow	imgui.cpp	/^static void StartLockWheelingWindow(ImGuiWindow* window)$/;"	f	file:
StartMouseMovingWindow	imgui.cpp	/^void ImGui::StartMouseMovingWindow(ImGuiWindow* window)$/;"	f	class:ImGui
StartPosY	imgui.h	/^    float   StartPosY;$/;"	m	struct:ImGuiListClipper
StateStorage	imgui_internal.h	/^    ImGuiStorage            StateStorage;$/;"	m	struct:ImGuiWindow
StateStorage	imgui_internal.h	/^    ImGuiStorage*           StateStorage;           \/\/ Current persistent per-window storage (store e.g. tree node open\/close state)$/;"	m	struct:ImGuiWindowTempData
Stb	imgui_internal.h	/^    ImStb::STB_TexteditState Stb;                   \/\/ state for stb_textedit.h$/;"	m	struct:ImGuiInputTextState
StbFindState	imstb_textedit.h	/^} StbFindState;$/;"	t	typeref:struct:__anon6
StbTexteditRow	imstb_textedit.h	/^} StbTexteditRow;$/;"	t	typeref:struct:__anon5
StbUndoRecord	imstb_textedit.h	/^} StbUndoRecord;$/;"	t	typeref:struct:__anon2
StbUndoState	imstb_textedit.h	/^} StbUndoState;$/;"	t	typeref:struct:__anon3
Step	imgui.cpp	/^bool ImGuiListClipper::Step()$/;"	f	class:ImGuiListClipper
StepNo	imgui.h	/^    int     StepNo;$/;"	m	struct:ImGuiListClipper
Storage	imgui_internal.h	/^    ImU32           Storage[(BITCOUNT + 31) >> 5];$/;"	m	struct:ImBitArray
Storage	imgui_internal.h	/^    ImVector<ImU32> Storage;$/;"	m	struct:ImBitVector
Strdup	imgui_demo.cpp	/^    static char* Strdup(const char* s)                           { IM_ASSERT(s); size_t len = strlen(s) + 1; void* buf = malloc(len); IM_ASSERT(buf); return (char*)memcpy(buf, (const void*)s, len); }$/;"	f	struct:ExampleAppConsole
StretchWeight	imgui_internal.h	/^    float                   StretchWeight;                  \/\/ Master width weight when (Flags & _WidthStretch). Often around ~1.0f initially.$/;"	m	struct:ImGuiTableColumn
Stricmp	imgui_demo.cpp	/^    static int   Stricmp(const char* s1, const char* s2)         { int d; while ((d = toupper(*s2) - toupper(*s1)) == 0 && *s1) { s1++; s2++; } return d; }$/;"	f	struct:ExampleAppConsole
Stride	imgui_widgets.cpp	/^    int Stride;$/;"	m	struct:ImGuiPlotArrayGetterData	file:
Strnicmp	imgui_demo.cpp	/^    static int   Strnicmp(const char* s1, const char* s2, int n) { int d = 0; while (n > 0 && (d = toupper(*s2) - toupper(*s1)) == 0 && *s1) { s1++; s2++; n--; } return d; }$/;"	f	struct:ExampleAppConsole
Strtrim	imgui_demo.cpp	/^    static void  Strtrim(char* s)                                { char* str_end = s + strlen(s); while (str_end > s && str_end[-1] == ' ') str_end--; *str_end = 0; }$/;"	f	struct:ExampleAppConsole
Style	imgui_internal.h	/^    ImGuiStyle              Style;$/;"	m	struct:ImGuiContext
StyleColorsClassic	imgui_draw.cpp	/^void ImGui::StyleColorsClassic(ImGuiStyle* dst)$/;"	f	class:ImGui
StyleColorsDark	imgui_draw.cpp	/^void ImGui::StyleColorsDark(ImGuiStyle* dst)$/;"	f	class:ImGui
StyleColorsLight	imgui_draw.cpp	/^void ImGui::StyleColorsLight(ImGuiStyle* dst)$/;"	f	class:ImGui
StyleVarStack	imgui_internal.h	/^    ImVector<ImGuiStyleMod> StyleVarStack;                      \/\/ Stack for PushStyleVar()\/PopStyleVar() - inherited by Begin()$/;"	m	struct:ImGuiContext
TABLE_BORDER_SIZE	imgui_tables.cpp	/^static const float TABLE_BORDER_SIZE                     = 1.0f;    \/\/ FIXME-TABLE: Currently hard-coded because of clipping assumptions with outer borders rendering.$/;"	v	file:
TABLE_DRAW_CHANNEL_BG0	imgui_tables.cpp	/^static const int TABLE_DRAW_CHANNEL_BG0 = 0;$/;"	v	file:
TABLE_DRAW_CHANNEL_BG2_FROZEN	imgui_tables.cpp	/^static const int TABLE_DRAW_CHANNEL_BG2_FROZEN = 1;$/;"	v	file:
TABLE_DRAW_CHANNEL_NOCLIP	imgui_tables.cpp	/^static const int TABLE_DRAW_CHANNEL_NOCLIP = 2;                     \/\/ When using ImGuiTableFlags_NoClip (this becomes the last visible channel)$/;"	v	file:
TABLE_RESIZE_SEPARATOR_FEEDBACK_TIMER	imgui_tables.cpp	/^static const float TABLE_RESIZE_SEPARATOR_FEEDBACK_TIMER = 0.06f;   \/\/ Delay\/timer before making the hover feedback (color+cursor) visible because tables\/columns tends to be more cramped.$/;"	v	file:
TABLE_RESIZE_SEPARATOR_HALF_THICKNESS	imgui_tables.cpp	/^static const float TABLE_RESIZE_SEPARATOR_HALF_THICKNESS = 4.0f;    \/\/ Extend outside inner borders.$/;"	v	file:
TabBarCalcMaxTabWidth	imgui_widgets.cpp	/^static float ImGui::TabBarCalcMaxTabWidth()$/;"	f	class:ImGui
TabBarCalcTabID	imgui_widgets.cpp	/^static ImU32   ImGui::TabBarCalcTabID(ImGuiTabBar* tab_bar, const char* label)$/;"	f	class:ImGui
TabBarCloseTab	imgui_widgets.cpp	/^void ImGui::TabBarCloseTab(ImGuiTabBar* tab_bar, ImGuiTabItem* tab)$/;"	f	class:ImGui
TabBarFindTabByID	imgui_widgets.cpp	/^ImGuiTabItem* ImGui::TabBarFindTabByID(ImGuiTabBar* tab_bar, ImGuiID tab_id)$/;"	f	class:ImGui
TabBarLayout	imgui_widgets.cpp	/^static void ImGui::TabBarLayout(ImGuiTabBar* tab_bar)$/;"	f	class:ImGui
TabBarProcessReorder	imgui_widgets.cpp	/^bool ImGui::TabBarProcessReorder(ImGuiTabBar* tab_bar)$/;"	f	class:ImGui
TabBarQueueReorder	imgui_widgets.cpp	/^void ImGui::TabBarQueueReorder(ImGuiTabBar* tab_bar, const ImGuiTabItem* tab, int offset)$/;"	f	class:ImGui
TabBarQueueReorderFromMousePos	imgui_widgets.cpp	/^void ImGui::TabBarQueueReorderFromMousePos(ImGuiTabBar* tab_bar, const ImGuiTabItem* src_tab, ImVec2 mouse_pos)$/;"	f	class:ImGui
TabBarRemoveTab	imgui_widgets.cpp	/^void ImGui::TabBarRemoveTab(ImGuiTabBar* tab_bar, ImGuiID tab_id)$/;"	f	class:ImGui
TabBarScrollClamp	imgui_widgets.cpp	/^static float ImGui::TabBarScrollClamp(ImGuiTabBar* tab_bar, float scrolling)$/;"	f	class:ImGui
TabBarScrollToTab	imgui_widgets.cpp	/^static void ImGui::TabBarScrollToTab(ImGuiTabBar* tab_bar, ImGuiID tab_id, ImGuiTabBarSection* sections)$/;"	f	class:ImGui
TabBarScrollingButtons	imgui_widgets.cpp	/^static ImGuiTabItem* ImGui::TabBarScrollingButtons(ImGuiTabBar* tab_bar)$/;"	f	class:ImGui
TabBarTabListPopupButton	imgui_widgets.cpp	/^static ImGuiTabItem* ImGui::TabBarTabListPopupButton(ImGuiTabBar* tab_bar)$/;"	f	class:ImGui
TabBars	imgui_internal.h	/^    ImPool<ImGuiTabBar>             TabBars;$/;"	m	struct:ImGuiContext
TabBorderSize	imgui.h	/^    float       TabBorderSize;              \/\/ Thickness of border around tabs.$/;"	m	struct:ImGuiStyle
TabCount	imgui_widgets.cpp	/^    int                 TabCount;               \/\/ Number of tabs in this section.$/;"	m	struct:ImGuiTabBarSection	file:
TabFocusPressed	imgui_internal.h	/^    bool                    TabFocusPressed;                    \/\/$/;"	m	struct:ImGuiContext
TabFocusRequestCurrCounterRegular	imgui_internal.h	/^    int                     TabFocusRequestCurrCounterRegular;  \/\/ Any item being requested for focus, stored as an index (we on layout to be stable between the frame pressing TAB and the next frame, semi-ouch)$/;"	m	struct:ImGuiContext
TabFocusRequestCurrCounterTabStop	imgui_internal.h	/^    int                     TabFocusRequestCurrCounterTabStop;  \/\/ Tab item being requested for focus, stored as an index$/;"	m	struct:ImGuiContext
TabFocusRequestCurrWindow	imgui_internal.h	/^    ImGuiWindow*            TabFocusRequestCurrWindow;          \/\/$/;"	m	struct:ImGuiContext
TabFocusRequestNextCounterRegular	imgui_internal.h	/^    int                     TabFocusRequestNextCounterRegular;  \/\/ Stored for next frame$/;"	m	struct:ImGuiContext
TabFocusRequestNextCounterTabStop	imgui_internal.h	/^    int                     TabFocusRequestNextCounterTabStop;  \/\/ "$/;"	m	struct:ImGuiContext
TabFocusRequestNextWindow	imgui_internal.h	/^    ImGuiWindow*            TabFocusRequestNextWindow;          \/\/$/;"	m	struct:ImGuiContext
TabItemBackground	imgui_widgets.cpp	/^void ImGui::TabItemBackground(ImDrawList* draw_list, const ImRect& bb, ImGuiTabItemFlags flags, ImU32 col)$/;"	f	class:ImGui
TabItemButton	imgui_widgets.cpp	/^bool    ImGui::TabItemButton(const char* label, ImGuiTabItemFlags flags)$/;"	f	class:ImGui
TabItemCalcSize	imgui_widgets.cpp	/^ImVec2 ImGui::TabItemCalcSize(const char* label, bool has_close_button)$/;"	f	class:ImGui
TabItemComparerByBeginOrder	imgui_widgets.cpp	/^static int IMGUI_CDECL TabItemComparerByBeginOrder(const void* lhs, const void* rhs)$/;"	f	file:
TabItemComparerBySection	imgui_widgets.cpp	/^static int IMGUI_CDECL TabItemComparerBySection(const void* lhs, const void* rhs)$/;"	f	file:
TabItemEx	imgui_widgets.cpp	/^bool    ImGui::TabItemEx(ImGuiTabBar* tab_bar, const char* label, bool* p_open, ImGuiTabItemFlags flags)$/;"	f	class:ImGui
TabItemGetSectionIdx	imgui_widgets.cpp	/^static inline int TabItemGetSectionIdx(const ImGuiTabItem* tab)$/;"	f	file:
TabItemLabelAndCloseButton	imgui_widgets.cpp	/^void ImGui::TabItemLabelAndCloseButton(ImDrawList* draw_list, const ImRect& bb, ImGuiTabItemFlags flags, ImVec2 frame_padding, const char* label, ImGuiID tab_id, ImGuiID close_button_id, bool is_contents_visible, bool* out_just_closed, bool* out_text_clipped)$/;"	f	class:ImGui
TabMinWidthForCloseButton	imgui.h	/^    float       TabMinWidthForCloseButton;  \/\/ Minimum width for close button to appears on an unselected tab when hovered. Set to 0.0f to always show when hovering, set to FLT_MAX to never show close button unless selected.$/;"	m	struct:ImGuiStyle
TabRounding	imgui.h	/^    float       TabRounding;                \/\/ Radius of upper corners of a tab. Set to 0.0f to have rectangular tabs.$/;"	m	struct:ImGuiStyle
TableBeginApplyRequests	imgui_tables.cpp	/^void ImGui::TableBeginApplyRequests(ImGuiTable* table)$/;"	f	class:ImGui
TableBeginCell	imgui_tables.cpp	/^void ImGui::TableBeginCell(ImGuiTable* table, int column_n)$/;"	f	class:ImGui
TableBeginInitMemory	imgui_tables.cpp	/^void ImGui::TableBeginInitMemory(ImGuiTable* table, int columns_count)$/;"	f	class:ImGui
TableBeginRow	imgui_tables.cpp	/^void ImGui::TableBeginRow(ImGuiTable* table)$/;"	f	class:ImGui
TableDrawBorders	imgui_tables.cpp	/^void ImGui::TableDrawBorders(ImGuiTable* table)$/;"	f	class:ImGui
TableDrawContextMenu	imgui_tables.cpp	/^void ImGui::TableDrawContextMenu(ImGuiTable* table)$/;"	f	class:ImGui
TableEndCell	imgui_tables.cpp	/^void ImGui::TableEndCell(ImGuiTable* table)$/;"	f	class:ImGui
TableEndRow	imgui_tables.cpp	/^void ImGui::TableEndRow(ImGuiTable* table)$/;"	f	class:ImGui
TableFindByID	imgui_tables.cpp	/^ImGuiTable* ImGui::TableFindByID(ImGuiID id)$/;"	f	class:ImGui
TableFixColumnSortDirection	imgui_tables.cpp	/^void ImGui::TableFixColumnSortDirection(ImGuiTable* table, ImGuiTableColumn* column)$/;"	f	class:ImGui
TableFixFlags	imgui_tables.cpp	/^inline ImGuiTableFlags TableFixFlags(ImGuiTableFlags flags, ImGuiWindow* outer_window)$/;"	f
TableGcCompactSettings	imgui_tables.cpp	/^void ImGui::TableGcCompactSettings()$/;"	f	class:ImGui
TableGcCompactTransientBuffers	imgui_tables.cpp	/^void ImGui::TableGcCompactTransientBuffers(ImGuiTable* table)$/;"	f	class:ImGui
TableGetBoundSettings	imgui_tables.cpp	/^ImGuiTableSettings* ImGui::TableGetBoundSettings(ImGuiTable* table)$/;"	f	class:ImGui
TableGetCellBgRect	imgui_tables.cpp	/^ImRect ImGui::TableGetCellBgRect(const ImGuiTable* table, int column_n)$/;"	f	class:ImGui
TableGetColumnAvailSortDirection	imgui_tables.cpp	/^static inline ImGuiSortDirection TableGetColumnAvailSortDirection(ImGuiTableColumn* column, int n)$/;"	f	file:
TableGetColumnCount	imgui_tables.cpp	/^int ImGui::TableGetColumnCount()$/;"	f	class:ImGui
TableGetColumnFlags	imgui_tables.cpp	/^ImGuiTableColumnFlags ImGui::TableGetColumnFlags(int column_n)$/;"	f	class:ImGui
TableGetColumnIndex	imgui_tables.cpp	/^int ImGui::TableGetColumnIndex()$/;"	f	class:ImGui
TableGetColumnName	imgui_tables.cpp	/^const char* ImGui::TableGetColumnName(const ImGuiTable* table, int column_n)$/;"	f	class:ImGui
TableGetColumnName	imgui_tables.cpp	/^const char* ImGui::TableGetColumnName(int column_n)$/;"	f	class:ImGui
TableGetColumnNextSortDirection	imgui_tables.cpp	/^ImGuiSortDirection ImGui::TableGetColumnNextSortDirection(ImGuiTableColumn* column)$/;"	f	class:ImGui
TableGetColumnResizeID	imgui_tables.cpp	/^ImGuiID ImGui::TableGetColumnResizeID(const ImGuiTable* table, int column_n, int instance_no)$/;"	f	class:ImGui
TableGetColumnWidthAuto	imgui_tables.cpp	/^float ImGui::TableGetColumnWidthAuto(ImGuiTable* table, ImGuiTableColumn* column)$/;"	f	class:ImGui
TableGetHeaderRowHeight	imgui_tables.cpp	/^float ImGui::TableGetHeaderRowHeight()$/;"	f	class:ImGui
TableGetHoveredColumn	imgui_tables.cpp	/^int ImGui::TableGetHoveredColumn()$/;"	f	class:ImGui
TableGetMaxColumnWidth	imgui_tables.cpp	/^float ImGui::TableGetMaxColumnWidth(const ImGuiTable* table, int column_n)$/;"	f	class:ImGui
TableGetRowIndex	imgui_tables.cpp	/^int ImGui::TableGetRowIndex()$/;"	f	class:ImGui
TableGetSortSpecs	imgui_tables.cpp	/^ImGuiTableSortSpecs* ImGui::TableGetSortSpecs()$/;"	f	class:ImGui
TableHeader	imgui_tables.cpp	/^void ImGui::TableHeader(const char* label)$/;"	f	class:ImGui
TableHeadersRow	imgui_tables.cpp	/^void ImGui::TableHeadersRow()$/;"	f	class:ImGui
TableLoadSettings	imgui_tables.cpp	/^void ImGui::TableLoadSettings(ImGuiTable* table)$/;"	f	class:ImGui
TableMergeDrawChannels	imgui_tables.cpp	/^void ImGui::TableMergeDrawChannels(ImGuiTable* table)$/;"	f	class:ImGui
TableNextColumn	imgui_tables.cpp	/^bool ImGui::TableNextColumn()$/;"	f	class:ImGui
TableNextRow	imgui_tables.cpp	/^void ImGui::TableNextRow(ImGuiTableRowFlags row_flags, float row_min_height)$/;"	f	class:ImGui
TableOpenContextMenu	imgui_tables.cpp	/^void ImGui::TableOpenContextMenu(int column_n)$/;"	f	class:ImGui
TablePopBackgroundChannel	imgui_tables.cpp	/^void ImGui::TablePopBackgroundChannel()$/;"	f	class:ImGui
TablePushBackgroundChannel	imgui_tables.cpp	/^void ImGui::TablePushBackgroundChannel()$/;"	f	class:ImGui
TableRemove	imgui_tables.cpp	/^void ImGui::TableRemove(ImGuiTable* table)$/;"	f	class:ImGui
TableResetSettings	imgui_tables.cpp	/^void ImGui::TableResetSettings(ImGuiTable* table)$/;"	f	class:ImGui
TableSaveSettings	imgui_tables.cpp	/^void ImGui::TableSaveSettings(ImGuiTable* table)$/;"	f	class:ImGui
TableSetBgColor	imgui_tables.cpp	/^void ImGui::TableSetBgColor(ImGuiTableBgTarget target, ImU32 color, int column_n)$/;"	f	class:ImGui
TableSetColumnEnabled	imgui_tables.cpp	/^void ImGui::TableSetColumnEnabled(int column_n, bool enabled)$/;"	f	class:ImGui
TableSetColumnIndex	imgui_tables.cpp	/^bool ImGui::TableSetColumnIndex(int column_n)$/;"	f	class:ImGui
TableSetColumnSortDirection	imgui_tables.cpp	/^void ImGui::TableSetColumnSortDirection(int column_n, ImGuiSortDirection sort_direction, bool append_to_sort_specs)$/;"	f	class:ImGui
TableSetColumnWidth	imgui_tables.cpp	/^void ImGui::TableSetColumnWidth(int column_n, float width)$/;"	f	class:ImGui
TableSetColumnWidthAutoAll	imgui_tables.cpp	/^void ImGui::TableSetColumnWidthAutoAll(ImGuiTable* table)$/;"	f	class:ImGui
TableSetColumnWidthAutoSingle	imgui_tables.cpp	/^void ImGui::TableSetColumnWidthAutoSingle(ImGuiTable* table, int column_n)$/;"	f	class:ImGui
TableSettingsCalcChunkSize	imgui_tables.cpp	/^static size_t TableSettingsCalcChunkSize(int columns_count)$/;"	f	file:
TableSettingsCreate	imgui_tables.cpp	/^ImGuiTableSettings* ImGui::TableSettingsCreate(ImGuiID id, int columns_count)$/;"	f	class:ImGui
TableSettingsFindByID	imgui_tables.cpp	/^ImGuiTableSettings* ImGui::TableSettingsFindByID(ImGuiID id)$/;"	f	class:ImGui
TableSettingsHandler_ApplyAll	imgui_tables.cpp	/^static void TableSettingsHandler_ApplyAll(ImGuiContext* ctx, ImGuiSettingsHandler*)$/;"	f	file:
TableSettingsHandler_ClearAll	imgui_tables.cpp	/^static void TableSettingsHandler_ClearAll(ImGuiContext* ctx, ImGuiSettingsHandler*)$/;"	f	file:
TableSettingsHandler_ReadLine	imgui_tables.cpp	/^static void TableSettingsHandler_ReadLine(ImGuiContext*, ImGuiSettingsHandler*, void* entry, const char* line)$/;"	f	file:
TableSettingsHandler_ReadOpen	imgui_tables.cpp	/^static void* TableSettingsHandler_ReadOpen(ImGuiContext*, ImGuiSettingsHandler*, const char* name)$/;"	f	file:
TableSettingsHandler_WriteAll	imgui_tables.cpp	/^static void TableSettingsHandler_WriteAll(ImGuiContext* ctx, ImGuiSettingsHandler* handler, ImGuiTextBuffer* buf)$/;"	f	file:
TableSettingsInit	imgui_tables.cpp	/^static void TableSettingsInit(ImGuiTableSettings* settings, ImGuiID id, int columns_count, int columns_count_max)$/;"	f	file:
TableSettingsInstallHandler	imgui_tables.cpp	/^void ImGui::TableSettingsInstallHandler(ImGuiContext* context)$/;"	f	class:ImGui
TableSetupColumn	imgui_tables.cpp	/^void ImGui::TableSetupColumn(const char* label, ImGuiTableColumnFlags flags, float init_width_or_weight, ImGuiID user_id)$/;"	f	class:ImGui
TableSetupColumnFlags	imgui_tables.cpp	/^static void TableSetupColumnFlags(ImGuiTable* table, ImGuiTableColumn* column, ImGuiTableColumnFlags flags_in)$/;"	f	file:
TableSetupDrawChannels	imgui_tables.cpp	/^void ImGui::TableSetupDrawChannels(ImGuiTable* table)$/;"	f	class:ImGui
TableSetupScrollFreeze	imgui_tables.cpp	/^void ImGui::TableSetupScrollFreeze(int columns, int rows)$/;"	f	class:ImGui
TableSortSpecsBuild	imgui_tables.cpp	/^void ImGui::TableSortSpecsBuild(ImGuiTable* table)$/;"	f	class:ImGui
TableSortSpecsSanitize	imgui_tables.cpp	/^void ImGui::TableSortSpecsSanitize(ImGuiTable* table)$/;"	f	class:ImGui
TableUpdateBorders	imgui_tables.cpp	/^void ImGui::TableUpdateBorders(ImGuiTable* table)$/;"	f	class:ImGui
TableUpdateColumnsWeightFromWidth	imgui_tables.cpp	/^void ImGui::TableUpdateColumnsWeightFromWidth(ImGuiTable* table)$/;"	f	class:ImGui
TableUpdateLayout	imgui_tables.cpp	/^void ImGui::TableUpdateLayout(ImGuiTable* table)$/;"	f	class:ImGui
Tables	imgui_internal.h	/^    ImPool<ImGuiTable>              Tables;$/;"	m	struct:ImGuiContext
TablesLastTimeActive	imgui_internal.h	/^    ImVector<float>                 TablesLastTimeActive;       \/\/ Last used timestamp of each tables (SOA, for efficient GC)$/;"	m	struct:ImGuiContext
Tabs	imgui_internal.h	/^    ImVector<ImGuiTabItem> Tabs;$/;"	m	struct:ImGuiTabBar
TabsActiveCount	imgui_internal.h	/^    ImS16               TabsActiveCount;        \/\/ Number of tabs submitted this frame.$/;"	m	struct:ImGuiTabBar
TabsAddedNew	imgui_internal.h	/^    bool                TabsAddedNew;           \/\/ Set to true when a new tab item or button has been added to the tab bar during last frame$/;"	m	struct:ImGuiTabBar
TabsNames	imgui_internal.h	/^    ImGuiTextBuffer     TabsNames;              \/\/ For non-docking tab bar we re-append names in a contiguous buffer.$/;"	m	struct:ImGuiTabBar
TempBuffer	imgui_internal.h	/^    char                    TempBuffer[1024 * 3 + 1];           \/\/ Temporary text buffer$/;"	m	struct:ImGuiContext
TempInputId	imgui_internal.h	/^    ImGuiID                 TempInputId;                        \/\/ Temporary text input when CTRL+clicking on a slider, etc.$/;"	m	struct:ImGuiContext
TempInputIsActive	imgui_internal.h	/^    inline bool             TempInputIsActive(ImGuiID id)       { ImGuiContext& g = *GImGui; return (g.ActiveId == id && g.TempInputId == id); }$/;"	f	namespace:ImGui
TempInputScalar	imgui_widgets.cpp	/^bool ImGui::TempInputScalar(const ImRect& bb, ImGuiID id, const char* label, ImGuiDataType data_type, void* p_data, const char* format, const void* p_clamp_min, const void* p_clamp_max)$/;"	f	class:ImGui
TempInputText	imgui_widgets.cpp	/^bool ImGui::TempInputText(const ImRect& bb, ImGuiID id, const char* label, char* buf, int buf_size, ImGuiInputTextFlags flags)$/;"	f	class:ImGui
TestBit	imgui_internal.h	/^    bool            TestBit(int n) const        { IM_ASSERT(n < (Storage.Size << 5)); return ImBitArrayTestBit(Storage.Data, n); }$/;"	f	struct:ImBitVector
TestBit	imgui_internal.h	/^    bool            TestBit(int n) const        { IM_ASSERT(n < BITCOUNT); return ImBitArrayTestBit(Storage, n); }$/;"	f	struct:ImBitArray
TestEngine	imgui_internal.h	/^    void*                   TestEngine;                         \/\/ Test engine user data$/;"	m	struct:ImGuiContext
TestEngineHookIdInfo	imgui_internal.h	/^    ImGuiID                 TestEngineHookIdInfo;               \/\/ Will call test engine hooks: ImGuiTestEngineHook_IdInfo() from GetID()$/;"	m	struct:ImGuiContext
TestEngineHookItems	imgui_internal.h	/^    bool                    TestEngineHookItems;                \/\/ Will call test engine hooks: ImGuiTestEngineHook_ItemAdd(), ImGuiTestEngineHook_ItemInfo(), ImGuiTestEngineHook_Log()$/;"	m	struct:ImGuiContext
TexDesiredWidth	imgui.h	/^    int                         TexDesiredWidth;    \/\/ Texture width desired by user before Build(). Must be a power-of-two. If have many glyphs your graphics API have texture size restrictions you may want to increase texture width to decrease height.$/;"	m	struct:ImFontAtlas
TexGlyphPadding	imgui.h	/^    int                         TexGlyphPadding;    \/\/ Padding between glyphs within texture in pixels. Defaults to 1. If your rendering method doesn't rely on bilinear filtering you may set this to 0.$/;"	m	struct:ImFontAtlas
TexHeight	imgui.h	/^    int                         TexHeight;          \/\/ Texture height calculated during Build().$/;"	m	struct:ImFontAtlas
TexID	imgui.h	/^    ImTextureID                 TexID;              \/\/ User data to refer to the texture once it has been uploaded to user's graphic systems. It is passed back to you during rendering via the ImDrawCmd structure.$/;"	m	struct:ImFontAtlas
TexPixelsAlpha8	imgui.h	/^    unsigned char*              TexPixelsAlpha8;    \/\/ 1 component per pixel, each component is unsigned 8-bit. Total size = TexWidth * TexHeight$/;"	m	struct:ImFontAtlas
TexPixelsRGBA32	imgui.h	/^    unsigned int*               TexPixelsRGBA32;    \/\/ 4 component per pixel, each component is unsigned 8-bit. Total size = TexWidth * TexHeight * 4$/;"	m	struct:ImFontAtlas
TexPixelsUseColors	imgui.h	/^    bool                        TexPixelsUseColors; \/\/ Tell whether our texture data is known to use colors (rather than just alpha channel), in order to help backend select a format.$/;"	m	struct:ImFontAtlas
TexUvLines	imgui.h	/^    ImVec4                      TexUvLines[IM_DRAWLIST_TEX_LINES_WIDTH_MAX + 1];  \/\/ UVs for baked anti-aliased lines$/;"	m	struct:ImFontAtlas
TexUvLines	imgui_internal.h	/^    const ImVec4*   TexUvLines;                 \/\/ UV of anti-aliased lines in the atlas$/;"	m	struct:ImDrawListSharedData
TexUvScale	imgui.h	/^    ImVec2                      TexUvScale;         \/\/ = (1.0f\/TexWidth, 1.0f\/TexHeight)$/;"	m	struct:ImFontAtlas
TexUvWhitePixel	imgui.h	/^    ImVec2                      TexUvWhitePixel;    \/\/ Texture coordinates to a white pixel$/;"	m	struct:ImFontAtlas
TexUvWhitePixel	imgui_internal.h	/^    ImVec2          TexUvWhitePixel;            \/\/ UV of white pixel in the atlas$/;"	m	struct:ImDrawListSharedData
TexWidth	imgui.h	/^    int                         TexWidth;           \/\/ Texture width calculated during Build().$/;"	m	struct:ImFontAtlas
Text	imgui_widgets.cpp	/^void ImGui::Text(const char* fmt, ...)$/;"	f	class:ImGui
TextA	imgui_internal.h	/^    ImVector<char>          TextA;                  \/\/ temporary UTF8 buffer for callbacks and other operations. this is not updated in every code-path! size=capacity.$/;"	m	struct:ImGuiInputTextState
TextAIsValid	imgui_internal.h	/^    bool                    TextAIsValid;           \/\/ temporary UTF8 buffer is not initially valid before we make the widget active (until then we pull the data from user argument)$/;"	m	struct:ImGuiInputTextState
TextColored	imgui_widgets.cpp	/^void ImGui::TextColored(const ImVec4& col, const char* fmt, ...)$/;"	f	class:ImGui
TextColoredV	imgui_widgets.cpp	/^void ImGui::TextColoredV(const ImVec4& col, const char* fmt, va_list args)$/;"	f	class:ImGui
TextDisabled	imgui_widgets.cpp	/^void ImGui::TextDisabled(const char* fmt, ...)$/;"	f	class:ImGui
TextDisabledV	imgui_widgets.cpp	/^void ImGui::TextDisabledV(const char* fmt, va_list args)$/;"	f	class:ImGui
TextEditCallback	imgui_demo.cpp	/^    int     TextEditCallback(ImGuiInputTextCallbackData* data)$/;"	f	struct:ExampleAppConsole
TextEditCallbackStub	imgui_demo.cpp	/^    static int TextEditCallbackStub(ImGuiInputTextCallbackData* data)$/;"	f	struct:ExampleAppConsole
TextEx	imgui_widgets.cpp	/^void ImGui::TextEx(const char* text, const char* text_end, ImGuiTextFlags flags)$/;"	f	class:ImGui
TextUnformatted	imgui_widgets.cpp	/^void ImGui::TextUnformatted(const char* text, const char* text_end)$/;"	f	class:ImGui
TextV	imgui_widgets.cpp	/^void ImGui::TextV(const char* fmt, va_list args)$/;"	f	class:ImGui
TextW	imgui_internal.h	/^    ImVector<ImWchar>       TextW;                  \/\/ edit buffer, we need to persist but can't guarantee the persistence of the user-provided buffer. so we copy into own buffer.$/;"	m	struct:ImGuiInputTextState
TextWrapPos	imgui_internal.h	/^    float                   TextWrapPos;            \/\/ Current text wrap pos.$/;"	m	struct:ImGuiWindowTempData
TextWrapPosStack	imgui_internal.h	/^    ImVector<float>         TextWrapPosStack;       \/\/ Store text wrap pos to restore (attention: .back() is not == TextWrapPos)$/;"	m	struct:ImGuiWindowTempData
TextWrapped	imgui_widgets.cpp	/^void ImGui::TextWrapped(const char* fmt, ...)$/;"	f	class:ImGui
TextWrappedV	imgui_widgets.cpp	/^void ImGui::TextWrappedV(const char* fmt, va_list args)$/;"	f	class:ImGui
TextureId	imgui.h	/^    ImTextureID     TextureId;          \/\/ 4-8  \/\/ User-provided texture ID. Set by user in ImfontAtlas::SetTexID() for fonts or passed to Image*() functions. Ignore if never using images or multiple fonts atlas.$/;"	m	struct:ImDrawCmd
TextureId	imgui.h	/^    ImTextureID     TextureId;$/;"	m	struct:ImDrawCmdHeader
Time	imgui_internal.h	/^    double                  Time;$/;"	m	struct:ImGuiContext
TitleBarHeight	imgui_internal.h	/^    float       TitleBarHeight() const  { ImGuiContext& g = *GImGui; return (Flags & ImGuiWindowFlags_NoTitleBar) ? 0.0f : CalcFontSize() + g.Style.FramePadding.y * 2.0f; }$/;"	f	struct:ImGuiWindow
TitleBarRect	imgui_internal.h	/^    ImRect      TitleBarRect() const    { return ImRect(Pos, ImVec2(Pos.x + SizeFull.x, Pos.y + TitleBarHeight())); }$/;"	f	struct:ImGuiWindow
ToVec4	imgui_internal.h	/^    ImVec4      ToVec4() const                      { return ImVec4(Min.x, Min.y, Max.x, Max.y); }$/;"	f	struct:ImRect
TooltipOverrideCount	imgui_internal.h	/^    int                     TooltipOverrideCount;$/;"	m	struct:ImGuiContext
TooltipSlowDelay	imgui_internal.h	/^    float                   TooltipSlowDelay;                   \/\/ Time before slow tooltips appears (FIXME: This is temporary until we merge in tooltip timer+priority work)$/;"	m	struct:ImGuiContext
TotalIdxCount	imgui.h	/^    int             TotalIdxCount;          \/\/ For convenience, sum of all ImDrawList's IdxBuffer.Size$/;"	m	struct:ImDrawData
TotalVtxCount	imgui.h	/^    int             TotalVtxCount;          \/\/ For convenience, sum of all ImDrawList's VtxBuffer.Size$/;"	m	struct:ImDrawData
TouchExtraPadding	imgui.h	/^    ImVec2      TouchExtraPadding;          \/\/ Expand reactive bounding box for touch-based system where touch position is not accurate enough. Unfortunately we don't sort widgets so priority on overlap will always be given to the first widget. So don't grow this too much!$/;"	m	struct:ImGuiStyle
Translate	imgui_internal.h	/^    void        Translate(const ImVec2& d)          { Min.x += d.x; Min.y += d.y; Max.x += d.x; Max.y += d.y; }$/;"	f	struct:ImRect
TranslateX	imgui_internal.h	/^    void        TranslateX(float dx)                { Min.x += dx; Max.x += dx; }$/;"	f	struct:ImRect
TranslateY	imgui_internal.h	/^    void        TranslateY(float dy)                { Min.y += dy; Max.y += dy; }$/;"	f	struct:ImRect
TreeAdvanceToLabelPos	imgui.h	/^    static inline void  TreeAdvanceToLabelPos()             { SetCursorPosX(GetCursorPosX() + GetTreeNodeToLabelSpacing()); }$/;"	f	namespace:ImGui
TreeDepth	imgui_internal.h	/^    int                     TreeDepth;              \/\/ Current tree depth.$/;"	m	struct:ImGuiWindowTempData
TreeJumpToParentOnPopMask	imgui_internal.h	/^    ImU32                   TreeJumpToParentOnPopMask; \/\/ Store a copy of !g.NavIdIsAlive for TreeDepth 0..31.. Could be turned into a ImU64 if necessary.$/;"	m	struct:ImGuiWindowTempData
TreeNode	imgui_widgets.cpp	/^bool ImGui::TreeNode(const char* label)$/;"	f	class:ImGui
TreeNode	imgui_widgets.cpp	/^bool ImGui::TreeNode(const char* str_id, const char* fmt, ...)$/;"	f	class:ImGui
TreeNode	imgui_widgets.cpp	/^bool ImGui::TreeNode(const void* ptr_id, const char* fmt, ...)$/;"	f	class:ImGui
TreeNodeBehavior	imgui_widgets.cpp	/^bool ImGui::TreeNodeBehavior(ImGuiID id, ImGuiTreeNodeFlags flags, const char* label, const char* label_end)$/;"	f	class:ImGui
TreeNodeBehaviorIsOpen	imgui_widgets.cpp	/^bool ImGui::TreeNodeBehaviorIsOpen(ImGuiID id, ImGuiTreeNodeFlags flags)$/;"	f	class:ImGui
TreeNodeEx	imgui_widgets.cpp	/^bool ImGui::TreeNodeEx(const char* label, ImGuiTreeNodeFlags flags)$/;"	f	class:ImGui
TreeNodeEx	imgui_widgets.cpp	/^bool ImGui::TreeNodeEx(const char* str_id, ImGuiTreeNodeFlags flags, const char* fmt, ...)$/;"	f	class:ImGui
TreeNodeEx	imgui_widgets.cpp	/^bool ImGui::TreeNodeEx(const void* ptr_id, ImGuiTreeNodeFlags flags, const char* fmt, ...)$/;"	f	class:ImGui
TreeNodeExV	imgui_widgets.cpp	/^bool ImGui::TreeNodeExV(const char* str_id, ImGuiTreeNodeFlags flags, const char* fmt, va_list args)$/;"	f	class:ImGui
TreeNodeExV	imgui_widgets.cpp	/^bool ImGui::TreeNodeExV(const void* ptr_id, ImGuiTreeNodeFlags flags, const char* fmt, va_list args)$/;"	f	class:ImGui
TreeNodeV	imgui_widgets.cpp	/^bool ImGui::TreeNodeV(const char* str_id, const char* fmt, va_list args)$/;"	f	class:ImGui
TreeNodeV	imgui_widgets.cpp	/^bool ImGui::TreeNodeV(const void* ptr_id, const char* fmt, va_list args)$/;"	f	class:ImGui
TreePop	imgui_widgets.cpp	/^void ImGui::TreePop()$/;"	f	class:ImGui
TreePush	imgui_widgets.cpp	/^void ImGui::TreePush(const char* str_id)$/;"	f	class:ImGui
TreePush	imgui_widgets.cpp	/^void ImGui::TreePush(const void* ptr_id)$/;"	f	class:ImGui
TreePushOverrideID	imgui_widgets.cpp	/^void ImGui::TreePushOverrideID(ImGuiID id)$/;"	f	class:ImGui
Type	imgui.cpp	/^    ImGuiDataType   Type;$/;"	m	struct:ImGuiStyleVarInfo	file:
Type	imgui_internal.h	/^    ImGuiContextHookType        Type;$/;"	m	struct:ImGuiContextHook
TypeHash	imgui_internal.h	/^    ImGuiID     TypeHash;       \/\/ == ImHashStr(TypeName)$/;"	m	struct:ImGuiSettingsHandler
TypeName	imgui_internal.h	/^    const char* TypeName;       \/\/ Short description stored in .ini file. Disallowed characters: '[' ']'$/;"	m	struct:ImGuiSettingsHandler
U0	imgui.h	/^    float           U0, V0, U1, V1;     \/\/ Texture coordinates$/;"	m	struct:ImFontGlyph
U1	imgui.h	/^    float           U0, V0, U1, V1;     \/\/ Texture coordinates$/;"	m	struct:ImFontGlyph
Unindent	imgui.cpp	/^void ImGui::Unindent(float indent_w)$/;"	f	class:ImGui
UnpackAccumulativeOffsetsIntoRanges	imgui_draw.cpp	/^static void UnpackAccumulativeOffsetsIntoRanges(int base_codepoint, const short* accumulative_offsets, int accumulative_offsets_count, ImWchar* out_ranges)$/;"	f	file:
UnpackBitVectorToFlatIndexList	imgui_draw.cpp	/^static void UnpackBitVectorToFlatIndexList(const ImBitVector* in, ImVector<int>* out)$/;"	f	file:
Update	imgui_widgets.cpp	/^void ImGuiMenuColumns::Update(int count, float spacing, bool clear)$/;"	f	class:ImGuiMenuColumns
UpdateDebugToolItemPicker	imgui.cpp	/^void ImGui::UpdateDebugToolItemPicker()$/;"	f	class:ImGui
UpdateHoveredWindowAndCaptureFlags	imgui.cpp	/^void ImGui::UpdateHoveredWindowAndCaptureFlags()$/;"	f	class:ImGui
UpdateMouseInputs	imgui.cpp	/^static void ImGui::UpdateMouseInputs()$/;"	f	class:ImGui
UpdateMouseMovingWindowEndFrame	imgui.cpp	/^void ImGui::UpdateMouseMovingWindowEndFrame()$/;"	f	class:ImGui
UpdateMouseMovingWindowNewFrame	imgui.cpp	/^void ImGui::UpdateMouseMovingWindowNewFrame()$/;"	f	class:ImGui
UpdateMouseWheel	imgui.cpp	/^void ImGui::UpdateMouseWheel()$/;"	f	class:ImGui
UpdateSettings	imgui.cpp	/^void ImGui::UpdateSettings()$/;"	f	class:ImGui
UpdateTabFocus	imgui.cpp	/^void ImGui::UpdateTabFocus()$/;"	f	class:ImGui
UpdateViewportsNewFrame	imgui.cpp	/^static void ImGui::UpdateViewportsNewFrame()$/;"	f	class:ImGui
UpdateWindowManualResize	imgui.cpp	/^static bool ImGui::UpdateWindowManualResize(ImGuiWindow* window, const ImVec2& size_auto_fit, int* border_held, int resize_grip_count, ImU32 resize_grip_col[4], const ImRect& visibility_rect)$/;"	f	class:ImGui
UpdateWindowParentAndRootLinks	imgui.cpp	/^void ImGui::UpdateWindowParentAndRootLinks(ImGuiWindow* window, ImGuiWindowFlags flags, ImGuiWindow* parent_window)$/;"	f	class:ImGui
UpdateWorkRect	imgui_internal.h	/^    void    UpdateWorkRect()            { WorkPos = CalcWorkRectPos(WorkOffsetMin); WorkSize = CalcWorkRectSize(WorkOffsetMin, WorkOffsetMax); } \/\/ Update public fields$/;"	f	struct:ImGuiViewportP
Used4kPagesMap	imgui.h	/^    ImU8                        Used4kPagesMap[(IM_UNICODE_CODEPOINT_MAX+1)\/4096\/8]; \/\/ 2 bytes if ImWchar=ImWchar16, 34 bytes if ImWchar==ImWchar32. Store 1-bit for each block of 4K codepoints that has one active glyph. This is mainly used to facilitate iterations across all used codepoints.$/;"	m	struct:ImFont
UsedChars	imgui.h	/^    ImVector<ImU32> UsedChars;            \/\/ Store 1-bit per Unicode code point (0=unused, 1=used)$/;"	m	struct:ImFontGlyphRangesBuilder
UserCallback	imgui.h	/^    ImDrawCallback  UserCallback;       \/\/ 4-8  \/\/ If != NULL, call the function instead of rendering the vertices. clip_rect and texture_id will be set normally.$/;"	m	struct:ImDrawCmd
UserCallback	imgui_internal.h	/^    ImGuiInputTextCallback  UserCallback;           \/\/ "$/;"	m	struct:ImGuiInputTextState
UserCallbackData	imgui.h	/^    void*           UserCallbackData;   \/\/ 4-8  \/\/ The draw callback code can access this.$/;"	m	struct:ImDrawCmd
UserCallbackData	imgui_internal.h	/^    void*                   UserCallbackData;       \/\/ "$/;"	m	struct:ImGuiInputTextState
UserData	imgui.h	/^    void*               UserData;       \/\/ What user passed to InputText()      \/\/ Read-only$/;"	m	struct:ImGuiInputTextCallbackData
UserData	imgui.h	/^    void*       UserData;                       \/\/ = NULL           \/\/ Store your own data for retrieval by callbacks.$/;"	m	struct:ImGuiIO
UserData	imgui.h	/^    void*   UserData;       \/\/ Read-only.   What user passed to SetNextWindowSizeConstraints()$/;"	m	struct:ImGuiSizeCallbackData
UserData	imgui_internal.h	/^    void*                       UserData;$/;"	m	struct:ImGuiContextHook
UserData	imgui_internal.h	/^    void*       UserData;$/;"	m	struct:ImGuiSettingsHandler
UserFlags	imgui_internal.h	/^    ImGuiInputTextFlags     UserFlags;              \/\/ Temporarily set while we call user's callback$/;"	m	struct:ImGuiInputTextState
UserID	imgui_internal.h	/^    ImGuiID                 UserID;                         \/\/ Optional, value passed to TableSetupColumn()$/;"	m	struct:ImGuiTableColumn
UserID	imgui_internal.h	/^    ImGuiID                 UserID;$/;"	m	struct:ImGuiTableColumnSettings
UserOuterSize	imgui_internal.h	/^    ImVec2                      UserOuterSize;              \/\/ outer_size.x passed to BeginTable()$/;"	m	struct:ImGuiTable
V0	imgui.h	/^    float           U0, V0, U1, V1;     \/\/ Texture coordinates$/;"	m	struct:ImFontGlyph
V1	imgui.h	/^    float           U0, V0, U1, V1;     \/\/ Texture coordinates$/;"	m	struct:ImFontGlyph
VSliderFloat	imgui_widgets.cpp	/^bool ImGui::VSliderFloat(const char* label, const ImVec2& size, float* v, float v_min, float v_max, const char* format, ImGuiSliderFlags flags)$/;"	f	class:ImGui
VSliderInt	imgui_widgets.cpp	/^bool ImGui::VSliderInt(const char* label, const ImVec2& size, int* v, int v_min, int v_max, const char* format, ImGuiSliderFlags flags)$/;"	f	class:ImGui
VSliderScalar	imgui_widgets.cpp	/^bool ImGui::VSliderScalar(const char* label, const ImVec2& size, ImGuiDataType data_type, void* p_data, const void* p_min, const void* p_max, const char* format, ImGuiSliderFlags flags)$/;"	f	class:ImGui
Valid	imgui.h	/^    bool            Valid;                  \/\/ Only valid after Render() is called and before the next NewFrame() is called.$/;"	m	struct:ImDrawData
Value	imgui.h	/^    ImVec4              Value;$/;"	m	struct:ImColor
Value	imgui_widgets.cpp	/^void ImGui::Value(const char* prefix, bool b)$/;"	f	class:ImGui
Value	imgui_widgets.cpp	/^void ImGui::Value(const char* prefix, float v, const char* float_format)$/;"	f	class:ImGui
Value	imgui_widgets.cpp	/^void ImGui::Value(const char* prefix, int v)$/;"	f	class:ImGui
Value	imgui_widgets.cpp	/^void ImGui::Value(const char* prefix, unsigned int v)$/;"	f	class:ImGui
Values	imgui_widgets.cpp	/^    const float* Values;$/;"	m	struct:ImGuiPlotArrayGetterData	file:
VarIdx	imgui_internal.h	/^    ImGuiStyleVar   VarIdx;$/;"	m	struct:ImGuiStyleMod
Viewports	imgui_internal.h	/^    ImVector<ImGuiViewportP*> Viewports;                        \/\/ Active viewports (Size==1 in 'master' branch). Each viewports hold their copy of ImDrawData.$/;"	m	struct:ImGuiContext
Visible	imgui.h	/^    unsigned int    Visible : 1;        \/\/ Flag to indicate glyph has no visible pixels (e.g. space). Allow early out when rendering.$/;"	m	struct:ImFontGlyph
VisibleMaskByIndex	imgui_internal.h	/^    ImU64                       VisibleMaskByIndex;         \/\/ Column Index -> IsVisibleX|IsVisibleY map (== not hidden by user\/api && not hidden by scrolling\/cliprect)$/;"	m	struct:ImGuiTable
VisibleTabId	imgui_internal.h	/^    ImGuiID             VisibleTabId;           \/\/ Can occasionally be != SelectedTabId (e.g. when previewing contents for CTRL+TAB preview)$/;"	m	struct:ImGuiTabBar
VisibleTabWasSubmitted	imgui_internal.h	/^    bool                VisibleTabWasSubmitted;$/;"	m	struct:ImGuiTabBar
VtxBuffer	imgui.h	/^    ImVector<ImDrawVert>    VtxBuffer;          \/\/ Vertex buffer.$/;"	m	struct:ImDrawList
VtxOffset	imgui.h	/^    unsigned int    VtxOffset;          \/\/ 4    \/\/ Start offset in vertex buffer. ImGuiBackendFlags_RendererHasVtxOffset: always 0, otherwise may be >0 to support meshes larger than 64K vertices with 16-bit indices.$/;"	m	struct:ImDrawCmd
VtxOffset	imgui.h	/^    unsigned int    VtxOffset;$/;"	m	struct:ImDrawCmdHeader
WIN32_LEAN_AND_MEAN	imgui.cpp	/^#define WIN32_LEAN_AND_MEAN$/;"	d	file:
WINDOWS_HOVER_PADDING	imgui.cpp	/^static const float WINDOWS_HOVER_PADDING                    = 4.0f;     \/\/ Extend outside window for hovering\/resizing (maxxed with TouchPadding) and inside windows for borders. Affect FindHoveredWindow().$/;"	v	file:
WINDOWS_MOUSE_WHEEL_SCROLL_LOCK_TIMER	imgui.cpp	/^static const float WINDOWS_MOUSE_WHEEL_SCROLL_LOCK_TIMER    = 2.00f;    \/\/ Lock scrolled window (so it doesn't pick child windows that are scrolling through) for a certain time, unless mouse moved.$/;"	v	file:
WINDOWS_RESIZE_FROM_EDGES_FEEDBACK_TIMER	imgui.cpp	/^static const float WINDOWS_RESIZE_FROM_EDGES_FEEDBACK_TIMER = 0.04f;    \/\/ Reduce visual noise by only highlighting the border after a certain time.$/;"	v	file:
WantApply	imgui_internal.h	/^    bool                        WantApply;              \/\/ Set when loaded from .ini data (to enable merging\/loading .ini data into an already running context)$/;"	m	struct:ImGuiTableSettings
WantApply	imgui_internal.h	/^    bool        WantApply;      \/\/ Set when loaded from .ini data (to enable merging\/loading .ini data into an already running context)$/;"	m	struct:ImGuiWindowSettings
WantCaptureKeyboard	imgui.h	/^    bool        WantCaptureKeyboard;            \/\/ Set when Dear ImGui will use keyboard inputs, in this case do not dispatch them to your main game\/application (either way, always pass keyboard inputs to imgui). (e.g. InputText active, or an imgui window is focused and navigation is enabled, etc.).$/;"	m	struct:ImGuiIO
WantCaptureKeyboardNextFrame	imgui_internal.h	/^    int                     WantCaptureKeyboardNextFrame;$/;"	m	struct:ImGuiContext
WantCaptureMouse	imgui.h	/^    bool        WantCaptureMouse;               \/\/ Set when Dear ImGui will use mouse inputs, in this case do not dispatch them to your main game\/application (either way, always pass on mouse inputs to imgui). (e.g. unclicked mouse is hovering over an imgui window, widget is active, mouse was clicked over an imgui window, etc.).$/;"	m	struct:ImGuiIO
WantCaptureMouseNextFrame	imgui_internal.h	/^    int                     WantCaptureMouseNextFrame;          \/\/ Explicit capture via CaptureKeyboardFromApp()\/CaptureMouseFromApp() sets those flags$/;"	m	struct:ImGuiContext
WantClose	imgui_demo.cpp	/^    bool        WantClose;  \/\/ Set when the document$/;"	m	struct:MyDocument	file:
WantClose	imgui_internal.h	/^    bool                WantClose;              \/\/ Marked as closed by SetTabItemClosed()$/;"	m	struct:ImGuiTabItem
WantCollapseToggle	imgui_internal.h	/^    bool                    WantCollapseToggle;$/;"	m	struct:ImGuiWindow
WantLayout	imgui_internal.h	/^    bool                WantLayout;$/;"	m	struct:ImGuiTabBar
WantSaveIniSettings	imgui.h	/^    bool        WantSaveIniSettings;            \/\/ When manual .ini load\/save is active (io.IniFilename == NULL), this will be set to notify your application that you can call SaveIniSettingsToMemory() and save yourself. Important: clear io.WantSaveIniSettings yourself after saving!$/;"	m	struct:ImGuiIO
WantSetMousePos	imgui.h	/^    bool        WantSetMousePos;                \/\/ MousePos has been altered, backend should reposition mouse on next frame. Rarely used! Set only when ImGuiConfigFlags_NavEnableSetMousePos flag is enabled.$/;"	m	struct:ImGuiIO
WantTextInput	imgui.h	/^    bool        WantTextInput;                  \/\/ Mobile\/console: when set, you may display an on-screen keyboard. This is set by Dear ImGui when it wants textual keyboard input to happen (e.g. when a InputText widget is active).$/;"	m	struct:ImGuiIO
WantTextInputNextFrame	imgui_internal.h	/^    int                     WantTextInputNextFrame;$/;"	m	struct:ImGuiContext
WasActive	imgui_internal.h	/^    bool                    WasActive;$/;"	m	struct:ImGuiWindow
WheelingWindow	imgui_internal.h	/^    ImGuiWindow*            WheelingWindow;                     \/\/ Track the window we started mouse-wheeling on. Until a timer elapse or mouse has moved, generally keep scrolling the same window even if during the course of scrolling the mouse ends up hovering a child window.$/;"	m	struct:ImGuiContext
WheelingWindowRefMousePos	imgui_internal.h	/^    ImVec2                  WheelingWindowRefMousePos;$/;"	m	struct:ImGuiContext
WheelingWindowTimer	imgui_internal.h	/^    float                   WheelingWindowTimer;$/;"	m	struct:ImGuiContext
Width	imgui.h	/^    unsigned short  Width, Height;  \/\/ Input    \/\/ Desired rectangle dimension$/;"	m	struct:ImFontAtlasCustomRect
Width	imgui_internal.h	/^    float                       Width;          \/\/ Set by SetNextItemWidth()$/;"	m	struct:ImGuiNextItemData
Width	imgui_internal.h	/^    float               Width;                  \/\/ Width currently displayed$/;"	m	struct:ImGuiTabItem
Width	imgui_internal.h	/^    float       Width, NextWidth;$/;"	m	struct:ImGuiMenuColumns
Width	imgui_internal.h	/^    float       Width;$/;"	m	struct:ImGuiShrinkWidthItem
Width	imgui_widgets.cpp	/^    float               Width;                  \/\/ Sum of width of tabs in this section (after shrinking down)$/;"	m	struct:ImGuiTabBarSection	file:
WidthAllTabs	imgui_internal.h	/^    float               WidthAllTabs;           \/\/ Actual width of all tabs (locked during layout)$/;"	m	struct:ImGuiTabBar
WidthAllTabsIdeal	imgui_internal.h	/^    float               WidthAllTabsIdeal;      \/\/ Ideal width if all tabs were visible and not clipped$/;"	m	struct:ImGuiTabBar
WidthAuto	imgui_internal.h	/^    float                   WidthAuto;                      \/\/ Automatic width$/;"	m	struct:ImGuiTableColumn
WidthGiven	imgui_internal.h	/^    float                   WidthGiven;                     \/\/ Final\/actual width visible == (MaxX - MinX), locked in TableUpdateLayout(). May be > WidthRequest to honor minimum width, may be < WidthRequest to honor shrinking columns down in tight space.$/;"	m	struct:ImGuiTableColumn
WidthOrWeight	imgui_internal.h	/^    float                   WidthOrWeight;$/;"	m	struct:ImGuiTableColumnSettings
WidthRequest	imgui_internal.h	/^    float                   WidthRequest;                   \/\/ Master width absolute value when !(Flags & _WidthStretch). When Stretch this is derived every frame from StretchWeight in TableUpdateLayout()$/;"	m	struct:ImGuiTableColumn
Window	imgui_internal.h	/^    ImGuiWindow*        Window;         \/\/ Init,Move    \/\/ Best candidate window (result->ItemWindow->RootWindowForNav == request->Window)$/;"	m	struct:ImGuiNavItemData
Window	imgui_internal.h	/^    ImGuiWindow*        Window;         \/\/ Resolved on BeginPopup() - may stay unresolved if user never calls OpenPopup()$/;"	m	struct:ImGuiPopupData
WindowBorderSize	imgui.h	/^    float       WindowBorderSize;           \/\/ Thickness of border around windows. Generally set to 0.0f or 1.0f. (Other values are not well tested and more CPU\/GPU costly).$/;"	m	struct:ImGuiStyle
WindowBorderSize	imgui_internal.h	/^    float                   WindowBorderSize;                   \/\/ Window border size at the time of Begin().$/;"	m	struct:ImGuiWindow
WindowID	imgui_internal.h	/^    ImGuiID     WindowID;$/;"	m	struct:ImGuiGroupData
WindowMenuButtonPosition	imgui.h	/^    ImGuiDir    WindowMenuButtonPosition;   \/\/ Side of the collapsing\/docking button in the title bar (None\/Left\/Right). Defaults to ImGuiDir_Left.$/;"	m	struct:ImGuiStyle
WindowMinSize	imgui.h	/^    ImVec2      WindowMinSize;              \/\/ Minimum window size. This is a global setting. If you want to constraint individual windows, use SetNextWindowSizeConstraints().$/;"	m	struct:ImGuiStyle
WindowPadding	imgui.h	/^    ImVec2      WindowPadding;              \/\/ Padding within a window.$/;"	m	struct:ImGuiStyle
WindowPadding	imgui_internal.h	/^    ImVec2                  WindowPadding;                      \/\/ Window padding at the time of Begin().$/;"	m	struct:ImGuiWindow
WindowRounding	imgui.h	/^    float       WindowRounding;             \/\/ Radius of window corners rounding. Set to 0.0f to have rectangular windows. Large values tend to lead to variety of artifacts and are not recommended.$/;"	m	struct:ImGuiStyle
WindowRounding	imgui_internal.h	/^    float                   WindowRounding;                     \/\/ Window rounding at the time of Begin(). May be clamped lower to avoid rendering artifacts with title bar, menu bar etc.$/;"	m	struct:ImGuiWindow
WindowSettingsHandler_ApplyAll	imgui.cpp	/^static void WindowSettingsHandler_ApplyAll(ImGuiContext* ctx, ImGuiSettingsHandler*)$/;"	f	file:
WindowSettingsHandler_ClearAll	imgui.cpp	/^static void WindowSettingsHandler_ClearAll(ImGuiContext* ctx, ImGuiSettingsHandler*)$/;"	f	file:
WindowSettingsHandler_ReadLine	imgui.cpp	/^static void WindowSettingsHandler_ReadLine(ImGuiContext*, ImGuiSettingsHandler*, void* entry, const char* line)$/;"	f	file:
WindowSettingsHandler_ReadOpen	imgui.cpp	/^static void* WindowSettingsHandler_ReadOpen(ImGuiContext*, ImGuiSettingsHandler*, const char* name)$/;"	f	file:
WindowSettingsHandler_WriteAll	imgui.cpp	/^static void WindowSettingsHandler_WriteAll(ImGuiContext* ctx, ImGuiSettingsHandler* handler, ImGuiTextBuffer* buf)$/;"	f	file:
WindowTitleAlign	imgui.h	/^    ImVec2      WindowTitleAlign;           \/\/ Alignment for title bar text. Defaults to (0.0f,0.5f) for left-aligned,vertically centered.$/;"	m	struct:ImGuiStyle
Windows	imgui_internal.h	/^    ImVector<ImGuiWindow*>  Windows;                            \/\/ Windows, sorted in display order, back to front$/;"	m	struct:ImGuiContext
WindowsActiveCount	imgui_internal.h	/^    int                     WindowsActiveCount;                 \/\/ Number of unique windows submitted by frame$/;"	m	struct:ImGuiContext
WindowsById	imgui_internal.h	/^    ImGuiStorage            WindowsById;                        \/\/ Map window's ImGuiID to ImGuiWindow*$/;"	m	struct:ImGuiContext
WindowsFocusOrder	imgui_internal.h	/^    ImVector<ImGuiWindow*>  WindowsFocusOrder;                  \/\/ Root windows, sorted in focus order, back to front.$/;"	m	struct:ImGuiContext
WindowsHoverPadding	imgui_internal.h	/^    ImVec2                  WindowsHoverPadding;                \/\/ Padding around resizable windows for which hovering on counts as hovering the window == ImMax(style.TouchExtraPadding, WINDOWS_HOVER_PADDING)$/;"	m	struct:ImGuiContext
WindowsTempSortBuffer	imgui_internal.h	/^    ImVector<ImGuiWindow*>  WindowsTempSortBuffer;              \/\/ Temporary buffer used in EndFrame() to reorder windows so parents are kept before their child$/;"	m	struct:ImGuiContext
WithinEndChild	imgui_internal.h	/^    bool                    WithinEndChild;                     \/\/ Set within EndChild()$/;"	m	struct:ImGuiContext
WithinFrameScope	imgui_internal.h	/^    bool                    WithinFrameScope;                   \/\/ Set by NewFrame(), cleared by EndFrame()$/;"	m	struct:ImGuiContext
WithinFrameScopeWithImplicitWindow	imgui_internal.h	/^    bool                    WithinFrameScopeWithImplicitWindow; \/\/ Set by NewFrame(), cleared by EndFrame() when the implicit debug window has been pushed$/;"	m	struct:ImGuiContext
WorkMaxX	imgui_internal.h	/^    float                   WorkMaxX;                       \/\/ Contents region max ~(MaxX - CellPaddingX - CellSpacingX2)$/;"	m	struct:ImGuiTableColumn
WorkMinX	imgui_internal.h	/^    float                   WorkMinX;                       \/\/ Contents region min ~(MinX + CellPaddingX + CellSpacingX1) == cursor start position when entering column$/;"	m	struct:ImGuiTableColumn
WorkOffsetMax	imgui_internal.h	/^    ImVec2              WorkOffsetMax;          \/\/ Work Area: Offset from Pos+Size to bottom-right corner of Work Area. Generally (0,0) or (0,-status_bar_height).$/;"	m	struct:ImGuiViewportP
WorkOffsetMin	imgui_internal.h	/^    ImVec2              WorkOffsetMin;          \/\/ Work Area: Offset from Pos to top-left corner of Work Area. Generally (0,0) or (0,+main_menu_bar_height). Work Area is Full Area but without menu-bars\/status-bars (so WorkArea always fit inside Pos\/Size!)$/;"	m	struct:ImGuiViewportP
WorkPos	imgui.h	/^    ImVec2              WorkPos;                \/\/ Work Area: Position of the viewport minus task bars, menus bars, status bars (>= Pos)$/;"	m	struct:ImGuiViewport
WorkRect	imgui_internal.h	/^    ImRect                      WorkRect;$/;"	m	struct:ImGuiTable
WorkRect	imgui_internal.h	/^    ImRect                  WorkRect;                           \/\/ Initially covers the whole scrolling region. Reduced by containers e.g columns\/tables when active. Shrunk by WindowPadding*1.0f on each side. This is meant to replace ContentRegionRect over time (from 1.71+ onward).$/;"	m	struct:ImGuiWindow
WorkSize	imgui.h	/^    ImVec2              WorkSize;               \/\/ Work Area: Size of the viewport minus task bars, menu bars, status bars (<= Size)$/;"	m	struct:ImGuiViewport
WriteAccessed	imgui_internal.h	/^    bool                    WriteAccessed;                      \/\/ Set to true when any widget access the current window$/;"	m	struct:ImGuiWindow
WriteAllFn	imgui_internal.h	/^    void        (*WriteAllFn)(ImGuiContext* ctx, ImGuiSettingsHandler* handler, ImGuiTextBuffer* out_buf);      \/\/ Write: Output every entries into 'out_buf'$/;"	m	struct:ImGuiSettingsHandler
X	imgui.h	/^    unsigned short  X, Y;           \/\/ Output   \/\/ Packed position in Atlas$/;"	m	struct:ImFontAtlasCustomRect
X0	imgui.h	/^    float           X0, Y0, X1, Y1;     \/\/ Glyph corners$/;"	m	struct:ImFontGlyph
X1	imgui.h	/^    float           X0, Y0, X1, Y1;     \/\/ Glyph corners$/;"	m	struct:ImFontGlyph
Y	imgui.h	/^    unsigned short  X, Y;           \/\/ Output   \/\/ Packed position in Atlas$/;"	m	struct:ImFontAtlasCustomRect
Y0	imgui.h	/^    float           X0, Y0, X1, Y1;     \/\/ Glyph corners$/;"	m	struct:ImFontGlyph
Y1	imgui.h	/^    float           X0, Y0, X1, Y1;     \/\/ Glyph corners$/;"	m	struct:ImFontGlyph
_CRT_SECURE_NO_WARNINGS	imgui.cpp	/^#define _CRT_SECURE_NO_WARNINGS$/;"	d	file:
_CRT_SECURE_NO_WARNINGS	imgui_demo.cpp	/^#define _CRT_SECURE_NO_WARNINGS$/;"	d	file:
_CRT_SECURE_NO_WARNINGS	imgui_draw.cpp	/^#define _CRT_SECURE_NO_WARNINGS$/;"	d	file:
_CRT_SECURE_NO_WARNINGS	imgui_tables.cpp	/^#define _CRT_SECURE_NO_WARNINGS$/;"	d	file:
_CRT_SECURE_NO_WARNINGS	imgui_widgets.cpp	/^#define _CRT_SECURE_NO_WARNINGS$/;"	d	file:
_CalcCircleAutoSegmentCount	imgui_draw.cpp	/^int ImDrawList::_CalcCircleAutoSegmentCount(float radius) const$/;"	f	class:ImDrawList
_Channels	imgui.h	/^    ImVector<ImDrawChannel>     _Channels;   \/\/ Draw channels (not resized down so _Count might be < Channels.Size)$/;"	m	struct:ImDrawListSplitter
_ClearFreeMemory	imgui_draw.cpp	/^void ImDrawList::_ClearFreeMemory()$/;"	f	class:ImDrawList
_ClipRectStack	imgui.h	/^    ImVector<ImVec4>        _ClipRectStack;     \/\/ [Internal]$/;"	m	struct:ImDrawList
_CmdBuffer	imgui.h	/^    ImVector<ImDrawCmd>         _CmdBuffer;$/;"	m	struct:ImDrawChannel
_CmdHeader	imgui.h	/^    ImDrawCmdHeader         _CmdHeader;         \/\/ [Internal] template of active commands. Fields should match those of CmdBuffer.back().$/;"	m	struct:ImDrawList
_Count	imgui.h	/^    int                         _Count;      \/\/ Number of active channels (1+)$/;"	m	struct:ImDrawListSplitter
_Current	imgui.h	/^    int                         _Current;    \/\/ Current channel number (0)$/;"	m	struct:ImDrawListSplitter
_Data	imgui.h	/^    const ImDrawListSharedData* _Data;          \/\/ Pointer to shared draw data (you can use ImGui::GetDrawListSharedData() to get the one from current ImGui context)$/;"	m	struct:ImDrawList
_FringeScale	imgui.h	/^    float                   _FringeScale;       \/\/ [Internal] anti-alias fringe is scaled by this value, this helps to keep things sharp while zooming at vertex buffer content$/;"	m	struct:ImDrawList
_IdxBuffer	imgui.h	/^    ImVector<ImDrawIdx>         _IdxBuffer;$/;"	m	struct:ImDrawChannel
_IdxWritePtr	imgui.h	/^    ImDrawIdx*              _IdxWritePtr;       \/\/ [Internal] point within IdxBuffer.Data after each add command (to avoid using the ImVector<> operators too much)$/;"	m	struct:ImDrawList
_OnChangedClipRect	imgui_draw.cpp	/^void ImDrawList::_OnChangedClipRect()$/;"	f	class:ImDrawList
_OnChangedTextureID	imgui_draw.cpp	/^void ImDrawList::_OnChangedTextureID()$/;"	f	class:ImDrawList
_OnChangedVtxOffset	imgui_draw.cpp	/^void ImDrawList::_OnChangedVtxOffset()$/;"	f	class:ImDrawList
_OwnerName	imgui.h	/^    const char*             _OwnerName;         \/\/ Pointer to owner window's name for debugging$/;"	m	struct:ImDrawList
_Path	imgui.h	/^    ImVector<ImVec2>        _Path;              \/\/ [Internal] current path building$/;"	m	struct:ImDrawList
_PathArcToFastEx	imgui_draw.cpp	/^void ImDrawList::_PathArcToFastEx(const ImVec2& center, float radius, int a_min_sample, int a_max_sample, int a_step)$/;"	f	class:ImDrawList
_PathArcToN	imgui_draw.cpp	/^void ImDrawList::_PathArcToN(const ImVec2& center, float radius, float a_min, float a_max, int num_segments)$/;"	f	class:ImDrawList
_PopUnusedDrawCmd	imgui_draw.cpp	/^void ImDrawList::_PopUnusedDrawCmd()$/;"	f	class:ImDrawList
_ResetForNewFrame	imgui_draw.cpp	/^void ImDrawList::_ResetForNewFrame()$/;"	f	class:ImDrawList
_Splitter	imgui.h	/^    ImDrawListSplitter      _Splitter;          \/\/ [Internal] for channels api (note: prefer using your own persistent instance of ImDrawListSplitter!)$/;"	m	struct:ImDrawList
_TextureIdStack	imgui.h	/^    ImVector<ImTextureID>   _TextureIdStack;    \/\/ [Internal]$/;"	m	struct:ImDrawList
_VtxCurrentIdx	imgui.h	/^    unsigned int            _VtxCurrentIdx;     \/\/ [Internal] generally == VtxBuffer.Size unless we are past 64K vertices, in which case this gets reset to 0.$/;"	m	struct:ImDrawList
_VtxWritePtr	imgui.h	/^    ImDrawVert*             _VtxWritePtr;       \/\/ [Internal] point within VtxBuffer.Data after each add command (to avoid using the ImVector<> operators too much)$/;"	m	struct:ImDrawList
__STB_INCLUDE_STB_TRUETYPE_H__	imstb_truetype.h	/^#define __STB_INCLUDE_STB_TRUETYPE_H__$/;"	d
_grow_capacity	imgui.h	/^    inline int          _grow_capacity(int sz) const        { int new_capacity = Capacity ? (Capacity + Capacity \/ 2) : 8; return new_capacity > sz ? new_capacity : sz; }$/;"	f	struct:ImVector
active_head	imstb_rectpack.h	/^   stbrp_node *active_head;$/;"	m	struct:stbrp_context
align	imstb_rectpack.h	/^   int align;$/;"	m	struct:stbrp_context
alloc_chunk	imgui_internal.h	/^    T*      alloc_chunk(size_t sz)      { size_t HDR_SZ = 4; sz = IM_MEMALIGN(HDR_SZ + sz, 4u); int off = Buf.Size; Buf.resize(off + (int)sz); ((int*)(void*)(Buf.Data + off))[0] = (int)sz; return (T*)(void*)(Buf.Data + off + (int)HDR_SZ); }$/;"	f	struct:ImChunkStream
alloca	imgui_draw.cpp	/^#define alloca /;"	d	file:
append	imgui.cpp	/^void ImGuiTextBuffer::append(const char* str, const char* str_end)$/;"	f	class:ImGuiTextBuffer
appendf	imgui.cpp	/^void ImGuiTextBuffer::appendf(const char* fmt, ...)$/;"	f	class:ImGuiTextBuffer
appendfv	imgui.cpp	/^void ImGuiTextBuffer::appendfv(const char* fmt, va_list args)$/;"	f	class:ImGuiTextBuffer
array_of_unicode_codepoints	imstb_truetype.h	/^   int *array_of_unicode_codepoints;       \/\/ if non-zero, then this is an array of unicode codepoints$/;"	m	struct:__anon11
b	imgui.h	/^        const char*     b;$/;"	m	struct:ImGuiTextFilter::ImGuiTextRange
back	imgui.h	/^    inline T&           back()                              { IM_ASSERT(Size > 0); return Data[Size - 1]; }$/;"	f	struct:ImVector
back	imgui.h	/^    inline const T&     back() const                        { IM_ASSERT(Size > 0); return Data[Size - 1]; }$/;"	f	struct:ImVector
baseline_y_delta	imstb_textedit.h	/^   float baseline_y_delta;  \/\/ position of baseline relative to previous row's baseline$/;"	m	struct:__anon5
begin	imgui.h	/^    const char*         begin() const           { return Buf.Data ? &Buf.front() : EmptyString; }$/;"	f	struct:ImGuiTextBuffer
begin	imgui.h	/^    inline T*           begin()                             { return Data; }$/;"	f	struct:ImVector
begin	imgui.h	/^    inline const T*     begin() const                       { return Data; }$/;"	f	struct:ImVector
begin	imgui_internal.h	/^    T*      begin()                     { size_t HDR_SZ = 4; if (!Buf.Data) return NULL; return (T*)(void*)(Buf.Data + HDR_SZ); }$/;"	f	struct:ImChunkStream
begin	imgui_internal.h	/^    inline T*           begin()                     { return Data; }$/;"	f	struct:ImSpan
begin	imgui_internal.h	/^    inline const T*     begin() const               { return Data; }$/;"	f	struct:ImSpan
bottom_y	imstb_truetype.h	/^   int x,y,bottom_y;$/;"	m	struct:__anon23
bounds	imstb_truetype.h	/^   int bounds;$/;"	m	struct:__anon21
c_str	imgui.h	/^    const char*         c_str() const           { return Buf.Data ? Buf.Data : EmptyString; }$/;"	f	struct:ImGuiTextBuffer
capacity	imgui.h	/^    inline int          capacity() const                    { return Capacity; }$/;"	f	struct:ImVector
cdata	imstb_truetype.h	/^stbtt_bakedchar cdata[96]; \/\/ ASCII 32..126 is 95 glyphs$/;"	v
cff	imstb_truetype.h	/^   stbtt__buf cff;                    \/\/ cff font data$/;"	m	struct:stbtt_fontinfo
char_storage	imstb_textedit.h	/^   int                        char_storage;$/;"	m	struct:__anon2
chardata_for_range	imstb_truetype.h	/^   stbtt_packedchar *chardata_for_range; \/\/ output$/;"	m	struct:__anon11
charstrings	imstb_truetype.h	/^   stbtt__buf charstrings;            \/\/ the charstring index$/;"	m	struct:stbtt_fontinfo
chunk_size	imgui_internal.h	/^    int     chunk_size(const T* p)      { return ((const int*)p)[-1]; }$/;"	f	struct:ImChunkStream
clear	imgui.h	/^    inline void         clear()                             { if (Data) { Size = Capacity = 0; IM_FREE(Data); Data = NULL; } }$/;"	f	struct:ImVector
clear	imgui.h	/^    void                clear()                 { Buf.clear(); }$/;"	f	struct:ImGuiTextBuffer
clear	imgui_internal.h	/^    void    clear()                     { Buf.clear(); }$/;"	f	struct:ImChunkStream
col	imgui.h	/^    ImU32   col;$/;"	m	struct:ImDrawVert
const_iterator	imgui.h	/^    typedef const value_type*   const_iterator;$/;"	t	struct:ImVector
contains	imgui.h	/^    inline bool         contains(const T& v) const          { const T* data = Data;  const T* data_end = Data + Size; while (data < data_end) if (*data++ == v) return true; return false; }$/;"	f	struct:ImVector
cursor	imstb_textedit.h	/^   int cursor;$/;"	m	struct:__anon4
cursor	imstb_truetype.h	/^   int cursor;$/;"	m	struct:__anon7
cursor_at_end_of_line	imstb_textedit.h	/^   unsigned char cursor_at_end_of_line; \/\/ not implemented yet$/;"	m	struct:__anon4
cx	imstb_truetype.h	/^      stbtt_vertex_type x,y,cx,cy,cx1,cy1;$/;"	m	struct:__anon13
cx1	imstb_truetype.h	/^      stbtt_vertex_type x,y,cx,cy,cx1,cy1;$/;"	m	struct:__anon13
cy	imstb_truetype.h	/^      stbtt_vertex_type x,y,cx,cy,cx1,cy1;$/;"	m	struct:__anon13
cy1	imstb_truetype.h	/^      stbtt_vertex_type x,y,cx,cy,cx1,cy1;$/;"	m	struct:__anon13
data	imstb_truetype.h	/^   unsigned char  * data;              \/\/ pointer to .ttf file$/;"	m	struct:stbtt_fontinfo
data	imstb_truetype.h	/^   unsigned char *data;$/;"	m	struct:__anon7
delete_length	imstb_textedit.h	/^   STB_TEXTEDIT_POSITIONTYPE  delete_length;$/;"	m	struct:__anon2
direction	imstb_truetype.h	/^   float direction;$/;"	m	struct:stbtt__active_edge
direction	imstb_truetype.h	/^   int direction;$/;"	m	struct:stbtt__active_edge
dx	imstb_truetype.h	/^   int x,dx;$/;"	m	struct:stbtt__active_edge
e	imgui.h	/^        const char*     e;$/;"	m	struct:ImGuiTextFilter::ImGuiTextRange
empty	imgui.h	/^        bool            empty() const                   { return b == e; }$/;"	f	struct:ImGuiTextFilter::ImGuiTextRange
empty	imgui.h	/^    bool                empty() const           { return Buf.Size <= 1; }$/;"	f	struct:ImGuiTextBuffer
empty	imgui.h	/^    inline bool         empty() const                       { return Size == 0; }$/;"	f	struct:ImVector
empty	imgui_internal.h	/^    bool    empty() const               { return Buf.Size == 0; }$/;"	f	struct:ImChunkStream
end	imgui.h	/^    const char*         end() const             { return Buf.Data ? &Buf.back() : EmptyString; }   \/\/ Buf is zero-terminated, so end() will point on the zero-terminator$/;"	f	struct:ImGuiTextBuffer
end	imgui.h	/^    inline T*           end()                               { return Data + Size; }$/;"	f	struct:ImVector
end	imgui.h	/^    inline const T*     end() const                         { return Data + Size; }$/;"	f	struct:ImVector
end	imgui_internal.h	/^    T*      end()                       { return (T*)(void*)(Buf.Data + Buf.Size); }$/;"	f	struct:ImChunkStream
end	imgui_internal.h	/^    inline T*           end()                       { return DataEnd; }$/;"	f	struct:ImSpan
end	imgui_internal.h	/^    inline const T*     end() const                 { return DataEnd; }$/;"	f	struct:ImSpan
equal	imstb_truetype.h	/^static int equal(float *a, float *b)$/;"	f
erase	imgui.h	/^    inline T*           erase(const T* it)                  { IM_ASSERT(it >= Data && it < Data + Size); const ptrdiff_t off = it - Data; memmove(Data + off, Data + off + 1, ((size_t)Size - (size_t)off - 1) * sizeof(T)); Size--; return Data + off; }$/;"	f	struct:ImVector
erase	imgui.h	/^    inline T*           erase(const T* it, const T* it_last){ IM_ASSERT(it >= Data && it < Data + Size && it_last > it && it_last <= Data + Size); const ptrdiff_t count = it_last - it; const ptrdiff_t off = it - Data; memmove(Data + off, Data + off + count, ((size_t)Size - (size_t)off - count) * sizeof(T)); Size -= (int)count; return Data + off; }$/;"	f	struct:ImVector
erase_unsorted	imgui.h	/^    inline T*           erase_unsorted(const T* it)         { IM_ASSERT(it >= Data && it < Data + Size);  const ptrdiff_t off = it - Data; if (it < Data + Size - 1) memcpy(Data + off, Data + Size - 1, sizeof(T)); Size--; return Data + off; }$/;"	f	struct:ImVector
extra	imstb_rectpack.h	/^   stbrp_node extra[2]; \/\/ we allocate two extra nodes so optimal user-node-count is 'width' not 'width+2'$/;"	m	struct:stbrp_context
ey	imstb_truetype.h	/^   float ey;$/;"	m	struct:stbtt__active_edge
fdselect	imstb_truetype.h	/^   stbtt__buf fdselect;               \/\/ map from glyph to fontdict$/;"	m	struct:stbtt_fontinfo
fdx	imstb_truetype.h	/^   float fx,fdx,fdy;$/;"	m	struct:stbtt__active_edge
fdy	imstb_truetype.h	/^   float fx,fdx,fdy;$/;"	m	struct:stbtt__active_edge
find	imgui.h	/^    inline T*           find(const T& v)                    { T* data = Data;  const T* data_end = Data + Size; while (data < data_end) if (*data == v) break; else ++data; return data; }$/;"	f	struct:ImVector
find	imgui.h	/^    inline const T*     find(const T& v) const              { const T* data = Data;  const T* data_end = Data + Size; while (data < data_end) if (*data == v) break; else ++data; return data; }$/;"	f	struct:ImVector
find_erase	imgui.h	/^    inline bool         find_erase(const T& v)              { const T* it = find(v); if (it < Data + Size) { erase(it); return true; } return false; }$/;"	f	struct:ImVector
find_erase_unsorted	imgui.h	/^    inline bool         find_erase_unsorted(const T& v)     { const T* it = find(v); if (it < Data + Size) { erase_unsorted(it); return true; } return false; }$/;"	f	struct:ImVector
first_char	imstb_textedit.h	/^   int first_char, length; \/\/ first char of row, and length$/;"	m	struct:__anon6
first_free	imstb_truetype.h	/^   void   *first_free;$/;"	m	struct:stbtt__hheap
first_unicode_codepoint_in_range	imstb_truetype.h	/^   int first_unicode_codepoint_in_range;  \/\/ if non-zero, then the chars are continuous, and this is the first codepoint$/;"	m	struct:__anon11
first_x	imstb_truetype.h	/^   float first_x, first_y;$/;"	m	struct:__anon21
first_y	imstb_truetype.h	/^   float first_x, first_y;$/;"	m	struct:__anon21
font_size	imstb_truetype.h	/^   float font_size;$/;"	m	struct:__anon11
fontdicts	imstb_truetype.h	/^   stbtt__buf fontdicts;              \/\/ array of font dicts$/;"	m	struct:stbtt_fontinfo
fontstart	imstb_truetype.h	/^   int              fontstart;         \/\/ offset of start of font$/;"	m	struct:stbtt_fontinfo
free_head	imstb_rectpack.h	/^   stbrp_node *free_head;$/;"	m	struct:stbrp_context
front	imgui.h	/^    inline T&           front()                             { IM_ASSERT(Size > 0); return Data[0]; }$/;"	f	struct:ImVector
front	imgui.h	/^    inline const T&     front() const                       { IM_ASSERT(Size > 0); return Data[0]; }$/;"	f	struct:ImVector
ftex	imstb_truetype.h	/^GLuint ftex;$/;"	v
fx	imstb_truetype.h	/^   float fx,fdx,fdy;$/;"	m	struct:stbtt__active_edge
glyf	imstb_truetype.h	/^   int loca,head,glyf,hhea,hmtx,kern,gpos; \/\/ table locations as offset from start of .ttf$/;"	m	struct:stbtt_fontinfo
gpos	imstb_truetype.h	/^   int loca,head,glyf,hhea,hmtx,kern,gpos; \/\/ table locations as offset from start of .ttf$/;"	m	struct:stbtt_fontinfo
gsubrs	imstb_truetype.h	/^   stbtt__buf gsubrs;                 \/\/ global charstring subroutines index$/;"	m	struct:stbtt_fontinfo
h	imstb_rectpack.h	/^   stbrp_coord    w, h;$/;"	m	struct:stbrp_rect
h	imstb_truetype.h	/^   int id,w,h,was_packed;$/;"	m	struct:stbrp_rect
h	imstb_truetype.h	/^   int w,h,stride;$/;"	m	struct:__anon14
h_oversample	imstb_truetype.h	/^   unsigned char h_oversample, v_oversample; \/\/ don't set these, they're used internally$/;"	m	struct:__anon11
h_oversample	imstb_truetype.h	/^   unsigned int   h_oversample, v_oversample;$/;"	m	struct:stbtt_pack_context
has_preferred_x	imstb_textedit.h	/^   unsigned char has_preferred_x;$/;"	m	struct:__anon4
head	imstb_truetype.h	/^   int loca,head,glyf,hhea,hmtx,kern,gpos; \/\/ table locations as offset from start of .ttf$/;"	m	struct:stbtt_fontinfo
head	imstb_truetype.h	/^   struct stbtt__hheap_chunk *head;$/;"	m	struct:stbtt__hheap	typeref:struct:stbtt__hheap::stbtt__hheap_chunk
height	imstb_rectpack.h	/^   int height;$/;"	m	struct:stbrp_context
height	imstb_textedit.h	/^   float height; \/\/ height of line$/;"	m	struct:__anon6
height	imstb_truetype.h	/^   int   height;$/;"	m	struct:stbtt_pack_context
height	imstb_truetype.h	/^   int width,height;$/;"	m	struct:__anon23
heuristic	imstb_rectpack.h	/^   int heuristic;$/;"	m	struct:stbrp_context
hhea	imstb_truetype.h	/^   int loca,head,glyf,hhea,hmtx,kern,gpos; \/\/ table locations as offset from start of .ttf$/;"	m	struct:stbtt_fontinfo
hmtx	imstb_truetype.h	/^   int loca,head,glyf,hhea,hmtx,kern,gpos; \/\/ table locations as offset from start of .ttf$/;"	m	struct:stbtt_fontinfo
id	imstb_rectpack.h	/^   int            id;$/;"	m	struct:stbrp_rect
id	imstb_truetype.h	/^   int id,w,h,was_packed;$/;"	m	struct:stbrp_rect
indexToLocFormat	imstb_truetype.h	/^   int indexToLocFormat;              \/\/ format needed to map from glyph index to glyph$/;"	m	struct:stbtt_fontinfo
index_from_ptr	imgui.h	/^    inline int          index_from_ptr(const T* it) const   { IM_ASSERT(it >= Data && it < Data + Size); const ptrdiff_t off = it - Data; return (int)off; }$/;"	f	struct:ImVector
index_from_ptr	imgui_internal.h	/^    inline int  index_from_ptr(const T* it) const   { IM_ASSERT(it >= Data && it < DataEnd); const ptrdiff_t off = it - Data; return (int)off; }$/;"	f	struct:ImSpan
index_map	imstb_truetype.h	/^   int index_map;                     \/\/ a cmap mapping for our chosen character encoding$/;"	m	struct:stbtt_fontinfo
init_mode	imstb_rectpack.h	/^   int init_mode;$/;"	m	struct:stbrp_context
initialized	imstb_textedit.h	/^   unsigned char initialized;$/;"	m	struct:__anon4
insert	imgui.h	/^    inline T*           insert(const T* it, const T& v)     { IM_ASSERT(it >= Data && it <= Data + Size); const ptrdiff_t off = it - Data; if (Size == Capacity) reserve(_grow_capacity(Size + 1)); if (off < (int)Size) memmove(Data + off + 1, Data + off, ((size_t)Size - (size_t)off) * sizeof(T)); memcpy(&Data[off], &v, sizeof(v)); Size++; return Data + off; }$/;"	f	struct:ImVector
insert_length	imstb_textedit.h	/^   STB_TEXTEDIT_POSITIONTYPE  insert_length;$/;"	m	struct:__anon2
insert_mode	imstb_textedit.h	/^   unsigned char insert_mode;$/;"	m	struct:__anon4
invert	imstb_truetype.h	/^   int invert;$/;"	m	struct:stbtt__edge
is_separator	imgui_widgets.cpp	/^static bool is_separator(unsigned int c)                                        { return ImCharIsBlankW(c) || c==',' || c==';' || c=='(' || c==')' || c=='{' || c=='}' || c=='[' || c==']' || c=='|'; }$/;"	f	namespace:ImStb
is_word_boundary	imstb_textedit.h	/^static int is_word_boundary( STB_TEXTEDIT_STRING *str, int idx )$/;"	f
is_word_boundary_from_left	imgui_widgets.cpp	/^static int  is_word_boundary_from_left(STB_TEXTEDIT_STRING* obj, int idx)       { return idx > 0 ? (!is_separator(obj->TextW[idx - 1]) && is_separator(obj->TextW[idx]) ) : 1; }$/;"	f	namespace:ImStb
is_word_boundary_from_right	imgui_widgets.cpp	/^static int  is_word_boundary_from_right(STB_TEXTEDIT_STRING* obj, int idx)      { return idx > 0 ? (is_separator(obj->TextW[idx - 1]) && !is_separator(obj->TextW[idx]) ) : 1; }$/;"	f	namespace:ImStb
iterator	imgui.h	/^    typedef value_type*         iterator;$/;"	t	struct:ImVector
kern	imstb_truetype.h	/^   int loca,head,glyf,hhea,hmtx,kern,gpos; \/\/ table locations as offset from start of .ttf$/;"	m	struct:stbtt_fontinfo
key	imgui.h	/^        ImGuiID key;$/;"	m	struct:ImGuiStorage::ImGuiStoragePair
length	imstb_textedit.h	/^   int first_char, length; \/\/ first char of row, and length$/;"	m	struct:__anon6
loca	imstb_truetype.h	/^   int loca,head,glyf,hhea,hmtx,kern,gpos; \/\/ table locations as offset from start of .ttf$/;"	m	struct:stbtt_fontinfo
main	TOOL.cpp	/^int main () {$/;"	f
main	imstb_truetype.h	/^int main(int argc, char **argv)$/;"	f
main_clipboard	imgui.cpp	/^static PasteboardRef main_clipboard = 0;$/;"	v	file:
max_size	imgui.h	/^    inline int          max_size() const                    { return 0x7FFFFFFF \/ (int)sizeof(T); }$/;"	f	struct:ImVector
max_x	imstb_truetype.h	/^   stbtt_int32 min_x, max_x, min_y, max_y;$/;"	m	struct:__anon21
max_y	imstb_truetype.h	/^   stbtt_int32 min_x, max_x, min_y, max_y;$/;"	m	struct:__anon21
min_x	imstb_truetype.h	/^   stbtt_int32 min_x, max_x, min_y, max_y;$/;"	m	struct:__anon21
min_y	imstb_truetype.h	/^   stbtt_int32 min_x, max_x, min_y, max_y;$/;"	m	struct:__anon21
my_stbtt_initfont	imstb_truetype.h	/^void my_stbtt_initfont(void)$/;"	f
my_stbtt_print	imstb_truetype.h	/^void my_stbtt_print(float x, float y, char *text)$/;"	f
next	imstb_rectpack.h	/^   stbrp_node  *next;$/;"	m	struct:stbrp_node
next	imstb_truetype.h	/^   struct stbtt__active_edge *next;$/;"	m	struct:stbtt__active_edge	typeref:struct:stbtt__active_edge::stbtt__active_edge
next	imstb_truetype.h	/^   struct stbtt__hheap_chunk *next;$/;"	m	struct:stbtt__hheap_chunk	typeref:struct:stbtt__hheap_chunk::stbtt__hheap_chunk
next_chunk	imgui_internal.h	/^    T*      next_chunk(T* p)            { size_t HDR_SZ = 4; IM_ASSERT(p >= begin() && p < end()); p = (T*)(void*)((char*)(void*)p + chunk_size(p)); if (p == (T*)(void*)((char*)end() + HDR_SZ)) return (T*)0; IM_ASSERT(p < end()); return p; }$/;"	f	struct:ImChunkStream
nodes	imstb_truetype.h	/^   void  *nodes;$/;"	m	struct:stbtt_pack_context
numGlyphs	imstb_truetype.h	/^   int numGlyphs;                     \/\/ number of glyphs, needed for range checking$/;"	m	struct:stbtt_fontinfo
num_chars	imstb_textedit.h	/^   int num_chars;$/;"	m	struct:__anon5
num_chars	imstb_truetype.h	/^   int num_chars;$/;"	m	struct:__anon11
num_nodes	imstb_rectpack.h	/^   int num_nodes;$/;"	m	struct:stbrp_context
num_remaining_in_head_chunk	imstb_truetype.h	/^   int    num_remaining_in_head_chunk;$/;"	m	struct:stbtt__hheap
num_vertices	imstb_truetype.h	/^   int num_vertices;$/;"	m	struct:__anon21
offset_from_ptr	imgui_internal.h	/^    int     offset_from_ptr(const T* p) { IM_ASSERT(p >= begin() && p < end()); const ptrdiff_t off = (const char*)p - Buf.Data; return (int)off; }$/;"	f	struct:ImChunkStream
operator *	imgui_internal.h	/^static inline ImVec2 operator*(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x * rhs.x, lhs.y * rhs.y); }$/;"	f
operator *	imgui_internal.h	/^static inline ImVec2 operator*(const ImVec2& lhs, const float rhs)              { return ImVec2(lhs.x * rhs, lhs.y * rhs); }$/;"	f
operator *	imgui_internal.h	/^static inline ImVec4 operator*(const ImVec4& lhs, const ImVec4& rhs)            { return ImVec4(lhs.x * rhs.x, lhs.y * rhs.y, lhs.z * rhs.z, lhs.w * rhs.w); }$/;"	f
operator *=	imgui_internal.h	/^static inline ImVec2& operator*=(ImVec2& lhs, const ImVec2& rhs)                { lhs.x *= rhs.x; lhs.y *= rhs.y; return lhs; }$/;"	f
operator *=	imgui_internal.h	/^static inline ImVec2& operator*=(ImVec2& lhs, const float rhs)                  { lhs.x *= rhs; lhs.y *= rhs; return lhs; }$/;"	f
operator +	imgui_internal.h	/^static inline ImVec2 operator+(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x + rhs.x, lhs.y + rhs.y); }$/;"	f
operator +	imgui_internal.h	/^static inline ImVec4 operator+(const ImVec4& lhs, const ImVec4& rhs)            { return ImVec4(lhs.x + rhs.x, lhs.y + rhs.y, lhs.z + rhs.z, lhs.w + rhs.w); }$/;"	f
operator +=	imgui_internal.h	/^static inline ImVec2& operator+=(ImVec2& lhs, const ImVec2& rhs)                { lhs.x += rhs.x; lhs.y += rhs.y; return lhs; }$/;"	f
operator -	imgui_internal.h	/^static inline ImVec2 operator-(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x - rhs.x, lhs.y - rhs.y); }$/;"	f
operator -	imgui_internal.h	/^static inline ImVec4 operator-(const ImVec4& lhs, const ImVec4& rhs)            { return ImVec4(lhs.x - rhs.x, lhs.y - rhs.y, lhs.z - rhs.z, lhs.w - rhs.w); }$/;"	f
operator -=	imgui_internal.h	/^static inline ImVec2& operator-=(ImVec2& lhs, const ImVec2& rhs)                { lhs.x -= rhs.x; lhs.y -= rhs.y; return lhs; }$/;"	f
operator /	imgui_internal.h	/^static inline ImVec2 operator\/(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x \/ rhs.x, lhs.y \/ rhs.y); }$/;"	f
operator /	imgui_internal.h	/^static inline ImVec2 operator\/(const ImVec2& lhs, const float rhs)              { return ImVec2(lhs.x \/ rhs, lhs.y \/ rhs); }$/;"	f
operator /=	imgui_internal.h	/^static inline ImVec2& operator\/=(ImVec2& lhs, const ImVec2& rhs)                { lhs.x \/= rhs.x; lhs.y \/= rhs.y; return lhs; }$/;"	f
operator /=	imgui_internal.h	/^static inline ImVec2& operator\/=(ImVec2& lhs, const float rhs)                  { lhs.x \/= rhs; lhs.y \/= rhs; return lhs; }$/;"	f
operator =	imgui.h	/^    inline ImVector<T>& operator=(const ImVector<T>& src)   { clear(); resize(src.Size); memcpy(Data, src.Data, (size_t)Size * sizeof(T)); return *this; }$/;"	f	struct:ImVector
operator ImU32	imgui.h	/^    inline operator ImU32() const                                   { return ImGui::ColorConvertFloat4ToU32(Value); }$/;"	f	struct:ImColor
operator ImVec4	imgui.h	/^    inline operator ImVec4() const                                  { return Value; }$/;"	f	struct:ImColor
operator []	imgui.h	/^    float  operator[] (size_t idx) const    { IM_ASSERT(idx <= 1); return (&x)[idx]; }    \/\/ We very rarely use this [] operator, the assert overhead is fine.$/;"	f	struct:ImVec2
operator []	imgui.h	/^    float& operator[] (size_t idx)          { IM_ASSERT(idx <= 1); return (&x)[idx]; }    \/\/ We very rarely use this [] operator, the assert overhead is fine.$/;"	f	struct:ImVec2
operator []	imgui.h	/^    inline T&           operator[](int i)                   { IM_ASSERT(i >= 0 && i < Size); return Data[i]; }$/;"	f	struct:ImVector
operator []	imgui.h	/^    inline char         operator[](int i) const { IM_ASSERT(Buf.Data != NULL); return Buf.Data[i]; }$/;"	f	struct:ImGuiTextBuffer
operator []	imgui.h	/^    inline const T&     operator[](int i) const             { IM_ASSERT(i >= 0 && i < Size); return Data[i]; }$/;"	f	struct:ImVector
operator []	imgui_internal.h	/^    inline T&           operator[](int i)           { T* p = Data + i; IM_ASSERT(p >= Data && p < DataEnd); return *p; }$/;"	f	struct:ImSpan
operator []	imgui_internal.h	/^    inline const T&     operator[](int i) const     { const T* p = Data + i; IM_ASSERT(p >= Data && p < DataEnd); return *p; }$/;"	f	struct:ImSpan
operator bool	imgui.h	/^    operator bool() const { int current_frame = ImGui::GetFrameCount(); if (RefFrame == current_frame) return false; RefFrame = current_frame; return true; }$/;"	f	struct:ImGuiOnceUponAFrame
operator delete	imgui.h	/^inline void  operator delete(void*, ImNewWrapper, void*)   {} \/\/ This is only required so we can use the symmetrical new()$/;"	f
operator new	imgui.h	/^inline void* operator new(size_t, ImNewWrapper, void* ptr) { return ptr; }$/;"	f
pack_info	imstb_truetype.h	/^   void *pack_info;$/;"	m	struct:stbtt_pack_context
padding	imstb_truetype.h	/^      unsigned char type,padding;$/;"	m	struct:__anon13
padding	imstb_truetype.h	/^   int   padding;$/;"	m	struct:stbtt_pack_context
padding1	imstb_textedit.h	/^   unsigned char padding1, padding2, padding3;$/;"	m	struct:__anon4
padding2	imstb_textedit.h	/^   unsigned char padding1, padding2, padding3;$/;"	m	struct:__anon4
padding3	imstb_textedit.h	/^   unsigned char padding1, padding2, padding3;$/;"	m	struct:__anon4
pixels	imstb_truetype.h	/^   unsigned char *pixels;$/;"	m	struct:__anon14
pixels	imstb_truetype.h	/^   unsigned char *pixels;$/;"	m	struct:stbtt_pack_context
pop_back	imgui.h	/^    inline void         pop_back()                          { IM_ASSERT(Size > 0); Size--; }$/;"	f	struct:ImVector
pos	imgui.h	/^    ImVec2  pos;$/;"	m	struct:ImDrawVert
preferred_x	imstb_textedit.h	/^   float preferred_x; \/\/ this determines where the cursor up\/down tries to seek to along x$/;"	m	struct:__anon4
prev_first	imstb_textedit.h	/^   int prev_first;  \/\/ first char of previous row$/;"	m	struct:__anon6
prev_link	imstb_rectpack.h	/^   stbrp_node **prev_link;$/;"	m	struct:__anon28
proggy_clean_ttf_compressed_data_base85	imgui_draw.cpp	/^static const char proggy_clean_ttf_compressed_data_base85[11980 + 1] =$/;"	v	file:
ptr_from_offset	imgui_internal.h	/^    T*      ptr_from_offset(int off)    { IM_ASSERT(off >= 4 && off < Buf.Size); return (T*)(void*)(Buf.Data + off); }$/;"	f	struct:ImChunkStream
push_back	imgui.h	/^    inline void         push_back(const T& v)               { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }$/;"	f	struct:ImVector
push_front	imgui.h	/^    inline void         push_front(const T& v)              { if (Size == 0) push_back(v); else insert(Data, v); }$/;"	f	struct:ImVector
pvertices	imstb_truetype.h	/^   stbtt_vertex *pvertices;$/;"	m	struct:__anon21
rect_height_compare	imstb_rectpack.h	/^static int STBRP__CDECL rect_height_compare(const void *a, const void *b)$/;"	f
rect_original_order	imstb_rectpack.h	/^static int STBRP__CDECL rect_original_order(const void *a, const void *b)$/;"	f
redo_char_point	imstb_textedit.h	/^   int undo_char_point, redo_char_point;$/;"	m	struct:__anon3
redo_point	imstb_textedit.h	/^   short undo_point, redo_point;$/;"	m	struct:__anon3
reserve	imgui.h	/^    inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }$/;"	f	struct:ImVector
reserve	imgui.h	/^    void                reserve(int capacity)   { Buf.reserve(capacity); }$/;"	f	struct:ImGuiTextBuffer
resize	imgui.h	/^    inline void         resize(int new_size)                { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }$/;"	f	struct:ImVector
resize	imgui.h	/^    inline void         resize(int new_size, const T& v)    { if (new_size > Capacity) reserve(_grow_capacity(new_size)); if (new_size > Size) for (int n = Size; n < new_size; n++) memcpy(&Data[n], &v, sizeof(v)); Size = new_size; }$/;"	f	struct:ImVector
resize_border_def	imgui.cpp	/^static const ImGuiResizeBorderDef resize_border_def[4] =$/;"	v	file:
resize_grip_def	imgui.cpp	/^static const ImGuiResizeGripDef resize_grip_def[4] =$/;"	v	file:
row_count_per_page	imstb_textedit.h	/^   int row_count_per_page;$/;"	m	struct:__anon4
s0	imstb_truetype.h	/^   float x0,y0,s0,t0; \/\/ top-left$/;"	m	struct:__anon9
s1	imstb_truetype.h	/^   float x1,y1,s1,t1; \/\/ bottom-right$/;"	m	struct:__anon9
s_current_sort_specs	imgui_demo.cpp	/^    static const ImGuiTableSortSpecs* s_current_sort_specs;$/;"	m	struct:__anon29::MyItem	file:
s_current_sort_specs	imgui_demo.cpp	/^const ImGuiTableSortSpecs* MyItem::s_current_sort_specs = NULL;$/;"	m	class:__anon29::MyItem	file:
select_end	imstb_textedit.h	/^   int select_end;$/;"	m	struct:__anon4
select_start	imstb_textedit.h	/^   int select_start;          \/\/ selection start point$/;"	m	struct:__anon4
set	imgui_internal.h	/^    inline void         set(T* data, T* data_end)   { Data = data; DataEnd = data_end; }$/;"	f	struct:ImSpan
set	imgui_internal.h	/^    inline void         set(T* data, int size)      { Data = data; DataEnd = data + size; }$/;"	f	struct:ImSpan
shrink	imgui.h	/^    inline void         shrink(int new_size)                { IM_ASSERT(new_size <= Size); Size = new_size; } \/\/ Resize a vector to a smaller size, guaranteed not to cause a reallocation$/;"	f	struct:ImVector
single_line	imstb_textedit.h	/^   unsigned char single_line;$/;"	m	struct:__anon4
size	imgui.h	/^    inline int          size() const                        { return Size; }$/;"	f	struct:ImVector
size	imgui.h	/^    int                 size() const            { return Buf.Size ? Buf.Size - 1 : 0; }$/;"	f	struct:ImGuiTextBuffer
size	imgui_internal.h	/^    inline int          size() const                { return (int)(ptrdiff_t)(DataEnd - Data); }$/;"	f	struct:ImSpan
size	imgui_internal.h	/^    int     size() const                { return Buf.Size; }$/;"	f	struct:ImChunkStream
size	imstb_truetype.h	/^   int size;$/;"	m	struct:__anon7
size_in_bytes	imgui.h	/^    inline int          size_in_bytes() const               { return Size * (int)sizeof(T); }$/;"	f	struct:ImVector
size_in_bytes	imgui_internal.h	/^    inline int          size_in_bytes() const       { return (int)(ptrdiff_t)(DataEnd - Data) * (int)sizeof(T); }$/;"	f	struct:ImSpan
skip_missing	imstb_truetype.h	/^   int   skip_missing;$/;"	m	struct:stbtt_pack_context
snprintf	imgui_demo.cpp	/^#define snprintf /;"	d	file:
split	imgui.cpp	/^void ImGuiTextFilter::ImGuiTextRange::split(char separator, ImVector<ImGuiTextRange>* out) const$/;"	f	class:ImGuiTextFilter::ImGuiTextRange
started	imstb_truetype.h	/^   int started;$/;"	m	struct:__anon21
stb__barrier_in_b	imgui_draw.cpp	/^static const unsigned char *stb__barrier_in_b;$/;"	v	file:
stb__barrier_out_b	imgui_draw.cpp	/^static unsigned char *stb__barrier_out_e, *stb__barrier_out_b;$/;"	v	file:
stb__barrier_out_e	imgui_draw.cpp	/^static unsigned char *stb__barrier_out_e, *stb__barrier_out_b;$/;"	v	file:
stb__dout	imgui_draw.cpp	/^static unsigned char *stb__dout;$/;"	v	file:
stb__in2	imgui_draw.cpp	/^#define stb__in2(/;"	d	file:
stb__in3	imgui_draw.cpp	/^#define stb__in3(/;"	d	file:
stb__in4	imgui_draw.cpp	/^#define stb__in4(/;"	d	file:
stb__lit	imgui_draw.cpp	/^static void stb__lit(const unsigned char *data, unsigned int length)$/;"	f	file:
stb__match	imgui_draw.cpp	/^static void stb__match(const unsigned char *data, unsigned int length)$/;"	f	file:
stb_adler32	imgui_draw.cpp	/^static unsigned int stb_adler32(unsigned int adler32, unsigned char *buffer, unsigned int buflen)$/;"	f	file:
stb_decompress	imgui_draw.cpp	/^static unsigned int stb_decompress(unsigned char *output, const unsigned char *i, unsigned int \/*length*\/)$/;"	f	file:
stb_decompress_length	imgui_draw.cpp	/^static unsigned int stb_decompress_length(const unsigned char *input)$/;"	f	file:
stb_decompress_token	imgui_draw.cpp	/^static const unsigned char *stb_decompress_token(const unsigned char *i)$/;"	f	file:
stb_text_create_undo_record	imstb_textedit.h	/^static StbUndoRecord *stb_text_create_undo_record(StbUndoState *state, int numchars)$/;"	f
stb_text_createundo	imstb_textedit.h	/^static STB_TEXTEDIT_CHARTYPE *stb_text_createundo(StbUndoState *state, int pos, int insert_len, int delete_len)$/;"	f
stb_text_locate_coord	imstb_textedit.h	/^static int stb_text_locate_coord(STB_TEXTEDIT_STRING *str, float x, float y)$/;"	f
stb_text_makeundo_delete	imstb_textedit.h	/^static void stb_text_makeundo_delete(STB_TEXTEDIT_STRING *str, STB_TexteditState *state, int where, int length)$/;"	f
stb_text_makeundo_insert	imstb_textedit.h	/^static void stb_text_makeundo_insert(STB_TexteditState *state, int where, int length)$/;"	f
stb_text_makeundo_replace	imstb_textedit.h	/^static void stb_text_makeundo_replace(STB_TEXTEDIT_STRING *str, STB_TexteditState *state, int where, int old_length, int new_length)$/;"	f
stb_text_redo	imstb_textedit.h	/^static void stb_text_redo(STB_TEXTEDIT_STRING *str, STB_TexteditState *state)$/;"	f
stb_text_undo	imstb_textedit.h	/^static void stb_text_undo(STB_TEXTEDIT_STRING *str, STB_TexteditState *state)$/;"	f
stb_textedit_clamp	imstb_textedit.h	/^static void stb_textedit_clamp(STB_TEXTEDIT_STRING *str, STB_TexteditState *state)$/;"	f
stb_textedit_clear_state	imstb_textedit.h	/^static void stb_textedit_clear_state(STB_TexteditState *state, int is_single_line)$/;"	f
stb_textedit_click	imstb_textedit.h	/^static void stb_textedit_click(STB_TEXTEDIT_STRING *str, STB_TexteditState *state, float x, float y)$/;"	f
stb_textedit_cut	imstb_textedit.h	/^static int stb_textedit_cut(STB_TEXTEDIT_STRING *str, STB_TexteditState *state)$/;"	f
stb_textedit_delete	imstb_textedit.h	/^static void stb_textedit_delete(STB_TEXTEDIT_STRING *str, STB_TexteditState *state, int where, int len)$/;"	f
stb_textedit_delete_selection	imstb_textedit.h	/^static void stb_textedit_delete_selection(STB_TEXTEDIT_STRING *str, STB_TexteditState *state)$/;"	f
stb_textedit_discard_redo	imstb_textedit.h	/^static void stb_textedit_discard_redo(StbUndoState *state)$/;"	f
stb_textedit_discard_undo	imstb_textedit.h	/^static void stb_textedit_discard_undo(StbUndoState *state)$/;"	f
stb_textedit_drag	imstb_textedit.h	/^static void stb_textedit_drag(STB_TEXTEDIT_STRING *str, STB_TexteditState *state, float x, float y)$/;"	f
stb_textedit_find_charpos	imstb_textedit.h	/^static void stb_textedit_find_charpos(StbFindState *find, STB_TEXTEDIT_STRING *str, int n, int single_line)$/;"	f
stb_textedit_flush_redo	imstb_textedit.h	/^static void stb_textedit_flush_redo(StbUndoState *state)$/;"	f
stb_textedit_initialize_state	imstb_textedit.h	/^static void stb_textedit_initialize_state(STB_TexteditState *state, int is_single_line)$/;"	f
stb_textedit_key	imstb_textedit.h	/^static void stb_textedit_key(STB_TEXTEDIT_STRING *str, STB_TexteditState *state, STB_TEXTEDIT_KEYTYPE key)$/;"	f
stb_textedit_move_to_first	imstb_textedit.h	/^static void stb_textedit_move_to_first(STB_TexteditState *state)$/;"	f
stb_textedit_move_to_last	imstb_textedit.h	/^static void stb_textedit_move_to_last(STB_TEXTEDIT_STRING *str, STB_TexteditState *state)$/;"	f
stb_textedit_move_to_word_next	imstb_textedit.h	/^static int stb_textedit_move_to_word_next( STB_TEXTEDIT_STRING *str, int c )$/;"	f
stb_textedit_move_to_word_previous	imstb_textedit.h	/^static int stb_textedit_move_to_word_previous( STB_TEXTEDIT_STRING *str, int c )$/;"	f
stb_textedit_paste	imstb_textedit.h	/^static int stb_textedit_paste(STB_TEXTEDIT_STRING *str, STB_TexteditState *state, STB_TEXTEDIT_CHARTYPE const *ctext, int len)$/;"	f
stb_textedit_paste_internal	imstb_textedit.h	/^static int stb_textedit_paste_internal(STB_TEXTEDIT_STRING *str, STB_TexteditState *state, STB_TEXTEDIT_CHARTYPE *text, int len)$/;"	f
stb_textedit_prep_selection_at_cursor	imstb_textedit.h	/^static void stb_textedit_prep_selection_at_cursor(STB_TexteditState *state)$/;"	f
stb_textedit_replace	imgui_widgets.cpp	/^static void stb_textedit_replace(STB_TEXTEDIT_STRING* str, STB_TexteditState* state, const STB_TEXTEDIT_CHARTYPE* text, int text_len)$/;"	f	namespace:ImStb
stb_textedit_sortselection	imstb_textedit.h	/^static void stb_textedit_sortselection(STB_TexteditState *state)$/;"	f
stbrp__findresult	imstb_rectpack.h	/^} stbrp__findresult;$/;"	t	typeref:struct:__anon28
stbrp__skyline_find_best_pos	imstb_rectpack.h	/^static stbrp__findresult stbrp__skyline_find_best_pos(stbrp_context *c, int width, int height)$/;"	f
stbrp__skyline_find_min_y	imstb_rectpack.h	/^static int stbrp__skyline_find_min_y(stbrp_context *c, stbrp_node *first, int x0, int width, int *pwaste)$/;"	f
stbrp__skyline_pack_rectangle	imstb_rectpack.h	/^static stbrp__findresult stbrp__skyline_pack_rectangle(stbrp_context *context, int width, int height)$/;"	f
stbrp_context	imstb_rectpack.h	/^struct stbrp_context$/;"	s
stbrp_context	imstb_rectpack.h	/^typedef struct stbrp_context stbrp_context;$/;"	t	typeref:struct:stbrp_context
stbrp_context	imstb_truetype.h	/^} stbrp_context;$/;"	t	typeref:struct:__anon23
stbrp_coord	imstb_rectpack.h	/^typedef int            stbrp_coord;$/;"	t
stbrp_coord	imstb_rectpack.h	/^typedef unsigned short stbrp_coord;$/;"	t
stbrp_coord	imstb_truetype.h	/^typedef int stbrp_coord;$/;"	t
stbrp_init_target	imstb_rectpack.h	/^STBRP_DEF void stbrp_init_target(stbrp_context *context, int width, int height, stbrp_node *nodes, int num_nodes)$/;"	f
stbrp_init_target	imstb_truetype.h	/^static void stbrp_init_target(stbrp_context *con, int pw, int ph, stbrp_node *nodes, int num_nodes)$/;"	f
stbrp_node	imstb_rectpack.h	/^struct stbrp_node$/;"	s
stbrp_node	imstb_rectpack.h	/^typedef struct stbrp_node    stbrp_node;$/;"	t	typeref:struct:stbrp_node
stbrp_node	imstb_truetype.h	/^} stbrp_node;$/;"	t	typeref:struct:__anon24
stbrp_pack_rects	imstb_rectpack.h	/^STBRP_DEF int stbrp_pack_rects(stbrp_context *context, stbrp_rect *rects, int num_rects)$/;"	f
stbrp_pack_rects	imstb_truetype.h	/^static void stbrp_pack_rects(stbrp_context *con, stbrp_rect *rects, int num_rects)$/;"	f
stbrp_rect	imstb_rectpack.h	/^struct stbrp_rect$/;"	s
stbrp_rect	imstb_rectpack.h	/^typedef struct stbrp_rect    stbrp_rect;$/;"	t	typeref:struct:stbrp_rect
stbrp_rect	imstb_truetype.h	/^struct stbrp_rect$/;"	s
stbrp_rect	imstb_truetype.h	/^typedef struct stbrp_rect stbrp_rect;$/;"	t	typeref:struct:stbrp_rect
stbrp_setup_allow_out_of_mem	imstb_rectpack.h	/^STBRP_DEF void stbrp_setup_allow_out_of_mem(stbrp_context *context, int allow_out_of_mem)$/;"	f
stbrp_setup_heuristic	imstb_rectpack.h	/^STBRP_DEF void stbrp_setup_heuristic(stbrp_context *context, int heuristic)$/;"	f
stbtt_BakeFontBitmap	imstb_truetype.h	/^STBTT_DEF int stbtt_BakeFontBitmap(const unsigned char *data, int offset,$/;"	f
stbtt_BakeFontBitmap_internal	imstb_truetype.h	/^static int stbtt_BakeFontBitmap_internal(unsigned char *data, int offset,  \/\/ font location (use offset=0 for plain .ttf)$/;"	f
stbtt_CompareUTF8toUTF16_bigendian	imstb_truetype.h	/^STBTT_DEF int stbtt_CompareUTF8toUTF16_bigendian(const char *s1, int len1, const char *s2, int len2)$/;"	f
stbtt_CompareUTF8toUTF16_bigendian_internal	imstb_truetype.h	/^static int stbtt_CompareUTF8toUTF16_bigendian_internal(char *s1, int len1, char *s2, int len2) $/;"	f
stbtt_FindGlyphIndex	imstb_truetype.h	/^STBTT_DEF int stbtt_FindGlyphIndex(const stbtt_fontinfo *info, int unicode_codepoint)$/;"	f
stbtt_FindMatchingFont	imstb_truetype.h	/^STBTT_DEF int stbtt_FindMatchingFont(const unsigned char *fontdata, const char *name, int flags)$/;"	f
stbtt_FindMatchingFont_internal	imstb_truetype.h	/^static int stbtt_FindMatchingFont_internal(unsigned char *font_collection, char *name_utf8, stbtt_int32 flags)$/;"	f
stbtt_FlattenCurves	imstb_truetype.h	/^static stbtt__point *stbtt_FlattenCurves(stbtt_vertex *vertices, int num_verts, float objspace_flatness, int **contour_lengths, int *num_contours, void *userdata)$/;"	f
stbtt_FreeBitmap	imstb_truetype.h	/^STBTT_DEF void stbtt_FreeBitmap(unsigned char *bitmap, void *userdata)$/;"	f
stbtt_FreeSDF	imstb_truetype.h	/^STBTT_DEF void stbtt_FreeSDF(unsigned char *bitmap, void *userdata)$/;"	f
stbtt_FreeShape	imstb_truetype.h	/^STBTT_DEF void stbtt_FreeShape(const stbtt_fontinfo *info, stbtt_vertex *v)$/;"	f
stbtt_GetBakedQuad	imstb_truetype.h	/^STBTT_DEF void stbtt_GetBakedQuad(const stbtt_bakedchar *chardata, int pw, int ph, int char_index, float *xpos, float *ypos, stbtt_aligned_quad *q, int opengl_fillrule)$/;"	f
stbtt_GetCodepointBitmap	imstb_truetype.h	/^STBTT_DEF unsigned char *stbtt_GetCodepointBitmap(const stbtt_fontinfo *info, float scale_x, float scale_y, int codepoint, int *width, int *height, int *xoff, int *yoff)$/;"	f
stbtt_GetCodepointBitmapBox	imstb_truetype.h	/^STBTT_DEF void stbtt_GetCodepointBitmapBox(const stbtt_fontinfo *font, int codepoint, float scale_x, float scale_y, int *ix0, int *iy0, int *ix1, int *iy1)$/;"	f
stbtt_GetCodepointBitmapBoxSubpixel	imstb_truetype.h	/^STBTT_DEF void stbtt_GetCodepointBitmapBoxSubpixel(const stbtt_fontinfo *font, int codepoint, float scale_x, float scale_y, float shift_x, float shift_y, int *ix0, int *iy0, int *ix1, int *iy1)$/;"	f
stbtt_GetCodepointBitmapSubpixel	imstb_truetype.h	/^STBTT_DEF unsigned char *stbtt_GetCodepointBitmapSubpixel(const stbtt_fontinfo *info, float scale_x, float scale_y, float shift_x, float shift_y, int codepoint, int *width, int *height, int *xoff, int *yoff)$/;"	f
stbtt_GetCodepointBox	imstb_truetype.h	/^STBTT_DEF int stbtt_GetCodepointBox(const stbtt_fontinfo *info, int codepoint, int *x0, int *y0, int *x1, int *y1)$/;"	f
stbtt_GetCodepointHMetrics	imstb_truetype.h	/^STBTT_DEF void stbtt_GetCodepointHMetrics(const stbtt_fontinfo *info, int codepoint, int *advanceWidth, int *leftSideBearing)$/;"	f
stbtt_GetCodepointKernAdvance	imstb_truetype.h	/^STBTT_DEF int  stbtt_GetCodepointKernAdvance(const stbtt_fontinfo *info, int ch1, int ch2)$/;"	f
stbtt_GetCodepointSDF	imstb_truetype.h	/^STBTT_DEF unsigned char * stbtt_GetCodepointSDF(const stbtt_fontinfo *info, float scale, int codepoint, int padding, unsigned char onedge_value, float pixel_dist_scale, int *width, int *height, int *xoff, int *yoff)$/;"	f
stbtt_GetCodepointShape	imstb_truetype.h	/^STBTT_DEF int stbtt_GetCodepointShape(const stbtt_fontinfo *info, int unicode_codepoint, stbtt_vertex **vertices)$/;"	f
stbtt_GetFontBoundingBox	imstb_truetype.h	/^STBTT_DEF void stbtt_GetFontBoundingBox(const stbtt_fontinfo *info, int *x0, int *y0, int *x1, int *y1)$/;"	f
stbtt_GetFontNameString	imstb_truetype.h	/^STBTT_DEF const char *stbtt_GetFontNameString(const stbtt_fontinfo *font, int *length, int platformID, int encodingID, int languageID, int nameID)$/;"	f
stbtt_GetFontOffsetForIndex	imstb_truetype.h	/^STBTT_DEF int stbtt_GetFontOffsetForIndex(const unsigned char *data, int index)$/;"	f
stbtt_GetFontOffsetForIndex_internal	imstb_truetype.h	/^static int stbtt_GetFontOffsetForIndex_internal(unsigned char *font_collection, int index)$/;"	f
stbtt_GetFontVMetrics	imstb_truetype.h	/^STBTT_DEF void stbtt_GetFontVMetrics(const stbtt_fontinfo *info, int *ascent, int *descent, int *lineGap)$/;"	f
stbtt_GetFontVMetricsOS2	imstb_truetype.h	/^STBTT_DEF int  stbtt_GetFontVMetricsOS2(const stbtt_fontinfo *info, int *typoAscent, int *typoDescent, int *typoLineGap)$/;"	f
stbtt_GetGlyphBitmap	imstb_truetype.h	/^STBTT_DEF unsigned char *stbtt_GetGlyphBitmap(const stbtt_fontinfo *info, float scale_x, float scale_y, int glyph, int *width, int *height, int *xoff, int *yoff)$/;"	f
stbtt_GetGlyphBitmapBox	imstb_truetype.h	/^STBTT_DEF void stbtt_GetGlyphBitmapBox(const stbtt_fontinfo *font, int glyph, float scale_x, float scale_y, int *ix0, int *iy0, int *ix1, int *iy1)$/;"	f
stbtt_GetGlyphBitmapBoxSubpixel	imstb_truetype.h	/^STBTT_DEF void stbtt_GetGlyphBitmapBoxSubpixel(const stbtt_fontinfo *font, int glyph, float scale_x, float scale_y,float shift_x, float shift_y, int *ix0, int *iy0, int *ix1, int *iy1)$/;"	f
stbtt_GetGlyphBitmapSubpixel	imstb_truetype.h	/^STBTT_DEF unsigned char *stbtt_GetGlyphBitmapSubpixel(const stbtt_fontinfo *info, float scale_x, float scale_y, float shift_x, float shift_y, int glyph, int *width, int *height, int *xoff, int *yoff)$/;"	f
stbtt_GetGlyphBox	imstb_truetype.h	/^STBTT_DEF int stbtt_GetGlyphBox(const stbtt_fontinfo *info, int glyph_index, int *x0, int *y0, int *x1, int *y1)$/;"	f
stbtt_GetGlyphHMetrics	imstb_truetype.h	/^STBTT_DEF void stbtt_GetGlyphHMetrics(const stbtt_fontinfo *info, int glyph_index, int *advanceWidth, int *leftSideBearing)$/;"	f
stbtt_GetGlyphKernAdvance	imstb_truetype.h	/^STBTT_DEF int  stbtt_GetGlyphKernAdvance(const stbtt_fontinfo *info, int g1, int g2)$/;"	f
stbtt_GetGlyphSDF	imstb_truetype.h	/^STBTT_DEF unsigned char * stbtt_GetGlyphSDF(const stbtt_fontinfo *info, float scale, int glyph, int padding, unsigned char onedge_value, float pixel_dist_scale, int *width, int *height, int *xoff, int *yoff)$/;"	f
stbtt_GetGlyphShape	imstb_truetype.h	/^STBTT_DEF int stbtt_GetGlyphShape(const stbtt_fontinfo *info, int glyph_index, stbtt_vertex **pvertices)$/;"	f
stbtt_GetNumberOfFonts	imstb_truetype.h	/^STBTT_DEF int stbtt_GetNumberOfFonts(const unsigned char *data)$/;"	f
stbtt_GetNumberOfFonts_internal	imstb_truetype.h	/^static int stbtt_GetNumberOfFonts_internal(unsigned char *font_collection)$/;"	f
stbtt_GetPackedQuad	imstb_truetype.h	/^STBTT_DEF void stbtt_GetPackedQuad(const stbtt_packedchar *chardata, int pw, int ph, int char_index, float *xpos, float *ypos, stbtt_aligned_quad *q, int align_to_integer)$/;"	f
stbtt_GetScaledFontVMetrics	imstb_truetype.h	/^STBTT_DEF void stbtt_GetScaledFontVMetrics(const unsigned char *fontdata, int index, float size, float *ascent, float *descent, float *lineGap)$/;"	f
stbtt_InitFont	imstb_truetype.h	/^STBTT_DEF int stbtt_InitFont(stbtt_fontinfo *info, const unsigned char *data, int offset)$/;"	f
stbtt_InitFont_internal	imstb_truetype.h	/^static int stbtt_InitFont_internal(stbtt_fontinfo *info, unsigned char *data, int fontstart)$/;"	f
stbtt_IsGlyphEmpty	imstb_truetype.h	/^STBTT_DEF int stbtt_IsGlyphEmpty(const stbtt_fontinfo *info, int glyph_index)$/;"	f
stbtt_MakeCodepointBitmap	imstb_truetype.h	/^STBTT_DEF void stbtt_MakeCodepointBitmap(const stbtt_fontinfo *info, unsigned char *output, int out_w, int out_h, int out_stride, float scale_x, float scale_y, int codepoint)$/;"	f
stbtt_MakeCodepointBitmapSubpixel	imstb_truetype.h	/^STBTT_DEF void stbtt_MakeCodepointBitmapSubpixel(const stbtt_fontinfo *info, unsigned char *output, int out_w, int out_h, int out_stride, float scale_x, float scale_y, float shift_x, float shift_y, int codepoint)$/;"	f
stbtt_MakeCodepointBitmapSubpixelPrefilter	imstb_truetype.h	/^STBTT_DEF void stbtt_MakeCodepointBitmapSubpixelPrefilter(const stbtt_fontinfo *info, unsigned char *output, int out_w, int out_h, int out_stride, float scale_x, float scale_y, float shift_x, float shift_y, int oversample_x, int oversample_y, float *sub_x, float *sub_y, int codepoint)$/;"	f
stbtt_MakeGlyphBitmap	imstb_truetype.h	/^STBTT_DEF void stbtt_MakeGlyphBitmap(const stbtt_fontinfo *info, unsigned char *output, int out_w, int out_h, int out_stride, float scale_x, float scale_y, int glyph)$/;"	f
stbtt_MakeGlyphBitmapSubpixel	imstb_truetype.h	/^STBTT_DEF void stbtt_MakeGlyphBitmapSubpixel(const stbtt_fontinfo *info, unsigned char *output, int out_w, int out_h, int out_stride, float scale_x, float scale_y, float shift_x, float shift_y, int glyph)$/;"	f
stbtt_MakeGlyphBitmapSubpixelPrefilter	imstb_truetype.h	/^STBTT_DEF void stbtt_MakeGlyphBitmapSubpixelPrefilter(const stbtt_fontinfo *info, unsigned char *output, int out_w, int out_h, int out_stride, float scale_x, float scale_y, float shift_x, float shift_y, int prefilter_x, int prefilter_y, float *sub_x, float *sub_y, int glyph)$/;"	f
stbtt_PackBegin	imstb_truetype.h	/^STBTT_DEF int stbtt_PackBegin(stbtt_pack_context *spc, unsigned char *pixels, int pw, int ph, int stride_in_bytes, int padding, void *alloc_context)$/;"	f
stbtt_PackEnd	imstb_truetype.h	/^STBTT_DEF void stbtt_PackEnd  (stbtt_pack_context *spc)$/;"	f
stbtt_PackFontRange	imstb_truetype.h	/^STBTT_DEF int stbtt_PackFontRange(stbtt_pack_context *spc, const unsigned char *fontdata, int font_index, float font_size,$/;"	f
stbtt_PackFontRanges	imstb_truetype.h	/^STBTT_DEF int stbtt_PackFontRanges(stbtt_pack_context *spc, const unsigned char *fontdata, int font_index, stbtt_pack_range *ranges, int num_ranges)$/;"	f
stbtt_PackFontRangesGatherRects	imstb_truetype.h	/^STBTT_DEF int stbtt_PackFontRangesGatherRects(stbtt_pack_context *spc, const stbtt_fontinfo *info, stbtt_pack_range *ranges, int num_ranges, stbrp_rect *rects)$/;"	f
stbtt_PackFontRangesPackRects	imstb_truetype.h	/^STBTT_DEF void stbtt_PackFontRangesPackRects(stbtt_pack_context *spc, stbrp_rect *rects, int num_rects)$/;"	f
stbtt_PackFontRangesRenderIntoRects	imstb_truetype.h	/^STBTT_DEF int stbtt_PackFontRangesRenderIntoRects(stbtt_pack_context *spc, const stbtt_fontinfo *info, stbtt_pack_range *ranges, int num_ranges, stbrp_rect *rects)$/;"	f
stbtt_PackSetOversampling	imstb_truetype.h	/^STBTT_DEF void stbtt_PackSetOversampling(stbtt_pack_context *spc, unsigned int h_oversample, unsigned int v_oversample)$/;"	f
stbtt_PackSetSkipMissingCodepoints	imstb_truetype.h	/^STBTT_DEF void stbtt_PackSetSkipMissingCodepoints(stbtt_pack_context *spc, int skip)$/;"	f
stbtt_Rasterize	imstb_truetype.h	/^STBTT_DEF void stbtt_Rasterize(stbtt__bitmap *result, float flatness_in_pixels, stbtt_vertex *vertices, int num_verts, float scale_x, float scale_y, float shift_x, float shift_y, int x_off, int y_off, int invert, void *userdata)$/;"	f
stbtt_ScaleForMappingEmToPixels	imstb_truetype.h	/^STBTT_DEF float stbtt_ScaleForMappingEmToPixels(const stbtt_fontinfo *info, float pixels)$/;"	f
stbtt_ScaleForPixelHeight	imstb_truetype.h	/^STBTT_DEF float stbtt_ScaleForPixelHeight(const stbtt_fontinfo *info, float height)$/;"	f
stbtt__CompareUTF8toUTF16_bigendian_prefix	imstb_truetype.h	/^static stbtt_int32 stbtt__CompareUTF8toUTF16_bigendian_prefix(stbtt_uint8 *s1, stbtt_int32 len1, stbtt_uint8 *s2, stbtt_int32 len2) $/;"	f
stbtt__GetCoverageIndex	imstb_truetype.h	/^static stbtt_int32  stbtt__GetCoverageIndex(stbtt_uint8 *coverageTable, int glyph)$/;"	f
stbtt__GetGlyfOffset	imstb_truetype.h	/^static int stbtt__GetGlyfOffset(const stbtt_fontinfo *info, int glyph_index)$/;"	f
stbtt__GetGlyphClass	imstb_truetype.h	/^static stbtt_int32  stbtt__GetGlyphClass(stbtt_uint8 *classDefTable, int glyph)$/;"	f
stbtt__GetGlyphGPOSInfoAdvance	imstb_truetype.h	/^static stbtt_int32  stbtt__GetGlyphGPOSInfoAdvance(const stbtt_fontinfo *info, int glyph1, int glyph2)$/;"	f
stbtt__GetGlyphInfoT2	imstb_truetype.h	/^static int stbtt__GetGlyphInfoT2(const stbtt_fontinfo *info, int glyph_index, int *x0, int *y0, int *x1, int *y1)$/;"	f
stbtt__GetGlyphKernInfoAdvance	imstb_truetype.h	/^static int  stbtt__GetGlyphKernInfoAdvance(const stbtt_fontinfo *info, int glyph1, int glyph2)$/;"	f
stbtt__GetGlyphShapeT2	imstb_truetype.h	/^static int stbtt__GetGlyphShapeT2(const stbtt_fontinfo *info, int glyph_index, stbtt_vertex **pvertices)$/;"	f
stbtt__GetGlyphShapeTT	imstb_truetype.h	/^static int stbtt__GetGlyphShapeTT(const stbtt_fontinfo *info, int glyph_index, stbtt_vertex **pvertices)$/;"	f
stbtt__active_edge	imstb_truetype.h	/^typedef struct stbtt__active_edge$/;"	s
stbtt__active_edge	imstb_truetype.h	/^} stbtt__active_edge;$/;"	t	typeref:struct:stbtt__active_edge
stbtt__add_point	imstb_truetype.h	/^static void stbtt__add_point(stbtt__point *points, int n, float x, float y)$/;"	f
stbtt__bitmap	imstb_truetype.h	/^} stbtt__bitmap;$/;"	t	typeref:struct:__anon14
stbtt__buf	imstb_truetype.h	/^} stbtt__buf;$/;"	t	typeref:struct:__anon7
stbtt__buf_get	imstb_truetype.h	/^static stbtt_uint32 stbtt__buf_get(stbtt__buf *b, int n)$/;"	f
stbtt__buf_get16	imstb_truetype.h	/^#define stbtt__buf_get16(/;"	d
stbtt__buf_get32	imstb_truetype.h	/^#define stbtt__buf_get32(/;"	d
stbtt__buf_get8	imstb_truetype.h	/^static stbtt_uint8 stbtt__buf_get8(stbtt__buf *b)$/;"	f
stbtt__buf_peek8	imstb_truetype.h	/^static stbtt_uint8 stbtt__buf_peek8(stbtt__buf *b)$/;"	f
stbtt__buf_range	imstb_truetype.h	/^static stbtt__buf stbtt__buf_range(const stbtt__buf *b, int o, int s)$/;"	f
stbtt__buf_seek	imstb_truetype.h	/^static void stbtt__buf_seek(stbtt__buf *b, int o)$/;"	f
stbtt__buf_skip	imstb_truetype.h	/^static void stbtt__buf_skip(stbtt__buf *b, int o)$/;"	f
stbtt__cff_get_index	imstb_truetype.h	/^static stbtt__buf stbtt__cff_get_index(stbtt__buf *b)$/;"	f
stbtt__cff_index_count	imstb_truetype.h	/^static int stbtt__cff_index_count(stbtt__buf *b)$/;"	f
stbtt__cff_index_get	imstb_truetype.h	/^static stbtt__buf stbtt__cff_index_get(stbtt__buf b, int i)$/;"	f
stbtt__cff_int	imstb_truetype.h	/^static stbtt_uint32 stbtt__cff_int(stbtt__buf *b)$/;"	f
stbtt__cff_skip_operand	imstb_truetype.h	/^static void stbtt__cff_skip_operand(stbtt__buf *b) {$/;"	f
stbtt__check_size16	imstb_truetype.h	/^   typedef char stbtt__check_size16[sizeof(stbtt_int16)==2 ? 1 : -1];$/;"	t
stbtt__check_size32	imstb_truetype.h	/^   typedef char stbtt__check_size32[sizeof(stbtt_int32)==4 ? 1 : -1];$/;"	t
stbtt__cid_get_glyph_subrs	imstb_truetype.h	/^static stbtt__buf stbtt__cid_get_glyph_subrs(const stbtt_fontinfo *info, int glyph_index)$/;"	f
stbtt__close_shape	imstb_truetype.h	/^static int stbtt__close_shape(stbtt_vertex *vertices, int num_vertices, int was_off, int start_off,$/;"	f
stbtt__compute_crossings_x	imstb_truetype.h	/^static int stbtt__compute_crossings_x(float x, float y, int nverts, stbtt_vertex *verts)$/;"	f
stbtt__csctx	imstb_truetype.h	/^} stbtt__csctx;$/;"	t	typeref:struct:__anon21
stbtt__csctx_close_shape	imstb_truetype.h	/^static void stbtt__csctx_close_shape(stbtt__csctx *ctx)$/;"	f
stbtt__csctx_rccurve_to	imstb_truetype.h	/^static void stbtt__csctx_rccurve_to(stbtt__csctx *ctx, float dx1, float dy1, float dx2, float dy2, float dx3, float dy3)$/;"	f
stbtt__csctx_rline_to	imstb_truetype.h	/^static void stbtt__csctx_rline_to(stbtt__csctx *ctx, float dx, float dy)$/;"	f
stbtt__csctx_rmove_to	imstb_truetype.h	/^static void stbtt__csctx_rmove_to(stbtt__csctx *ctx, float dx, float dy)$/;"	f
stbtt__csctx_v	imstb_truetype.h	/^static void stbtt__csctx_v(stbtt__csctx *c, stbtt_uint8 type, stbtt_int32 x, stbtt_int32 y, stbtt_int32 cx, stbtt_int32 cy, stbtt_int32 cx1, stbtt_int32 cy1)$/;"	f
stbtt__cuberoot	imstb_truetype.h	/^static float stbtt__cuberoot( float x )$/;"	f
stbtt__dict_get	imstb_truetype.h	/^static stbtt__buf stbtt__dict_get(stbtt__buf *b, int key)$/;"	f
stbtt__dict_get_ints	imstb_truetype.h	/^static void stbtt__dict_get_ints(stbtt__buf *b, int key, int outcount, stbtt_uint32 *out)$/;"	f
stbtt__edge	imstb_truetype.h	/^typedef struct stbtt__edge {$/;"	s
stbtt__edge	imstb_truetype.h	/^} stbtt__edge;$/;"	t	typeref:struct:stbtt__edge
stbtt__fill_active_edges	imstb_truetype.h	/^static void stbtt__fill_active_edges(unsigned char *scanline, int len, stbtt__active_edge *e, int max_weight)$/;"	f
stbtt__fill_active_edges_new	imstb_truetype.h	/^static void stbtt__fill_active_edges_new(float *scanline, float *scanline_fill, int len, stbtt__active_edge *e, float y_top)$/;"	f
stbtt__find_table	imstb_truetype.h	/^static stbtt_uint32 stbtt__find_table(stbtt_uint8 *data, stbtt_uint32 fontstart, const char *tag)$/;"	f
stbtt__get_subr	imstb_truetype.h	/^static stbtt__buf stbtt__get_subr(stbtt__buf idx, int n)$/;"	f
stbtt__get_subrs	imstb_truetype.h	/^static stbtt__buf stbtt__get_subrs(stbtt__buf cff, stbtt__buf fontdict)$/;"	f
stbtt__h_prefilter	imstb_truetype.h	/^static void stbtt__h_prefilter(unsigned char *pixels, int w, int h, int stride_in_bytes, unsigned int kernel_width)$/;"	f
stbtt__handle_clipped_edge	imstb_truetype.h	/^static void stbtt__handle_clipped_edge(float *scanline, int x, stbtt__active_edge *e, float x0, float y0, float x1, float y1)$/;"	f
stbtt__hheap	imstb_truetype.h	/^typedef struct stbtt__hheap$/;"	s
stbtt__hheap	imstb_truetype.h	/^} stbtt__hheap;$/;"	t	typeref:struct:stbtt__hheap
stbtt__hheap_alloc	imstb_truetype.h	/^static void *stbtt__hheap_alloc(stbtt__hheap *hh, size_t size, void *userdata)$/;"	f
stbtt__hheap_chunk	imstb_truetype.h	/^typedef struct stbtt__hheap_chunk$/;"	s
stbtt__hheap_chunk	imstb_truetype.h	/^} stbtt__hheap_chunk;$/;"	t	typeref:struct:stbtt__hheap_chunk
stbtt__hheap_cleanup	imstb_truetype.h	/^static void stbtt__hheap_cleanup(stbtt__hheap *hh, void *userdata)$/;"	f
stbtt__hheap_free	imstb_truetype.h	/^static void stbtt__hheap_free(stbtt__hheap *hh, void *p)$/;"	f
stbtt__isfont	imstb_truetype.h	/^static int stbtt__isfont(stbtt_uint8 *font)$/;"	f
stbtt__matches	imstb_truetype.h	/^static int stbtt__matches(stbtt_uint8 *fc, stbtt_uint32 offset, stbtt_uint8 *name, stbtt_int32 flags)$/;"	f
stbtt__matchpair	imstb_truetype.h	/^static int stbtt__matchpair(stbtt_uint8 *fc, stbtt_uint32 nm, stbtt_uint8 *name, stbtt_int32 nlen, stbtt_int32 target_id, stbtt_int32 next_id)$/;"	f
stbtt__new_active	imstb_truetype.h	/^static stbtt__active_edge *stbtt__new_active(stbtt__hheap *hh, stbtt__edge *e, int off_x, float start_point, void *userdata)$/;"	f
stbtt__new_buf	imstb_truetype.h	/^static stbtt__buf stbtt__new_buf(const void *p, size_t size)$/;"	f
stbtt__oversample_shift	imstb_truetype.h	/^static float stbtt__oversample_shift(int oversample)$/;"	f
stbtt__point	imstb_truetype.h	/^} stbtt__point;$/;"	t	typeref:struct:__anon22
stbtt__rasterize	imstb_truetype.h	/^static void stbtt__rasterize(stbtt__bitmap *result, stbtt__point *pts, int *wcount, int windings, float scale_x, float scale_y, float shift_x, float shift_y, int off_x, int off_y, int invert, void *userdata)$/;"	f
stbtt__rasterize_sorted_edges	imstb_truetype.h	/^static void stbtt__rasterize_sorted_edges(stbtt__bitmap *result, stbtt__edge *e, int n, int vsubsample, int off_x, int off_y, void *userdata)$/;"	f
stbtt__ray_intersect_bezier	imstb_truetype.h	/^static int stbtt__ray_intersect_bezier(float orig[2], float ray[2], float q0[2], float q1[2], float q2[2], float hits[2][2])$/;"	f
stbtt__run_charstring	imstb_truetype.h	/^static int stbtt__run_charstring(const stbtt_fontinfo *info, int glyph_index, stbtt__csctx *c)$/;"	f
stbtt__solve_cubic	imstb_truetype.h	/^static int stbtt__solve_cubic(float a, float b, float c, float* r)$/;"	f
stbtt__sort_edges	imstb_truetype.h	/^static void stbtt__sort_edges(stbtt__edge *p, int n)$/;"	f
stbtt__sort_edges_ins_sort	imstb_truetype.h	/^static void stbtt__sort_edges_ins_sort(stbtt__edge *p, int n)$/;"	f
stbtt__sort_edges_quicksort	imstb_truetype.h	/^static void stbtt__sort_edges_quicksort(stbtt__edge *p, int n)$/;"	f
stbtt__tesselate_cubic	imstb_truetype.h	/^static void stbtt__tesselate_cubic(stbtt__point *points, int *num_points, float x0, float y0, float x1, float y1, float x2, float y2, float x3, float y3, float objspace_flatness_squared, int n)$/;"	f
stbtt__tesselate_curve	imstb_truetype.h	/^static int stbtt__tesselate_curve(stbtt__point *points, int *num_points, float x0, float y0, float x1, float y1, float x2, float y2, float objspace_flatness_squared, int n)$/;"	f
stbtt__test_oversample_pow2	imstb_truetype.h	/^typedef int stbtt__test_oversample_pow2[(STBTT_MAX_OVERSAMPLE & (STBTT_MAX_OVERSAMPLE-1)) == 0 ? 1 : -1];$/;"	t
stbtt__track_vertex	imstb_truetype.h	/^static void stbtt__track_vertex(stbtt__csctx *c, stbtt_int32 x, stbtt_int32 y)$/;"	f
stbtt__v_prefilter	imstb_truetype.h	/^static void stbtt__v_prefilter(unsigned char *pixels, int w, int h, int stride_in_bytes, unsigned int kernel_width)$/;"	f
stbtt_aligned_quad	imstb_truetype.h	/^} stbtt_aligned_quad;$/;"	t	typeref:struct:__anon9
stbtt_bakedchar	imstb_truetype.h	/^} stbtt_bakedchar;$/;"	t	typeref:struct:__anon8
stbtt_fontinfo	imstb_truetype.h	/^struct stbtt_fontinfo$/;"	s
stbtt_fontinfo	imstb_truetype.h	/^typedef struct stbtt_fontinfo stbtt_fontinfo;$/;"	t	typeref:struct:stbtt_fontinfo
stbtt_int16	imstb_truetype.h	/^   typedef signed   short  stbtt_int16;$/;"	t
stbtt_int32	imstb_truetype.h	/^   typedef signed   int    stbtt_int32;$/;"	t
stbtt_int8	imstb_truetype.h	/^   typedef signed   char   stbtt_int8;$/;"	t
stbtt_pack_context	imstb_truetype.h	/^struct stbtt_pack_context {$/;"	s
stbtt_pack_context	imstb_truetype.h	/^typedef struct stbtt_pack_context stbtt_pack_context;$/;"	t	typeref:struct:stbtt_pack_context
stbtt_pack_range	imstb_truetype.h	/^} stbtt_pack_range;$/;"	t	typeref:struct:__anon11
stbtt_packedchar	imstb_truetype.h	/^} stbtt_packedchar;$/;"	t	typeref:struct:__anon10
stbtt_setvertex	imstb_truetype.h	/^static void stbtt_setvertex(stbtt_vertex *v, stbtt_uint8 type, stbtt_int32 x, stbtt_int32 y, stbtt_int32 cx, stbtt_int32 cy)$/;"	f
stbtt_tag	imstb_truetype.h	/^#define stbtt_tag(/;"	d
stbtt_tag4	imstb_truetype.h	/^#define stbtt_tag4(/;"	d
stbtt_uint16	imstb_truetype.h	/^   typedef unsigned short  stbtt_uint16;$/;"	t
stbtt_uint32	imstb_truetype.h	/^   typedef unsigned int    stbtt_uint32;$/;"	t
stbtt_uint8	imstb_truetype.h	/^   typedef unsigned char   stbtt_uint8;$/;"	t
stbtt_vertex	imstb_truetype.h	/^   } stbtt_vertex;$/;"	t	typeref:struct:__anon13
stbtt_vertex_type	imstb_truetype.h	/^   #define stbtt_vertex_type /;"	d
stride	imstb_truetype.h	/^   int w,h,stride;$/;"	m	struct:__anon14
stride_in_bytes	imstb_truetype.h	/^   int   stride_in_bytes;$/;"	m	struct:stbtt_pack_context
subrs	imstb_truetype.h	/^   stbtt__buf subrs;                  \/\/ private charstring subroutines index$/;"	m	struct:stbtt_fontinfo
swap	imgui.h	/^    inline void         swap(ImVector<T>& rhs)              { int rhs_size = rhs.Size; rhs.Size = Size; Size = rhs_size; int rhs_cap = rhs.Capacity; rhs.Capacity = Capacity; Capacity = rhs_cap; T* rhs_data = rhs.Data; rhs.Data = Data; Data = rhs_data; }$/;"	f	struct:ImVector
swap	imgui_internal.h	/^    void    swap(ImChunkStream<T>& rhs) { rhs.Buf.swap(Buf); }$/;"	f	struct:ImChunkStream
sy	imstb_truetype.h	/^   float sy;$/;"	m	struct:stbtt__active_edge
t0	imstb_truetype.h	/^   float x0,y0,s0,t0; \/\/ top-left$/;"	m	struct:__anon9
t1	imstb_truetype.h	/^   float x1,y1,s1,t1; \/\/ bottom-right$/;"	m	struct:__anon9
temp_bitmap	imstb_truetype.h	/^unsigned char temp_bitmap[512*512];$/;"	v
ttBYTE	imstb_truetype.h	/^#define ttBYTE(/;"	d
ttCHAR	imstb_truetype.h	/^#define ttCHAR(/;"	d
ttFixed	imstb_truetype.h	/^#define ttFixed(/;"	d
ttLONG	imstb_truetype.h	/^static stbtt_int32 ttLONG(stbtt_uint8 *p)    { return (p[0]<<24) + (p[1]<<16) + (p[2]<<8) + p[3]; }$/;"	f
ttSHORT	imstb_truetype.h	/^static stbtt_int16 ttSHORT(stbtt_uint8 *p)   { return p[0]*256 + p[1]; }$/;"	f
ttULONG	imstb_truetype.h	/^static stbtt_uint32 ttULONG(stbtt_uint8 *p)  { return (p[0]<<24) + (p[1]<<16) + (p[2]<<8) + p[3]; }$/;"	f
ttUSHORT	imstb_truetype.h	/^static stbtt_uint16 ttUSHORT(stbtt_uint8 *p) { return p[0]*256 + p[1]; }$/;"	f
ttf_buffer	imstb_truetype.h	/^char ttf_buffer[1<<25];$/;"	v
ttf_buffer	imstb_truetype.h	/^unsigned char ttf_buffer[1<<20];$/;"	v
type	imstb_truetype.h	/^      unsigned char type,padding;$/;"	m	struct:__anon13
undo_char	imstb_textedit.h	/^   STB_TEXTEDIT_CHARTYPE  undo_char[STB_TEXTEDIT_UNDOCHARCOUNT];$/;"	m	struct:__anon3
undo_char_point	imstb_textedit.h	/^   int undo_char_point, redo_char_point;$/;"	m	struct:__anon3
undo_point	imstb_textedit.h	/^   short undo_point, redo_point;$/;"	m	struct:__anon3
undo_rec	imstb_textedit.h	/^   StbUndoRecord          undo_rec [STB_TEXTEDIT_UNDOSTATECOUNT];$/;"	m	struct:__anon3
undostate	imstb_textedit.h	/^   StbUndoState undostate;$/;"	m	struct:__anon4
user_allocator_context	imstb_truetype.h	/^   void *user_allocator_context;$/;"	m	struct:stbtt_pack_context
userdata	imstb_truetype.h	/^   void           * userdata;$/;"	m	struct:stbtt_fontinfo
uv	imgui.h	/^    ImVec2  uv;$/;"	m	struct:ImDrawVert
v_oversample	imstb_truetype.h	/^   unsigned char h_oversample, v_oversample; \/\/ don't set these, they're used internally$/;"	m	struct:__anon11
v_oversample	imstb_truetype.h	/^   unsigned int   h_oversample, v_oversample;$/;"	m	struct:stbtt_pack_context
va_copy	imgui.cpp	/^#define va_copy(/;"	d	file:
val_f	imgui.h	/^        union { int val_i; float val_f; void* val_p; };$/;"	m	union:ImGuiStorage::ImGuiStoragePair::__anon1
val_i	imgui.h	/^        union { int val_i; float val_f; void* val_p; };$/;"	m	union:ImGuiStorage::ImGuiStoragePair::__anon1
val_p	imgui.h	/^        union { int val_i; float val_f; void* val_p; };$/;"	m	union:ImGuiStorage::ImGuiStoragePair::__anon1
value_type	imgui.h	/^    typedef T                   value_type;$/;"	t	struct:ImVector
vsnprintf	imgui.cpp	/^#define vsnprintf /;"	d	file:
vsnprintf	imgui_demo.cpp	/^#define vsnprintf /;"	d	file:
w	imgui.h	/^    float                                           x, y, z, w;$/;"	m	struct:ImVec4
w	imstb_rectpack.h	/^   stbrp_coord    w, h;$/;"	m	struct:stbrp_rect
w	imstb_truetype.h	/^   int id,w,h,was_packed;$/;"	m	struct:stbrp_rect
w	imstb_truetype.h	/^   int w,h,stride;$/;"	m	struct:__anon14
was_packed	imstb_rectpack.h	/^   int            was_packed;  \/\/ non-zero if valid packing$/;"	m	struct:stbrp_rect
was_packed	imstb_truetype.h	/^   int id,w,h,was_packed;$/;"	m	struct:stbrp_rect
where	imstb_textedit.h	/^   STB_TEXTEDIT_POSITIONTYPE  where;$/;"	m	struct:__anon2
width	imstb_rectpack.h	/^   int width;$/;"	m	struct:stbrp_context
width	imstb_truetype.h	/^   int   width;$/;"	m	struct:stbtt_pack_context
width	imstb_truetype.h	/^   int width,height;$/;"	m	struct:__anon23
x	imgui.h	/^    float                                           x, y, z, w;$/;"	m	struct:ImVec4
x	imgui.h	/^    float                                   x, y;$/;"	m	struct:ImVec2
x	imgui_internal.h	/^    float   x;$/;"	m	struct:ImVec1
x	imgui_internal.h	/^    short   x, y;$/;"	m	struct:ImVec2ih
x	imstb_rectpack.h	/^   int x,y;$/;"	m	struct:__anon28
x	imstb_rectpack.h	/^   stbrp_coord    x, y;$/;"	m	struct:stbrp_rect
x	imstb_rectpack.h	/^   stbrp_coord  x,y;$/;"	m	struct:stbrp_node
x	imstb_textedit.h	/^   float x,y;    \/\/ position of n'th character$/;"	m	struct:__anon6
x	imstb_truetype.h	/^      stbtt_vertex_type x,y,cx,cy,cx1,cy1;$/;"	m	struct:__anon13
x	imstb_truetype.h	/^   float x, y;$/;"	m	struct:__anon21
x	imstb_truetype.h	/^   float x,y;$/;"	m	struct:__anon22
x	imstb_truetype.h	/^   int x,dx;$/;"	m	struct:stbtt__active_edge
x	imstb_truetype.h	/^   int x,y,bottom_y;$/;"	m	struct:__anon23
x	imstb_truetype.h	/^   stbrp_coord x,y;$/;"	m	struct:stbrp_rect
x	imstb_truetype.h	/^   unsigned char x;$/;"	m	struct:__anon24
x0	imstb_textedit.h	/^   float x0,x1;             \/\/ starting x location, end x location (allows for align=right, etc)$/;"	m	struct:__anon5
x0	imstb_truetype.h	/^   float x0,y0, x1,y1;$/;"	m	struct:stbtt__edge
x0	imstb_truetype.h	/^   float x0,y0,s0,t0; \/\/ top-left$/;"	m	struct:__anon9
x0	imstb_truetype.h	/^   unsigned short x0,y0,x1,y1; \/\/ coordinates of bbox in bitmap$/;"	m	struct:__anon10
x0	imstb_truetype.h	/^   unsigned short x0,y0,x1,y1; \/\/ coordinates of bbox in bitmap$/;"	m	struct:__anon8
x1	imstb_textedit.h	/^   float x0,x1;             \/\/ starting x location, end x location (allows for align=right, etc)$/;"	m	struct:__anon5
x1	imstb_truetype.h	/^   float x0,y0, x1,y1;$/;"	m	struct:stbtt__edge
x1	imstb_truetype.h	/^   float x1,y1,s1,t1; \/\/ bottom-right$/;"	m	struct:__anon9
x1	imstb_truetype.h	/^   unsigned short x0,y0,x1,y1; \/\/ coordinates of bbox in bitmap$/;"	m	struct:__anon10
x1	imstb_truetype.h	/^   unsigned short x0,y0,x1,y1; \/\/ coordinates of bbox in bitmap$/;"	m	struct:__anon8
xadvance	imstb_truetype.h	/^   float xoff,yoff,xadvance;$/;"	m	struct:__anon10
xadvance	imstb_truetype.h	/^   float xoff,yoff,xadvance;$/;"	m	struct:__anon8
xoff	imstb_truetype.h	/^   float xoff,yoff,xadvance;$/;"	m	struct:__anon10
xoff	imstb_truetype.h	/^   float xoff,yoff,xadvance;$/;"	m	struct:__anon8
xoff2	imstb_truetype.h	/^   float xoff2,yoff2;$/;"	m	struct:__anon10
y	imgui.h	/^    float                                           x, y, z, w;$/;"	m	struct:ImVec4
y	imgui.h	/^    float                                   x, y;$/;"	m	struct:ImVec2
y	imgui_internal.h	/^    short   x, y;$/;"	m	struct:ImVec2ih
y	imstb_rectpack.h	/^   int x,y;$/;"	m	struct:__anon28
y	imstb_rectpack.h	/^   stbrp_coord    x, y;$/;"	m	struct:stbrp_rect
y	imstb_rectpack.h	/^   stbrp_coord  x,y;$/;"	m	struct:stbrp_node
y	imstb_textedit.h	/^   float x,y;    \/\/ position of n'th character$/;"	m	struct:__anon6
y	imstb_truetype.h	/^      stbtt_vertex_type x,y,cx,cy,cx1,cy1;$/;"	m	struct:__anon13
y	imstb_truetype.h	/^   float x, y;$/;"	m	struct:__anon21
y	imstb_truetype.h	/^   float x,y;$/;"	m	struct:__anon22
y	imstb_truetype.h	/^   int x,y,bottom_y;$/;"	m	struct:__anon23
y	imstb_truetype.h	/^   stbrp_coord x,y;$/;"	m	struct:stbrp_rect
y0	imstb_truetype.h	/^   float x0,y0, x1,y1;$/;"	m	struct:stbtt__edge
y0	imstb_truetype.h	/^   float x0,y0,s0,t0; \/\/ top-left$/;"	m	struct:__anon9
y0	imstb_truetype.h	/^   unsigned short x0,y0,x1,y1; \/\/ coordinates of bbox in bitmap$/;"	m	struct:__anon10
y0	imstb_truetype.h	/^   unsigned short x0,y0,x1,y1; \/\/ coordinates of bbox in bitmap$/;"	m	struct:__anon8
y1	imstb_truetype.h	/^   float x0,y0, x1,y1;$/;"	m	struct:stbtt__edge
y1	imstb_truetype.h	/^   float x1,y1,s1,t1; \/\/ bottom-right$/;"	m	struct:__anon9
y1	imstb_truetype.h	/^   unsigned short x0,y0,x1,y1; \/\/ coordinates of bbox in bitmap$/;"	m	struct:__anon10
y1	imstb_truetype.h	/^   unsigned short x0,y0,x1,y1; \/\/ coordinates of bbox in bitmap$/;"	m	struct:__anon8
ymax	imstb_textedit.h	/^   float ymin,ymax;         \/\/ height of row above and below baseline$/;"	m	struct:__anon5
ymin	imstb_textedit.h	/^   float ymin,ymax;         \/\/ height of row above and below baseline$/;"	m	struct:__anon5
yoff	imstb_truetype.h	/^   float xoff,yoff,xadvance;$/;"	m	struct:__anon10
yoff	imstb_truetype.h	/^   float xoff,yoff,xadvance;$/;"	m	struct:__anon8
yoff2	imstb_truetype.h	/^   float xoff2,yoff2;$/;"	m	struct:__anon10
z	imgui.h	/^    float                                           x, y, z, w;$/;"	m	struct:ImVec4
~ExampleAppConsole	imgui_demo.cpp	/^    ~ExampleAppConsole()$/;"	f	struct:ExampleAppConsole
~ImDrawList	imgui.h	/^    ~ImDrawList() { _ClearFreeMemory(); }$/;"	f	struct:ImDrawList
~ImDrawListSplitter	imgui.h	/^    inline ~ImDrawListSplitter() { ClearFreeMemory(); }$/;"	f	struct:ImDrawListSplitter
~ImFont	imgui_draw.cpp	/^ImFont::~ImFont()$/;"	f	class:ImFont
~ImFontAtlas	imgui_draw.cpp	/^ImFontAtlas::~ImFontAtlas()$/;"	f	class:ImFontAtlas
~ImGuiListClipper	imgui.cpp	/^ImGuiListClipper::~ImGuiListClipper()$/;"	f	class:ImGuiListClipper
~ImGuiTable	imgui_internal.h	/^    IMGUI_API ~ImGuiTable()     { IM_FREE(RawData); }$/;"	f	struct:ImGuiTable
~ImGuiViewportP	imgui_internal.h	/^    ~ImGuiViewportP()   { if (DrawLists[0]) IM_DELETE(DrawLists[0]); if (DrawLists[1]) IM_DELETE(DrawLists[1]); }$/;"	f	struct:ImGuiViewportP
~ImGuiWindow	imgui.cpp	/^ImGuiWindow::~ImGuiWindow()$/;"	f	class:ImGuiWindow
~ImPool	imgui_internal.h	/^    ~ImPool()   { Clear(); }$/;"	f	struct:ImPool
~ImVector	imgui.h	/^    inline ~ImVector()                                      { if (Data) IM_FREE(Data); }$/;"	f	struct:ImVector
